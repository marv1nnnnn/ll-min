# Specification: Refine Compaction Prompt

**Task:** `task-refine-compaction-prompt`

**Objective:** Modify the prompt generated by `get_compacting_prompt` in `src/llm_min_generator/compacter.py` to balance conciseness with the retention of essential usage details for core code components (functions, methods, classes).

**Current Problem:** The existing prompt leads to overly aggressive compression, potentially losing critical information needed to understand how to use the documented code components.

**Proposed Changes to `get_compacting_prompt` Logic:**

1.  **Instruction Refinement:** The core instructions within the prompt need adjustment.
    *   **Current (Implied):** Focus heavily on extreme conciseness, summarizing purpose broadly.
    *   **New:** Explicitly instruct the LLM to:
        *   Identify core public functions, methods, and classes.
        *   For these core components, retain:
            *   A concise one-sentence description of the purpose.
            *   Key parameters (name, type hint if available, brief description of purpose).
            *   Return value (type hint if available, brief description of what is returned).
            *   A minimal, illustrative usage example *if* it significantly clarifies usage and is very short.
        *   Continue to aggressively summarize or omit:
            *   Internal implementation details.
            *   Verbose explanations, tutorials, conceptual overviews.
            *   Code comments unless they are essential docstrings for core components.
            *   Metadata like author, date, version history.
            *   Setup, installation, or configuration instructions.
            *   Import statements (unless defining aliases crucial for understanding usage examples).
            *   Non-essential helper functions or private members.

2.  **Emphasis on Usage:** The prompt should emphasize that the goal of the compacted documentation is to enable *another LLM* to understand *how to use* the component, not just what it generally does.

3.  **JSON Output Constraint:** Reiterate clearly that the output MUST strictly adhere to the provided `OUTPUT_SCHEMA_JSON`. No extra text or deviation from the schema is allowed.

**Example Snippet (Conceptual - to be integrated into the Python f-string):**

```text
...
Your primary goal is to create a highly compact JSON representation of the provided documentation text.
Focus on extracting the essential information needed for another AI to understand *how to use* the core public functions, methods, and classes defined in the text.

For each core component (public function, method, class):
- Provide a one-sentence summary of its purpose.
- List key parameters, including their name, type (if available), and a brief description.
- Describe the return value, including its type (if available).
- Include a very short, essential usage example ONLY if it clarifies non-obvious usage patterns.

Aggressively OMIT:
- Detailed implementation logic, internal comments, private members.
- Tutorials, conceptual explanations, background information, history.
- Setup, installation, or configuration details.
- Author names, dates, version numbers.
- Standard import statements.

Ensure your entire output is valid JSON conforming strictly to this schema:
{OUTPUT_SCHEMA_JSON}

Documentation Text:
{documentation_text}
...
```

**Acceptance Criteria Check:**

*   [ ] `get_compacting_prompt` function updated. (Covered by implementation task)
*   [ ] New prompt guides LLM for more usage detail (parameters, purpose, return) for core components. (Covered by this spec)
*   [ ] Prompt still instructs omission of verbose content. (Covered by this spec)
*   [ ] Output format remains JSON adhering to `OUTPUT_SCHEMA_JSON`. (Covered by this spec)

**Next Step:** Define an implementation task (`task-implement-refined-compaction-prompt`) to apply these changes to the Python code.