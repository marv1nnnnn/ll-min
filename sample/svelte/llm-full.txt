# Documentation
Head to the Svelte or SvelteKit reference docs, or choose your adventure:
## I’m brand new here
We recommend starting with the interactive tutorial, which will teach you how to use Svelte right here in your browser.
## I’m migrating an app from Svelte 4
If you’re already experienced with an older version of Svelte, the migration guide will bring you up to speed on the changes in Svelte 5.
## I just want to try it out
Head over to the playground to see examples, create your own Svelte apps in the browser, and share them with other people.
## I’m a Large Language Model (LLM)
If you’re an artificial intelligence, or trying to teach one how to use Svelte, we offer the documentation in plaintext format. Beep boop.
## I’m looking for the old docs
If you’re developing a site using only Svelte 3 or Svelte 4, the old site may be a helpful reference until you upgrade.
## Help! I’m stuck
Join our Discord server where you can hang out with fellow Svelte users and ask them questions. It’s like an LLM but with people.


---

##  Before we begin
> If you’re new to Svelte or SvelteKit we recommend checking out the interactive tutorial.
> If you get stuck, reach out for help in the Discord chatroom.
##  What is SvelteKit?
SvelteKit is a framework for rapidly developing robust, performant web applications using Svelte. If you’re coming from React, SvelteKit is similar to Next. If you’re coming from Vue, SvelteKit is similar to Nuxt.
To learn more about the kinds of applications you can build with SvelteKit, see the documentation regarding project types.
##  What is Svelte?
In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don’t need to know Svelte to understand the rest of this guide, but it will help. If you’d like to learn more, check out the Svelte tutorial.
##  SvelteKit vs Svelte
Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.
SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a router that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes build optimizations to load only the minimal required code; offline support; preloading pages before user navigation; configurable rendering to handle different parts of your app on the server via SSR, in the browser through client-side rendering, or at build-time with prerendering; image optimization; and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.
It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging Vite with a Svelte plugin to do Hot Module Replacement (HMR).
Edit this page on GitHub llms.txt
previous next
Creating a project
##  Before we begin
> If you’re new to Svelte or SvelteKit we recommend checking out the interactive tutorial.
> If you get stuck, reach out for help in the Discord chatroom.
##  What is SvelteKit?
SvelteKit is a framework for rapidly developing robust, performant web applications using Svelte. If you’re coming from React, SvelteKit is similar to Next. If you’re coming from Vue, SvelteKit is similar to Nuxt.
To learn more about the kinds of applications you can build with SvelteKit, see the documentation regarding project types.
##  What is Svelte?
In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don’t need to know Svelte to understand the rest of this guide, but it will help. If you’d like to learn more, check out the Svelte tutorial.
##  SvelteKit vs Svelte
Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.
SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a router that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes build optimizations to load only the minimal required code; offline support; preloading pages before user navigation; configurable rendering to handle different parts of your app on the server via SSR, in the browser through client-side rendering, or at build-time with prerendering; image optimization; and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.
It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging Vite with a Svelte plugin to do Hot Module Replacement (HMR).
Edit this page on GitHub llms.txt
previous next
Creating a project
##  Before we begin
> If you’re new to Svelte or SvelteKit we recommend checking out the interactive tutorial.
> If you get stuck, reach out for help in the Discord chatroom.
##  What is SvelteKit?
SvelteKit is a framework for rapidly developing robust, performant web applications using Svelte. If you’re coming from React, SvelteKit is similar to Next. If you’re coming from Vue, SvelteKit is similar to Nuxt.
To learn more about the kinds of applications you can build with SvelteKit, see the documentation regarding project types.
##  What is Svelte?
In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don’t need to know Svelte to understand the rest of this guide, but it will help. If you’d like to learn more, check out the Svelte tutorial.
##  SvelteKit vs Svelte
Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.
SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a router that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes build optimizations to load only the minimal required code; offline support; preloading pages before user navigation; configurable rendering to handle different parts of your app on the server via SSR, in the browser through client-side rendering, or at build-time with prerendering; image optimization; and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.
It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging Vite with a Svelte plugin to do Hot Module Replacement (HMR).


---

# Docs for LLMs
We support the llms.txt convention for making documentation available to large language models and the applications that make use of them.
Currently, we have the following root-level files...
  * /llms.txt — a listing of the available files
  * /llms-full.txt — complete documentation for Svelte, SvelteKit and the CLI
  * /llms-medium.txt — compressed documentation for use with medium context windows
  * /llms-small.txt — highly compressed documentation for use with smaller context windows


...and package-level documentation:
  * /docs/svelte/llms.txt / /docs/svelte/llms-small.txt
  * /docs/kit/llms.txt / /docs/kit/llms-small.txt
  * /docs/cli/llms.txt




---

Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript...
App
```
<script>
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```
```
<script lang="ts">
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```

...into lean, tightly optimized JavaScript.
You can use it to build anything on the web, from standalone components to ambitious full stack apps (using Svelte’s companion application framework, SvelteKit) and everything in between.
These pages serve as reference documentation. If you’re new to Svelte, we recommend starting with the interactive tutorial and coming back here when you have questions.
You can also try Svelte online in the playground or, if you need a more fully-featured environment, on StackBlitz.
Edit this page on GitHub llms.txt
previous next
Getting started
Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript...
App
```
<script>
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```
```
<script lang="ts">
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```

...into lean, tightly optimized JavaScript.
You can use it to build anything on the web, from standalone components to ambitious full stack apps (using Svelte’s companion application framework, SvelteKit) and everything in between.
These pages serve as reference documentation. If you’re new to Svelte, we recommend starting with the interactive tutorial and coming back here when you have questions.
You can also try Svelte online in the playground or, if you need a more fully-featured environment, on StackBlitz.
Edit this page on GitHub llms.txt
previous next
Getting started
Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript...
App
```
<script>
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```
```
<script lang="ts">
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```

...into lean, tightly optimized JavaScript.
You can use it to build anything on the web, from standalone components to ambitious full stack apps (using Svelte’s companion application framework, SvelteKit) and everything in between.
These pages serve as reference documentation. If you’re new to Svelte, we recommend starting with the interactive tutorial and coming back here when you have questions.
You can also try Svelte online in the playground or, if you need a more fully-featured environment, on StackBlitz.


---

Version 5 comes with an overhauled syntax and reactivity system. While it may look different at first, you’ll soon notice many similarities. This guide goes over the changes in detail and shows you how to upgrade. Along with it, we also provide information on _why_ we did these changes.
You don’t have to migrate to the new syntax right away - Svelte 5 still supports the old Svelte 4 syntax, and you can mix and match components using the new syntax with components using the old and vice versa. We expect many people to be able to upgrade with only a few lines of code changed initially. There’s also a migration script that helps you with many of these steps automatically.
##  Reactivity syntax changes
At the heart of Svelte 5 is the new runes API. Runes are basically compiler instructions that inform Svelte about reactivity. Syntactically, runes are functions starting with a dollar-sign.
###  let → $state
In Svelte 4, a `let` declaration at the top level of a component was implicitly reactive. In Svelte 5, things are more explicit: a variable is reactive when created using the `$state` rune. Let’s migrate the counter to runes mode by wrapping the counter in `$state`:
```
<script>
	let count = $state(0);
</script>
```

Nothing else changes. `count` is still the number itself, and you read and write directly to it, without a wrapper like `.value` or `getCount()`.
> Why we did this
> `let` being implicitly reactive at the top level worked great, but it meant that reactivity was constrained - a `let` declaration anywhere else was not reactive. This forced you to resort to using stores when refactoring code out of the top level of components for reuse. This meant you had to learn an entirely separate reactivity model, and the result often wasn’t as nice to work with. Because reactivity is more explicit in Svelte 5, you can keep using the same API outside the top level of components. Head to the tutorial to learn more.
###  $: → $derived/$effect
In Svelte 4, a `$:` statement at the top level of a component could be used to declare a derivation, i.e. state that is entirely defined through a computation of other state. In Svelte 5, this is achieved using the `$derived` rune:
```
<script>
	let count = $state(0);
	$: const double = $derived(count * 2);
</script>
```

As with `$state`, nothing else changes. `double` is still the number itself, and you read it directly, without a wrapper like `.value` or `getDouble()`.
A `$:` statement could also be used to create side effects. In Svelte 5, this is achieved using the `$effect` rune:
```
<script>
	let count = $state(0);

	$:$effect(() => {
		if (count > 5) {
			alert('Count is too high!');
		}
	});
</script>
```

Note that when `$effect` runs is different than when `$:` runs.
> Why we did this
> `$:` was a great shorthand and easy to get started with: you could slap a `$:` in front of most code and it would somehow work. This intuitiveness was also its drawback the more complicated your code became, because it wasn’t as easy to reason about. Was the intent of the code to create a derivation, or a side effect? With `$derived` and `$effect`, you have a bit more up-front decision making to do (spoiler alert: 90% of the time you want `$derived`), but future-you and other developers on your team will have an easier time.
> There were also gotchas that were hard to spot:
>   * `$:` only updated directly before rendering, which meant you could read stale values in-between rerenders
>   * `$:` only ran once per tick, which meant that statements may run less often than you think
>   * `$:` dependencies were determined through static analysis of the dependencies. This worked in most cases, but could break in subtle ways during a refactoring where dependencies would be for example moved into a function and no longer be visible as a result
>   * `$:` statements were also ordered by using static analysis of the dependencies. In some cases there could be ties and the ordering would be wrong as a result, needing manual interventions. Ordering could also break while refactoring code and some dependencies no longer being visible as a result.
> 

> Lastly, it wasn’t TypeScript-friendly (our editor tooling had to jump through some hoops to make it valid for TypeScript), which was a blocker for making Svelte’s reactivity model truly universal.
> `$derived` and `$effect` fix all of these by
>   * always returning the latest value
>   * running as often as needed to be stable
>   * determining the dependencies at runtime, and therefore being immune to refactorings
>   * executing dependencies as needed and therefore being immune to ordering problems
>   * being TypeScript-friendly
> 

###  export let → $props
In Svelte 4, properties of a component were declared using `export let`. Each property was one declaration. In Svelte 5, all properties are declared through the `$props` rune, through destructuring:
```
<script>
	export let optional = 'unset';
	export let required;
	let { optional = 'unset', required } = $props();
</script>
```

There are multiple cases where declaring properties becomes less straightforward than having a few `export let` declarations:
  * you want to rename the property, for example because the name is a reserved identifier (e.g. `class`)
  * you don’t know which other properties to expect in advance
  * you want to forward every property to another component


All these cases need special syntax in Svelte 4:
  * renaming: `export { klass as class}`
  * other properties: `$$restProps`
  * all properties `$$props`


In Svelte 5, the `$props` rune makes this straightforward without any additional Svelte-specific syntax:
  * renaming: use property renaming `let { class: klass } = $props();`
  * other properties: use spreading `let { foo, bar, ...rest } = $props();`
  * all properties: don’t destructure `let props = $props();`


```
<script>
	let klass = '';
	export { klass as class};
	let { class: klass, ...rest } = $props();
</script>
<button class={klass} {...$$restPropsrest}>click me</button>
```

> Why we did this
> `export let` was one of the more controversial API decisions, and there was a lot of debate about whether you should think about a property being `export`ed or `import`ed. `$props` doesn’t have this trait. It’s also in line with the other runes, and the general thinking reduces to “everything special to reactivity in Svelte is a rune”.
> There were also a lot of limitations around `export let`, which required additional API, as shown above. `$props` unite this in one syntactical concept that leans heavily on regular JavaScript destructuring syntax.
##  Event changes
Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the `on:` directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):
```
<script>
	let count = $state(0);
</script>

<button on:click={() => count++}>
	clicks: {count}
</button>
```

Since they’re just properties, you can use the normal shorthand syntax...
```
<script>
	let count = $state(0);

	function onclick() {
		count++;
	}
</script>

<button {onclick}>
	clicks: {count}
</button>
```

...though when using a named event handler function it’s usually better to use a more descriptive name.
###  Component events
In Svelte 4, components could emit events by creating a dispatcher with `createEventDispatcher`.
This function is deprecated in Svelte 5. Instead, components should accept _callback props_ - which means you then pass functions as properties to these components:
App
```
<script>
	import Pump from './Pump.svelte';

	let size = $state(15);
	let burst = $state(false);

	function reset() {
		size = 15;
		burst = false;
	}
</script>

<Pump
	on:inflate={(power) => {
		size += power.detail;
		if (size > 75) burst = true;
	}}
	on:deflate={(power) => {
		if (size > 0) size -= power.detail;
	}}
/>

{#if burst}
	<button onclick={reset}>new balloon</button>
	<span class="boom">💥</span>
{:else}
	<span class="balloon" style="scale: {0.01 * size}">
		🎈
	</span>
{/if}
```
```
<script lang="ts">
	import Pump from './Pump.svelte';

	let size = $state(15);
	let burst = $state(false);

	function reset() {
		size = 15;
		burst = false;
	}
</script>

<Pump
	on:inflate={(power) => {
		size += power.detail;
		if (size > 75) burst = true;
	}}
	on:deflate={(power) => {
		if (size > 0) size -= power.detail;
	}}
/>

{#if burst}
	<button onclick={reset}>new balloon</button>
	<span class="boom">💥</span>
{:else}
	<span class="balloon" style="scale: {0.01 * size}">
		🎈
	</span>
{/if}
```

Pump
```
<script>
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();

	let { inflate, deflate } = $props();
	let power = $state(5);
</script>

<button onclick={() => dispatch('inflate', power)inflate(power)}>
	inflate
</button>
<button onclick={() => dispatch('deflate', power)deflate(power)}>
	deflate
</button>
<button onclick={() => power--}>-</button>
Pump power: {power}
<button onclick={() => power++}>+</button>
```
```
<script lang="ts">
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();

	let { inflate, deflate } = $props();
	let power = $state(5);
</script>

<button onclick={() => dispatch('inflate', power)inflate(power)}>
	inflate
</button>
<button onclick={() => dispatch('deflate', power)deflate(power)}>
	deflate
</button>
<button onclick={() => power--}>-</button>
Pump power: {power}
<button onclick={() => power++}>+</button>
```

###  Bubbling events
Instead of doing `<button on:click>` to ‘forward’ the event from the element to the component, the component should accept an `onclick` callback prop:
```
<script>
	let { onclick } = $props();
</script>

<button on:click {onclick}>
	click me
</button>
```

Note that this also means you can ‘spread’ event handlers onto the element along with other props instead of tediously forwarding each event separately:
```
<script>
	let props = $props();
</script>

<button {...$$props} on:click on:keydown on:all_the_other_stuff {...props}>
	click me
</button>
```

###  Event modifiers
In Svelte 4, you can add event modifiers to handlers:
```
<button on:click|once|preventDefault={handler}>...</button>
```

Modifiers are specific to `on:` and as such do not work with modern event handlers. Adding things like `event.preventDefault()` inside the handler itself is preferable, since all the logic lives in one place rather than being split between handler and modifiers.
Since event handlers are just functions, you can create your own wrappers as necessary:
```
<script>
	function once(fn) {
		return function (event) {
			if (fn) fn.call(this, event);
			fn = null;
		};
	}

	function preventDefault(fn) {
		return function (event) {
			event.preventDefault();
			fn.call(this, event);
		};
	}
</script>

<button onclick={once(preventDefault(handler))}>...</button>
```

There are three modifiers — `capture`, `passive` and `nonpassive` — that can’t be expressed as wrapper functions, since they need to be applied when the event handler is bound rather than when it runs.
For `capture`, we add the modifier to the event name:
```
<button onclickcapture={...}>...</button>
```

Changing the `passive` option of an event handler, meanwhile, is not something to be done lightly. If you have a use case for it — and you probably don’t! — then you will need to use an action to apply the event handler yourself.
###  Multiple event handlers
In Svelte 4, this is possible:
```
<button on:click={one} on:click={two}>...</button>
```

Duplicate attributes/properties on elements — which now includes event handlers — are not allowed. Instead, do this:
```
<button
	onclick={(e) => {
		one(e);
		two(e);
	}}
>
	...
</button>
```

When spreading props, local event handlers must go _after_ the spread, or they risk being overwritten:
```
<button
	{...props}
	onclick={(e) => {
		doStuff(e);
		props.onclick?.(e);
	}}
>
	...
</button>
```

> Why we did this
> `createEventDispatcher` was always a bit boilerplate-y:
>   * import the function
>   * call the function to get a dispatch function
>   * call said dispatch function with a string and possibly a payload
>   * retrieve said payload on the other end through a `.detail` property, because the event itself was always a `CustomEvent`
> 

> It was always possible to use component callback props, but because you had to listen to DOM events using `on:`, it made sense to use `createEventDispatcher` for component events due to syntactical consistency. Now that we have event attributes (`onclick`), it’s the other way around: Callback props are now the more sensible thing to do.
> The removal of event modifiers is arguably one of the changes that seems like a step back for those who’ve liked the shorthand syntax of event modifiers. Given that they are not used that frequently, we traded a smaller surface area for more explicitness. Modifiers also were inconsistent, because most of them were only useable on DOM elements.
> Multiple listeners for the same event are also no longer possible, but it was something of an anti-pattern anyway, since it impedes readability: if there are many attributes, it becomes harder to spot that there are two handlers unless they are right next to each other. It also implies that the two handlers are independent, when in fact something like `event.stopImmediatePropagation()` inside `one` would prevent `two` from being called.
> By deprecating `createEventDispatcher` and the `on:` directive in favour of callback props and normal element properties, we:
>   * reduce Svelte’s learning curve
>   * remove boilerplate, particularly around `createEventDispatcher`
>   * remove the overhead of creating `CustomEvent` objects for events that may not even have listeners
>   * add the ability to spread event handlers
>   * add the ability to know which event handlers were provided to a component
>   * add the ability to express whether a given event handler is required or optional
>   * increase type safety (previously, it was effectively impossible for Svelte to guarantee that a component didn’t emit a particular event)
> 

##  Snippets instead of slots
In Svelte 4, content can be passed to components using slots. Svelte 5 replaces them with snippets which are more powerful and flexible, and as such slots are deprecated in Svelte 5.
They continue to work, however, and you can pass snippets to a component that uses slots:
Child
```
<slot />
<hr />
<slot name="foo" message="hello" />
```

Parent
```
<script>
	import Child from './Child.svelte';
</script>

<Child>
	default child content

	{#snippet foo({ message })}
		message from child: {message}
	{/snippet}
</Child>
```
```
<script lang="ts">
	import Child from './Child.svelte';
</script>

<Child>
	default child content

	{#snippet foo({ message })}
		message from child: {message}
	{/snippet}
</Child>
```

(The reverse is not true — you cannot pass slotted content to a component that uses `{@render ...}` tags.)
When using custom elements, you should still use `<slot />` like before. In a future version, when Svelte removes its internal version of slots, it will leave those slots as-is, i.e. output a regular DOM tag instead of transforming it.
###  Default content
In Svelte 4, the easiest way to pass a piece of UI to the child was using a `<slot />`. In Svelte 5, this is done using the `children` prop instead, which is then shown with `{@render children()}`:
```
<script>
	let { children } = $props();
</script>

<slot />
{@render children?.()}
```

###  Multiple content placeholders
If you wanted multiple UI placeholders, you had to use named slots. In Svelte 5, use props instead, name them however you like and `{@render ...}` them:
```
<script>
	let { header, main, footer } = $props();
</script>

<header>
	<slot name="header" />
	{@render header()}
</header>

<main>
	<slot name="main" />
	{@render main()}
</main>

<footer>
	<slot name="footer" />
	{@render footer()}
</footer>
```

###  Passing data back up
In Svelte 4, you would pass data to a `<slot />` and then retrieve it with `let:` in the parent component. In Svelte 5, snippets take on that responsibility:
App
```
<script>
	import List from './List.svelte';
</script>

<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```
```
<script lang="ts">
	import List from './List.svelte';
</script>

<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```

List
```
<script>
	let { items, item, empty } = $props();
</script>

{#if items.length}
	<ul>
		{#each items as entry}
			<li>
				<slot item={entry} />
				{@render item(entry)}
			</li>
		{/each}
	</ul>
{:else}
	<slot name="empty" />
	{@render empty?.()}
{/if}
```
```
<script lang="ts">
	let { items, item, empty } = $props();
</script>

{#if items.length}
	<ul>
		{#each items as entry}
			<li>
				<slot item={entry} />
				{@render item(entry)}
			</li>
		{/each}
	</ul>
{:else}
	<slot name="empty" />
	{@render empty?.()}
{/if}
```

> Why we did this
> Slots were easy to get started with, but the more advanced the use case became, the more involved and confusing the syntax became:
>   * the `let:` syntax was confusing to many people as it _creates_ a variable whereas all other `:` directives _receive_ a variable
>   * the scope of a variable declared with `let:` wasn’t clear. In the example above, it may look like you can use the `item` slot prop in the `empty` slot, but that’s not true
>   * named slots had to be applied to an element using the `slot` attribute. Sometimes you didn’t want to create an element, so we had to add the `<svelte:fragment>` API
>   * named slots could also be applied to a component, which changed the semantics of where `let:` directives are available (even today us maintainers often don’t know which way around it works)
> 

> Snippets solve all of these problems by being much more readable and clear. At the same time they’re more powerful as they allow you to define sections of UI that you can render _anywhere_ , not just passing them as props to a component.
##  Migration script
By now you should have a pretty good understanding of the before/after and how the old syntax relates to the new syntax. It probably also became clear that a lot of these migrations are rather technical and repetitive - something you don’t want to do by hand.
We thought the same, which is why we provide a migration script to do most of the migration automatically. You can upgrade your project by using `npx sv migrate svelte-5`. This will do the following things:
  * bump core dependencies in your `package.json`
  * migrate to runes (`let` → `$state` etc)
  * migrate to event attributes for DOM elements (`on:click` → `onclick`)
  * migrate slot creations to render tags (`<slot />` → `{@render children()}`)
  * migrate slot usages to snippets (`<div slot="x">...</div>` → `{#snippet x()}<div>...</div>{/snippet}`)
  * migrate obvious component creations (`new Component(...)` → `mount(Component, ...)`)


You can also migrate a single component in VS Code through the `Migrate Component to Svelte 5 Syntax` command, or in our Playground through the `Migrate` button.
Not everything can be migrated automatically, and some migrations need manual cleanup afterwards. The following sections describe these in more detail.
###  run
You may see that the migration script converts some of your `$:` statements to a `run` function which is imported from `svelte/legacy`. This happens if the migration script couldn’t reliably migrate the statement to a `$derived` and concluded this is a side effect instead. In some cases this may be wrong and it’s best to change this to use a `$derived` instead. In other cases it may be right, but since `$:` statements also ran on the server but `$effect` does not, it isn’t safe to transform it as such. Instead, `run` is used as a stopgap solution. `run` mimics most of the characteristics of `$:`, in that it runs on the server once, and runs as `$effect.pre` on the client (`$effect.pre` runs _before_ changes are applied to the DOM; most likely you want to use `$effect` instead).
```
<script>
	import { run } from 'svelte/legacy';
	run(() => {
	$effect(() => {
		// some side effect code
	})
</script>
```

###  Event modifiers
Event modifiers are not applicable to event attributes (e.g. you can’t do `onclick|preventDefault={...}`). Therefore, when migrating event directives to event attributes, we need a function-replacement for these modifiers. These are imported from `svelte/legacy`, and should be migrated away from in favor of e.g. just using `event.preventDefault()`.
```
<script>
	import { preventDefault } from 'svelte/legacy';
</script>

<button
	onclick={preventDefault((event) => {
		event.preventDefault();
		// ...
	})}
>
	click me
</button>
```

###  Things that are not automigrated
The migration script does not convert `createEventDispatcher`. You need to adjust those parts manually. It doesn’t do it because it’s too risky because it could result in breakage for users of the component, which the migration script cannot find out.
The migration script does not convert `beforeUpdate/afterUpdate`. It doesn’t do it because it’s impossible to determine the actual intent of the code. As a rule of thumb you can often go with a combination of `$effect.pre` (runs at the same time as `beforeUpdate` did) and `tick` (imported from `svelte`, allows you to wait until changes are applied to the DOM and then do some work).
##  Components are no longer classes
In Svelte 3 and 4, components are classes. In Svelte 5 they are functions and should be instantiated differently. If you need to manually instantiate components, you should use `mount` or `hydrate` (imported from `svelte`) instead. If you see this error using SvelteKit, try updating to the latest version of SvelteKit first, which adds support for Svelte 5. If you’re using Svelte without SvelteKit, you’ll likely have a `main.js` file (or similar) which you need to adjust:
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); export default ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app;`
```

`mount` and `hydrate` have the exact same API. The difference is that `hydrate` will pick up the Svelte’s server-rendered HTML inside its target and hydrate it. Both return an object with the exports of the component and potentially property accessors (if compiled with `accessors: true`). They do not come with the `$on`, `$set` and `$destroy` methods you may know from the class component API. These are its replacements:
For `$on`, instead of listening to events, pass them via the `events` property on the options argument.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); app.$on('event', callback); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `events?: Record<string, (e: any) => any> | undefined`
Allows the specification of events.
@deprecatedUse callback props instead.
events: { `event: any`event: callback } });`
```

> Note that using `events` is discouraged — instead, use callbacks
For `$set`, use `$state` instead to create a reactive property object and manipulate it. If you’re doing this inside a `.js` or `.ts` file, adjust the ending to include `.svelte`, i.e. `.svelte.js` or `.svelte.ts`.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.$set({ foo: 'baz' }); const ````
const props: {
    foo: string;
}
```
`props = ````
function $state<{
    foo: string;
}>(initial: {
    foo: string;
}): {
    foo: string;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `foo: string`foo: 'bar' }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `props?: Record<string, any> | undefined`
Component properties.
props }); ````
const props: {
    foo: string;
}
```
`props.`foo: string`foo = 'baz';`
```

For `$destroy`, use `unmount` instead.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.$destroy(); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app);`
```

As a stop-gap-solution, you can also use `createClassComponent` or `asClassComponent` (imported from `svelte/legacy`) instead to keep the same API known from Svelte 4 after instantiating.
```
import { ```
function createClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(options: ComponentConstructorOptions<Props> & {
    component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
}): SvelteComponent<Props, Events, Slots> & Exports
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent } from 'svelte/legacy'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); const `const app: SvelteComponent<Record<string, any>, any, any> & Record<string, any>`app = ````
createClassComponent<Record<string, any>, Record<string, any>, any, any>(options: ComponentConstructorOptions<Record<string, any>> & {
    component: Component<...> | ComponentType<...>;
}): SvelteComponent<...> & Record<...>
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent({ `component: Component<Record<string, any>, {}, string> | ComponentType<SvelteComponent<Record<string, any>, any, any>>`component: `const App: LegacyComponentType`App, `ComponentConstructorOptions<Props extends Record<string, any> = Record<string, any>>.target: Document | Element | ShadowRoot`target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); export default `const app: SvelteComponent<Record<string, any>, any, any> & Record<string, any>`app;`
```

If this component is not under your control, you can use the `compatibility.componentApi` compiler option for auto-applied backwards compatibility, which means code using `new Component(...)` keeps working without adjustments (note that this adds a bit of overhead to each component). This will also add `$set` and `$on` methods for all component instances you get through `bind:this`.
```
/// svelte.config.js
export default {
	```
compilerOptions: {
    compatibility: {
        componentApi: number;
    };
}
```
`compilerOptions: { ````
compatibility: {
    componentApi: number;
}
```
`compatibility: { `componentApi: number`componentApi: 4 } } };`
```

Note that `mount` and `hydrate` are _not_ synchronous, so things like `onMount` won’t have been called by the time the function returns and the pending block of promises will not have been rendered yet (because `#await` waits a microtask to wait for a potentially immediately-resolved promise). If you need that guarantee, call `flushSync` (import from `'svelte'`) after calling `mount/hydrate`.
###  Server API changes
Similarly, components no longer have a `render` method when compiled for server side rendering. Instead, pass the function to `render` from `svelte/server`:
```
import { ```
function render<Comp extends SvelteComponent<any> | Component<any>, Props extends ComponentProps<Comp> = ComponentProps<Comp>>(...args: {} extends Props ? [component: Comp extends SvelteComponent<any> ? ComponentType<Comp> : Comp, options?: {
    props?: Omit<Props, "$$slots" | "$$events">;
    context?: Map<any, any>;
    idPrefix?: string;
}] : [component: Comp extends SvelteComponent<any> ? ComponentType<Comp> : Comp, options: {
    props: Omit<Props, "$$slots" | "$$events">;
    context?: Map<any, any>;
    idPrefix?: string;
}]): RenderOutput
```
`
Only available on the server and when compiling with the `server` option. Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
render } from 'svelte/server'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte'; const { html, head } = App.render({ props: { message: 'hello' }}); const { `const html: string`html, `const head: string`
HTML that goes into the `&#x3C;head>`
head } = ````
render<SvelteComponent<Record<string, any>, any, any>, Record<string, any>>(component: ComponentType<SvelteComponent<Record<string, any>, any, any>>, options?: {
    ...;
} | undefined): RenderOutput
```
`
Only available on the server and when compiling with the `server` option. Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
render(`const App: LegacyComponentType`App, { `props?: Omit<Record<string, any>, "$$slots" | "$$events"> | undefined`props: { `message: string`message: 'hello' }});`
```

In Svelte 4, rendering a component to a string also returned the CSS of all components. In Svelte 5, this is no longer the case by default because most of the time you’re using a tooling chain that takes care of it in other ways (like SvelteKit). If you need CSS to be returned from `render`, you can set the `css` compiler option to `'injected'` and it will add `<style>` elements to the `head`.
###  Component typing changes
The change from classes towards functions is also reflected in the typings: `SvelteComponent`, the base class from Svelte 4, is deprecated in favour of the new `Component` type which defines the function shape of a Svelte component. To manually define a component shape in a `d.ts` file:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; export declare const ````
const MyComponent: Component<{
    foo: string;
}, {}, string>
```
`MyComponent: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string; }>;`
```

To declare that a component of a certain type is required:
```
import { import ComponentAComponentA, import ComponentBComponentB } from 'component-library';
import type { SvelteComponent } from 'svelte';
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; let C: typeof SvelteComponent<{ foo: string }> = $state( let ````
let C: Component<{
    foo: string;
}, {}, string>
```
`C: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string }> = ````
function $state<any>(initial: any): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state( `var Math: Math`
An intrinsic object that provides basic mathematics functionality and constants.
Math.`Math.random(): number`
Returns a pseudorandom number between 0 and 1.
random() ? `import ComponentA`ComponentA : `import ComponentB`ComponentB );`
```

The two utility types `ComponentEvents` and `ComponentType` are also deprecated. `ComponentEvents` is obsolete because events are defined as callback props now, and `ComponentType` is obsolete because the new `Component` type is the component type already (i.e. `ComponentType<SvelteComponent<{ prop: string }>>` is equivalent to `Component<{ prop: string }>`).
###  bind:this changes
Because components are no longer classes, using `bind:this` no longer returns a class instance with `$set`, `$on` and `$destroy` methods on it. It only returns the instance exports (`export function/const`) and, if you’re using the `accessors` option, a getter/setter-pair for each property.
##  <svelte:component> is no longer necessary
In Svelte 4, components are _static_ — if you render `<Thing>`, and the value of `Thing` changes, nothing happens. To make it dynamic you had to use `<svelte:component>`.
This is no longer true in Svelte 5:
```
<script>
	import A from './A.svelte';
	import B from './B.svelte';

	let Thing = $state();
</script>

<select bind:value={Thing}>
	<option value={A}>A</option>
	<option value={B}>B</option>
</select>

<!-- these are equivalent -->
<Thing />
<svelte:component this={Thing} />
```

While migrating, keep in mind that your component’s name should be capitalized (`Thing`) to distinguish it from elements, unless using dot notation.
###  Dot notation indicates a component
In Svelte 4, `<foo.bar>` would create an element with a tag name of `"foo.bar"`. In Svelte 5, `foo.bar` is treated as a component instead. This is particularly useful inside `each` blocks:
```
{#each items as item}
	<item.component {...item.props} />
{/each}
```

##  Whitespace handling changed
Previously, Svelte employed a very complicated algorithm to determine if whitespace should be kept or not. Svelte 5 simplifies this which makes it easier to reason about as a developer. The rules are:
  * Whitespace between nodes is collapsed to one whitespace
  * Whitespace at the start and end of a tag is removed completely
  * Certain exceptions apply such as keeping whitespace inside `pre` tags


As before, you can disable whitespace trimming by setting the `preserveWhitespace` option in your compiler settings or on a per-component basis in `<svelte:options>`.
##  Modern browser required
Svelte 5 requires a modern browser (in other words, not Internet Explorer) for various reasons:
  * it uses `Proxies`
  * elements with `clientWidth` / `clientHeight`/`offsetWidth`/`offsetHeight` bindings use a `ResizeObserver` rather than a convoluted `<iframe>` hack
  * `<input type="range" bind:value={...} />` only uses an `input` event listener, rather than also listening for `change` events as a fallback


The `legacy` compiler option, which generated bulkier but IE-friendly code, no longer exists.
##  Changes to compiler options
  * The `false` / `true` (already deprecated previously) and the `"none"` values were removed as valid values from the `css` option
  * The `legacy` option was repurposed
  * The `hydratable` option has been removed. Svelte components are always hydratable now
  * The `enableSourcemap` option has been removed. Source maps are always generated now, tooling can choose to ignore it
  * The `tag` option was removed. Use `<svelte:options customElement="tag-name" />` inside the component instead
  * The `loopGuardTimeout`, `format`, `sveltePath`, `errorMode` and `varsReport` options were removed


##  The children prop is reserved
Content inside component tags becomes a snippet prop called `children`. You cannot have a separate prop by that name.
##  Breaking changes in runes mode
Some breaking changes only apply once your component is in runes mode.
###  Bindings to component exports are not allowed
Exports from runes mode components cannot be bound to directly. For example, having `export const foo = ...` in component `A` and then doing `<A bind:foo />` causes an error. Use `bind:this` instead — `<A bind:this={a} />` — and access the export as `a.foo`. This change makes things easier to reason about, as it enforces a clear separation between props and exports.
###  Bindings need to be explicitly defined using $bindable()
In Svelte 4 syntax, every property (declared via `export let`) is bindable, meaning you can `bind:` to it. In runes mode, properties are not bindable by default: you need to denote bindable props with the `$bindable` rune.
If a bindable property has a default value (e.g. `let { foo = $bindable('bar') } = $props();`), you need to pass a non-`undefined` value to that property if you’re binding to it. This prevents ambiguous behavior — the parent and child must have the same value — and results in better performance (in Svelte 4, the default value was reflected back to the parent, resulting in wasteful additional render cycles).
###  accessors option is ignored
Setting the `accessors` option to `true` makes properties of a component directly accessible on the component instance.
```
<svelte:options accessors={true} />

<script>
	// available via componentInstance.name
	export let name;
</script>
```

In runes mode, properties are never accessible on the component instance. You can use component exports instead if you need to expose them.
```
<script>
	let { name } = $props();
	// available via componentInstance.getName()
	export const getName = () => name;
</script>
```

Alternatively, if the place where they are instantiated is under your control, you can also make use of runes inside `.js/.ts` files by adjusting their ending to include `.svelte`, i.e. `.svelte.js` or `.svelte.ts`, and then use `$state`:
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.foo = 'baz' const ````
const props: {
    foo: string;
}
```
`props = ````
function $state<{
    foo: string;
}>(initial: {
    foo: string;
}): {
    foo: string;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `foo: string`foo: 'bar' }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `props?: Record<string, any> | undefined`
Component properties.
props }); ````
const props: {
    foo: string;
}
```
`props.`foo: string`foo = 'baz';`
```

###  immutable option is ignored
Setting the `immutable` option has no effect in runes mode. This concept is replaced by how `$state` and its variations work.
###  Classes are no longer “auto-reactive”
In Svelte 4, doing the following triggered reactivity:
```
<script>
	let foo = new Foo();
</script>

<button on:click={() => (foo.value = 1)}>{foo.value}</button
>
```

This is because the Svelte compiler treated the assignment to `foo.value` as an instruction to update anything that referenced `foo`. In Svelte 5, reactivity is determined at runtime rather than compile time, so you should define `value` as a reactive `$state` field on the `Foo` class. Wrapping `new Foo()` with `$state(...)` will have no effect — only vanilla objects and arrays are made deeply reactive.
###  Touch and wheel events are passive
When using `onwheel`, `onmousewheel`, `ontouchstart` and `ontouchmove` event attributes, the handlers are passive to align with browser defaults. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls `event.preventDefault()`.
In the very rare cases that you need to prevent these event defaults, you should use `on` instead (for example inside an action).
###  Attribute/prop syntax is stricter
In Svelte 4, complex attribute values needn’t be quoted:
```
<Component prop=this{is}valid />
```

This is a footgun. In runes mode, if you want to concatenate stuff you must wrap the value in quotes:
```
<Component prop="this{is}valid" />
```

Note that Svelte 5 will also warn if you have a single expression wrapped in quotes, like `answer="{42}"` — in Svelte 6, that will cause the value to be converted to a string, rather than passed as a number.
###  HTML structure is stricter
In Svelte 4, you were allowed to write HTML code that would be repaired by the browser when server side rendering it. For example you could write this...
```
<table>
	<tr>
		<td>hi</td>
	</tr>
</table>
```

... and the browser would auto-insert a `<tbody>` element:
```
<table>
	<tbody>
		<tr>
			<td>hi</td>
		</tr>
	</tbody>
</table>
```

Svelte 5 is more strict about the HTML structure and will throw a compiler error in cases where the browser would repair the DOM.
##  Other breaking changes
###  Stricter @const assignment validation
Assignments to destructured parts of a `@const` declaration are no longer allowed. It was an oversight that this was ever allowed.
###  :is(...) and :where(...) are scoped
Previously, Svelte did not analyse selectors inside `:is(...)` and `:where(...)`, effectively treating them as global. Svelte 5 analyses them in the context of the current component. As such, some selectors may now be treated as unused if they were relying on this treatment. To fix this, use `:global(...)` inside the `:is(...)/:where(...)` selectors.
When using Tailwind’s `@apply` directive, add a `:global` selector to preserve rules that use Tailwind-generated `:is(...)` selectors:
```
main :global {
	@apply bg-blue-100 dark:bg-blue-900;
}
```

###  CSS hash position no longer deterministic
Previously Svelte would always insert the CSS hash last. This is no longer guaranteed in Svelte 5. This is only breaking if you have very weird css selectors.
###  Scoped CSS uses :where(...)
To avoid issues caused by unpredictable specificity changes, scoped CSS selectors now use `:where(.svelte-xyz123)` selector modifiers alongside `.svelte-xyz123` (where `xyz123` is, as previously, a hash of the `<style>` contents). You can read more detail here.
In the event that you need to support ancient browsers that don’t implement `:where`, you can manually alter the emitted CSS, at the cost of unpredictable specificity changes:
```
css = css.replace(/:where\((.+?)\)/, '$1');


```

###  Error/warning codes have been renamed
Error and warning codes have been renamed. Previously they used dashes to separate the words, they now use underscores (e.g. foo-bar becomes foo_bar). Additionally, a handful of codes have been reworded slightly.
###  Reduced number of namespaces
The number of valid namespaces you can pass to the compiler option `namespace` has been reduced to `html` (the default), `mathml` and `svg`.
The `foreign` namespace was only useful for Svelte Native, which we’re planning to support differently in a 5.x minor.
###  beforeUpdate/afterUpdate changes
`beforeUpdate` no longer runs twice on initial render if it modifies a variable referenced in the template.
`afterUpdate` callbacks in a parent component will now run after `afterUpdate` callbacks in any child components.
`beforeUpdate/afterUpdate` no longer run when the component contains a `<slot>` and its content is updated.
Both functions are disallowed in runes mode — use `$effect.pre(...)` and `$effect(...)` instead.
###  contenteditable behavior change
If you have a `contenteditable` node with a corresponding binding _and_ a reactive value inside it (example: `<div contenteditable=true bind:textContent>count is {count}</div>`), then the value inside the contenteditable will not be updated by updates to `count` because the binding takes full control over the content immediately and it should only be updated through it.
###  oneventname attributes no longer accept string values
In Svelte 4, it was possible to specify event attributes on HTML elements as a string:
```
<button onclick="alert('hello')">...</button>
```

This is not recommended, and is no longer possible in Svelte 5, where properties like `onclick` replace `on:click` as the mechanism for adding event handlers.
###  null and undefined become the empty string
In Svelte 4, `null` and `undefined` were printed as the corresponding string. In 99 out of 100 cases you want this to become the empty string instead, which is also what most other frameworks out there do. Therefore, in Svelte 5, `null` and `undefined` become the empty string.
###  bind:files values can only be null, undefined or FileList
`bind:files` is now a two-way binding. As such, when setting a value, it needs to be either falsy (`null` or `undefined`) or of type `FileList`.
###  Bindings now react to form resets
Previously, bindings did not take into account `reset` event of forms, and therefore values could get out of sync with the DOM. Svelte 5 fixes this by placing a `reset` listener on the document and invoking bindings where necessary.
###  walk no longer exported
`svelte/compiler` reexported `walk` from `estree-walker` for convenience. This is no longer true in Svelte 5, import it directly from that package instead in case you need it.
###  Content inside svelte:options is forbidden
In Svelte 4 you could have content inside a `<svelte:options />` tag. It was ignored, but you could write something in there. In Svelte 5, content inside that tag is a compiler error.
###  <slot> elements in declarative shadow roots are preserved
Svelte 4 replaced the `<slot />` tag in all places with its own version of slots. Svelte 5 preserves them in the case they are a child of a `<template shadowrootmode="...">` element.
###  <svelte:element> tag must be an expression
In Svelte 4, `<svelte:element this="div">` is valid code. This makes little sense — you should just do `<div>`. In the vanishingly rare case that you _do_ need to use a literal value for some reason, you can do this:
```
<svelte:element this={"div"}>
```

Note that whereas Svelte 4 would treat `<svelte:element this="input">` (for example) identically to `<input>` for the purposes of determining which `bind:` directives could be applied, Svelte 5 does not.
###  mount plays transitions by default
The `mount` function used to render a component tree plays transitions by default unless the `intro` option is set to `false`. This is different from legacy class components which, when manually instantiated, didn’t play transitions by default.
###  <img src={...}> and {@html ...} hydration mismatches are not repaired
In Svelte 4, if the value of a `src` attribute or `{@html ...}` tag differ between server and client (a.k.a. a hydration mismatch), the mismatch is repaired. This is very costly: setting a `src` attribute (even if it evaluates to the same thing) causes images and iframes to be reloaded, and reinserting a large blob of HTML is slow.
Since these mismatches are extremely rare, Svelte 5 assumes that the values are unchanged, but in development will warn you if they are not. To force an update you can do something like this:
```
<script>
	let { markup, src } = $props();

	if (typeof window !== 'undefined') {
		// stash the values...
		const initial = { markup, src };

		// unset them...
		markup = src = undefined;

		$effect(() => {
			// ...and reset after we've mounted
			markup = initial.markup;
			src = initial.src;
		});
	}
</script>

{@html markup}
<img {src} />
```

###  Hydration works differently
Svelte 5 makes use of comments during server side rendering which are used for more robust and efficient hydration on the client. As such, you shouldn’t remove comments from your HTML output if you intend to hydrate it, and if you manually authored HTML to be hydrated by a Svelte component, you need to adjust that HTML to include said comments at the correct positions.
###  onevent attributes are delegated
Event attributes replace event directives: Instead of `on:click={handler}` you write `onclick={handler}`. For backwards compatibility the `on:event` syntax is still supported and behaves the same as in Svelte 4. Some of the `onevent` attributes however are delegated, which means you need to take care to not stop event propagation on those manually, as they then might never reach the listener for this event type at the root.
###  --style-props uses a different element
Svelte 5 uses an extra `<svelte-css-wrapper>` element instead of a `<div>` to wrap the component when using CSS custom properties.
Edit this page on GitHub llms.txt
previous next
Svelte 4 migration guide Frequently asked questions
Version 5 comes with an overhauled syntax and reactivity system. While it may look different at first, you’ll soon notice many similarities. This guide goes over the changes in detail and shows you how to upgrade. Along with it, we also provide information on _why_ we did these changes.
You don’t have to migrate to the new syntax right away - Svelte 5 still supports the old Svelte 4 syntax, and you can mix and match components using the new syntax with components using the old and vice versa. We expect many people to be able to upgrade with only a few lines of code changed initially. There’s also a migration script that helps you with many of these steps automatically.
##  Reactivity syntax changes
At the heart of Svelte 5 is the new runes API. Runes are basically compiler instructions that inform Svelte about reactivity. Syntactically, runes are functions starting with a dollar-sign.
###  let → $state
In Svelte 4, a `let` declaration at the top level of a component was implicitly reactive. In Svelte 5, things are more explicit: a variable is reactive when created using the `$state` rune. Let’s migrate the counter to runes mode by wrapping the counter in `$state`:
```
<script>
	let count = $state(0);
</script>
```

Nothing else changes. `count` is still the number itself, and you read and write directly to it, without a wrapper like `.value` or `getCount()`.
> Why we did this
> `let` being implicitly reactive at the top level worked great, but it meant that reactivity was constrained - a `let` declaration anywhere else was not reactive. This forced you to resort to using stores when refactoring code out of the top level of components for reuse. This meant you had to learn an entirely separate reactivity model, and the result often wasn’t as nice to work with. Because reactivity is more explicit in Svelte 5, you can keep using the same API outside the top level of components. Head to the tutorial to learn more.
###  $: → $derived/$effect
In Svelte 4, a `$:` statement at the top level of a component could be used to declare a derivation, i.e. state that is entirely defined through a computation of other state. In Svelte 5, this is achieved using the `$derived` rune:
```
<script>
	let count = $state(0);
	$: const double = $derived(count * 2);
</script>
```

As with `$state`, nothing else changes. `double` is still the number itself, and you read it directly, without a wrapper like `.value` or `getDouble()`.
A `$:` statement could also be used to create side effects. In Svelte 5, this is achieved using the `$effect` rune:
```
<script>
	let count = $state(0);

	$:$effect(() => {
		if (count > 5) {
			alert('Count is too high!');
		}
	});
</script>
```

Note that when `$effect` runs is different than when `$:` runs.
> Why we did this
> `$:` was a great shorthand and easy to get started with: you could slap a `$:` in front of most code and it would somehow work. This intuitiveness was also its drawback the more complicated your code became, because it wasn’t as easy to reason about. Was the intent of the code to create a derivation, or a side effect? With `$derived` and `$effect`, you have a bit more up-front decision making to do (spoiler alert: 90% of the time you want `$derived`), but future-you and other developers on your team will have an easier time.
> There were also gotchas that were hard to spot:
>   * `$:` only updated directly before rendering, which meant you could read stale values in-between rerenders
>   * `$:` only ran once per tick, which meant that statements may run less often than you think
>   * `$:` dependencies were determined through static analysis of the dependencies. This worked in most cases, but could break in subtle ways during a refactoring where dependencies would be for example moved into a function and no longer be visible as a result
>   * `$:` statements were also ordered by using static analysis of the dependencies. In some cases there could be ties and the ordering would be wrong as a result, needing manual interventions. Ordering could also break while refactoring code and some dependencies no longer being visible as a result.
> 

> Lastly, it wasn’t TypeScript-friendly (our editor tooling had to jump through some hoops to make it valid for TypeScript), which was a blocker for making Svelte’s reactivity model truly universal.
> `$derived` and `$effect` fix all of these by
>   * always returning the latest value
>   * running as often as needed to be stable
>   * determining the dependencies at runtime, and therefore being immune to refactorings
>   * executing dependencies as needed and therefore being immune to ordering problems
>   * being TypeScript-friendly
> 

###  export let → $props
In Svelte 4, properties of a component were declared using `export let`. Each property was one declaration. In Svelte 5, all properties are declared through the `$props` rune, through destructuring:
```
<script>
	export let optional = 'unset';
	export let required;
	let { optional = 'unset', required } = $props();
</script>
```

There are multiple cases where declaring properties becomes less straightforward than having a few `export let` declarations:
  * you want to rename the property, for example because the name is a reserved identifier (e.g. `class`)
  * you don’t know which other properties to expect in advance
  * you want to forward every property to another component


All these cases need special syntax in Svelte 4:
  * renaming: `export { klass as class}`
  * other properties: `$$restProps`
  * all properties `$$props`


In Svelte 5, the `$props` rune makes this straightforward without any additional Svelte-specific syntax:
  * renaming: use property renaming `let { class: klass } = $props();`
  * other properties: use spreading `let { foo, bar, ...rest } = $props();`
  * all properties: don’t destructure `let props = $props();`


```
<script>
	let klass = '';
	export { klass as class};
	let { class: klass, ...rest } = $props();
</script>
<button class={klass} {...$$restPropsrest}>click me</button>
```

> Why we did this
> `export let` was one of the more controversial API decisions, and there was a lot of debate about whether you should think about a property being `export`ed or `import`ed. `$props` doesn’t have this trait. It’s also in line with the other runes, and the general thinking reduces to “everything special to reactivity in Svelte is a rune”.
> There were also a lot of limitations around `export let`, which required additional API, as shown above. `$props` unite this in one syntactical concept that leans heavily on regular JavaScript destructuring syntax.
##  Event changes
Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the `on:` directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):
```
<script>
	let count = $state(0);
</script>

<button on:click={() => count++}>
	clicks: {count}
</button>
```

Since they’re just properties, you can use the normal shorthand syntax...
```
<script>
	let count = $state(0);

	function onclick() {
		count++;
	}
</script>

<button {onclick}>
	clicks: {count}
</button>
```

...though when using a named event handler function it’s usually better to use a more descriptive name.
###  Component events
In Svelte 4, components could emit events by creating a dispatcher with `createEventDispatcher`.
This function is deprecated in Svelte 5. Instead, components should accept _callback props_ - which means you then pass functions as properties to these components:
App
```
<script>
	import Pump from './Pump.svelte';

	let size = $state(15);
	let burst = $state(false);

	function reset() {
		size = 15;
		burst = false;
	}
</script>

<Pump
	on:inflate={(power) => {
		size += power.detail;
		if (size > 75) burst = true;
	}}
	on:deflate={(power) => {
		if (size > 0) size -= power.detail;
	}}
/>

{#if burst}
	<button onclick={reset}>new balloon</button>
	<span class="boom">💥</span>
{:else}
	<span class="balloon" style="scale: {0.01 * size}">
		🎈
	</span>
{/if}
```
```
<script lang="ts">
	import Pump from './Pump.svelte';

	let size = $state(15);
	let burst = $state(false);

	function reset() {
		size = 15;
		burst = false;
	}
</script>

<Pump
	on:inflate={(power) => {
		size += power.detail;
		if (size > 75) burst = true;
	}}
	on:deflate={(power) => {
		if (size > 0) size -= power.detail;
	}}
/>

{#if burst}
	<button onclick={reset}>new balloon</button>
	<span class="boom">💥</span>
{:else}
	<span class="balloon" style="scale: {0.01 * size}">
		🎈
	</span>
{/if}
```

Pump
```
<script>
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();

	let { inflate, deflate } = $props();
	let power = $state(5);
</script>

<button onclick={() => dispatch('inflate', power)inflate(power)}>
	inflate
</button>
<button onclick={() => dispatch('deflate', power)deflate(power)}>
	deflate
</button>
<button onclick={() => power--}>-</button>
Pump power: {power}
<button onclick={() => power++}>+</button>
```
```
<script lang="ts">
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();

	let { inflate, deflate } = $props();
	let power = $state(5);
</script>

<button onclick={() => dispatch('inflate', power)inflate(power)}>
	inflate
</button>
<button onclick={() => dispatch('deflate', power)deflate(power)}>
	deflate
</button>
<button onclick={() => power--}>-</button>
Pump power: {power}
<button onclick={() => power++}>+</button>
```

###  Bubbling events
Instead of doing `<button on:click>` to ‘forward’ the event from the element to the component, the component should accept an `onclick` callback prop:
```
<script>
	let { onclick } = $props();
</script>

<button on:click {onclick}>
	click me
</button>
```

Note that this also means you can ‘spread’ event handlers onto the element along with other props instead of tediously forwarding each event separately:
```
<script>
	let props = $props();
</script>

<button {...$$props} on:click on:keydown on:all_the_other_stuff {...props}>
	click me
</button>
```

###  Event modifiers
In Svelte 4, you can add event modifiers to handlers:
```
<button on:click|once|preventDefault={handler}>...</button>
```

Modifiers are specific to `on:` and as such do not work with modern event handlers. Adding things like `event.preventDefault()` inside the handler itself is preferable, since all the logic lives in one place rather than being split between handler and modifiers.
Since event handlers are just functions, you can create your own wrappers as necessary:
```
<script>
	function once(fn) {
		return function (event) {
			if (fn) fn.call(this, event);
			fn = null;
		};
	}

	function preventDefault(fn) {
		return function (event) {
			event.preventDefault();
			fn.call(this, event);
		};
	}
</script>

<button onclick={once(preventDefault(handler))}>...</button>
```

There are three modifiers — `capture`, `passive` and `nonpassive` — that can’t be expressed as wrapper functions, since they need to be applied when the event handler is bound rather than when it runs.
For `capture`, we add the modifier to the event name:
```
<button onclickcapture={...}>...</button>
```

Changing the `passive` option of an event handler, meanwhile, is not something to be done lightly. If you have a use case for it — and you probably don’t! — then you will need to use an action to apply the event handler yourself.
###  Multiple event handlers
In Svelte 4, this is possible:
```
<button on:click={one} on:click={two}>...</button>
```

Duplicate attributes/properties on elements — which now includes event handlers — are not allowed. Instead, do this:
```
<button
	onclick={(e) => {
		one(e);
		two(e);
	}}
>
	...
</button>
```

When spreading props, local event handlers must go _after_ the spread, or they risk being overwritten:
```
<button
	{...props}
	onclick={(e) => {
		doStuff(e);
		props.onclick?.(e);
	}}
>
	...
</button>
```

> Why we did this
> `createEventDispatcher` was always a bit boilerplate-y:
>   * import the function
>   * call the function to get a dispatch function
>   * call said dispatch function with a string and possibly a payload
>   * retrieve said payload on the other end through a `.detail` property, because the event itself was always a `CustomEvent`
> 

> It was always possible to use component callback props, but because you had to listen to DOM events using `on:`, it made sense to use `createEventDispatcher` for component events due to syntactical consistency. Now that we have event attributes (`onclick`), it’s the other way around: Callback props are now the more sensible thing to do.
> The removal of event modifiers is arguably one of the changes that seems like a step back for those who’ve liked the shorthand syntax of event modifiers. Given that they are not used that frequently, we traded a smaller surface area for more explicitness. Modifiers also were inconsistent, because most of them were only useable on DOM elements.
> Multiple listeners for the same event are also no longer possible, but it was something of an anti-pattern anyway, since it impedes readability: if there are many attributes, it becomes harder to spot that there are two handlers unless they are right next to each other. It also implies that the two handlers are independent, when in fact something like `event.stopImmediatePropagation()` inside `one` would prevent `two` from being called.
> By deprecating `createEventDispatcher` and the `on:` directive in favour of callback props and normal element properties, we:
>   * reduce Svelte’s learning curve
>   * remove boilerplate, particularly around `createEventDispatcher`
>   * remove the overhead of creating `CustomEvent` objects for events that may not even have listeners
>   * add the ability to spread event handlers
>   * add the ability to know which event handlers were provided to a component
>   * add the ability to express whether a given event handler is required or optional
>   * increase type safety (previously, it was effectively impossible for Svelte to guarantee that a component didn’t emit a particular event)
> 

##  Snippets instead of slots
In Svelte 4, content can be passed to components using slots. Svelte 5 replaces them with snippets which are more powerful and flexible, and as such slots are deprecated in Svelte 5.
They continue to work, however, and you can pass snippets to a component that uses slots:
Child
```
<slot />
<hr />
<slot name="foo" message="hello" />
```

Parent
```
<script>
	import Child from './Child.svelte';
</script>

<Child>
	default child content

	{#snippet foo({ message })}
		message from child: {message}
	{/snippet}
</Child>
```
```
<script lang="ts">
	import Child from './Child.svelte';
</script>

<Child>
	default child content

	{#snippet foo({ message })}
		message from child: {message}
	{/snippet}
</Child>
```

(The reverse is not true — you cannot pass slotted content to a component that uses `{@render ...}` tags.)
When using custom elements, you should still use `<slot />` like before. In a future version, when Svelte removes its internal version of slots, it will leave those slots as-is, i.e. output a regular DOM tag instead of transforming it.
###  Default content
In Svelte 4, the easiest way to pass a piece of UI to the child was using a `<slot />`. In Svelte 5, this is done using the `children` prop instead, which is then shown with `{@render children()}`:
```
<script>
	let { children } = $props();
</script>

<slot />
{@render children?.()}
```

###  Multiple content placeholders
If you wanted multiple UI placeholders, you had to use named slots. In Svelte 5, use props instead, name them however you like and `{@render ...}` them:
```
<script>
	let { header, main, footer } = $props();
</script>

<header>
	<slot name="header" />
	{@render header()}
</header>

<main>
	<slot name="main" />
	{@render main()}
</main>

<footer>
	<slot name="footer" />
	{@render footer()}
</footer>
```

###  Passing data back up
In Svelte 4, you would pass data to a `<slot />` and then retrieve it with `let:` in the parent component. In Svelte 5, snippets take on that responsibility:
App
```
<script>
	import List from './List.svelte';
</script>

<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```
```
<script lang="ts">
	import List from './List.svelte';
</script>

<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```

List
```
<script>
	let { items, item, empty } = $props();
</script>

{#if items.length}
	<ul>
		{#each items as entry}
			<li>
				<slot item={entry} />
				{@render item(entry)}
			</li>
		{/each}
	</ul>
{:else}
	<slot name="empty" />
	{@render empty?.()}
{/if}
```
```
<script lang="ts">
	let { items, item, empty } = $props();
</script>

{#if items.length}
	<ul>
		{#each items as entry}
			<li>
				<slot item={entry} />
				{@render item(entry)}
			</li>
		{/each}
	</ul>
{:else}
	<slot name="empty" />
	{@render empty?.()}
{/if}
```

> Why we did this
> Slots were easy to get started with, but the more advanced the use case became, the more involved and confusing the syntax became:
>   * the `let:` syntax was confusing to many people as it _creates_ a variable whereas all other `:` directives _receive_ a variable
>   * the scope of a variable declared with `let:` wasn’t clear. In the example above, it may look like you can use the `item` slot prop in the `empty` slot, but that’s not true
>   * named slots had to be applied to an element using the `slot` attribute. Sometimes you didn’t want to create an element, so we had to add the `<svelte:fragment>` API
>   * named slots could also be applied to a component, which changed the semantics of where `let:` directives are available (even today us maintainers often don’t know which way around it works)
> 

> Snippets solve all of these problems by being much more readable and clear. At the same time they’re more powerful as they allow you to define sections of UI that you can render _anywhere_ , not just passing them as props to a component.
##  Migration script
By now you should have a pretty good understanding of the before/after and how the old syntax relates to the new syntax. It probably also became clear that a lot of these migrations are rather technical and repetitive - something you don’t want to do by hand.
We thought the same, which is why we provide a migration script to do most of the migration automatically. You can upgrade your project by using `npx sv migrate svelte-5`. This will do the following things:
  * bump core dependencies in your `package.json`
  * migrate to runes (`let` → `$state` etc)
  * migrate to event attributes for DOM elements (`on:click` → `onclick`)
  * migrate slot creations to render tags (`<slot />` → `{@render children()}`)
  * migrate slot usages to snippets (`<div slot="x">...</div>` → `{#snippet x()}<div>...</div>{/snippet}`)
  * migrate obvious component creations (`new Component(...)` → `mount(Component, ...)`)


You can also migrate a single component in VS Code through the `Migrate Component to Svelte 5 Syntax` command, or in our Playground through the `Migrate` button.
Not everything can be migrated automatically, and some migrations need manual cleanup afterwards. The following sections describe these in more detail.
###  run
You may see that the migration script converts some of your `$:` statements to a `run` function which is imported from `svelte/legacy`. This happens if the migration script couldn’t reliably migrate the statement to a `$derived` and concluded this is a side effect instead. In some cases this may be wrong and it’s best to change this to use a `$derived` instead. In other cases it may be right, but since `$:` statements also ran on the server but `$effect` does not, it isn’t safe to transform it as such. Instead, `run` is used as a stopgap solution. `run` mimics most of the characteristics of `$:`, in that it runs on the server once, and runs as `$effect.pre` on the client (`$effect.pre` runs _before_ changes are applied to the DOM; most likely you want to use `$effect` instead).
```
<script>
	import { run } from 'svelte/legacy';
	run(() => {
	$effect(() => {
		// some side effect code
	})
</script>
```

###  Event modifiers
Event modifiers are not applicable to event attributes (e.g. you can’t do `onclick|preventDefault={...}`). Therefore, when migrating event directives to event attributes, we need a function-replacement for these modifiers. These are imported from `svelte/legacy`, and should be migrated away from in favor of e.g. just using `event.preventDefault()`.
```
<script>
	import { preventDefault } from 'svelte/legacy';
</script>

<button
	onclick={preventDefault((event) => {
		event.preventDefault();
		// ...
	})}
>
	click me
</button>
```

###  Things that are not automigrated
The migration script does not convert `createEventDispatcher`. You need to adjust those parts manually. It doesn’t do it because it’s too risky because it could result in breakage for users of the component, which the migration script cannot find out.
The migration script does not convert `beforeUpdate/afterUpdate`. It doesn’t do it because it’s impossible to determine the actual intent of the code. As a rule of thumb you can often go with a combination of `$effect.pre` (runs at the same time as `beforeUpdate` did) and `tick` (imported from `svelte`, allows you to wait until changes are applied to the DOM and then do some work).
##  Components are no longer classes
In Svelte 3 and 4, components are classes. In Svelte 5 they are functions and should be instantiated differently. If you need to manually instantiate components, you should use `mount` or `hydrate` (imported from `svelte`) instead. If you see this error using SvelteKit, try updating to the latest version of SvelteKit first, which adds support for Svelte 5. If you’re using Svelte without SvelteKit, you’ll likely have a `main.js` file (or similar) which you need to adjust:
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); export default ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app;`
```

`mount` and `hydrate` have the exact same API. The difference is that `hydrate` will pick up the Svelte’s server-rendered HTML inside its target and hydrate it. Both return an object with the exports of the component and potentially property accessors (if compiled with `accessors: true`). They do not come with the `$on`, `$set` and `$destroy` methods you may know from the class component API. These are its replacements:
For `$on`, instead of listening to events, pass them via the `events` property on the options argument.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); app.$on('event', callback); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `events?: Record<string, (e: any) => any> | undefined`
Allows the specification of events.
@deprecatedUse callback props instead.
events: { `event: any`event: callback } });`
```

> Note that using `events` is discouraged — instead, use callbacks
For `$set`, use `$state` instead to create a reactive property object and manipulate it. If you’re doing this inside a `.js` or `.ts` file, adjust the ending to include `.svelte`, i.e. `.svelte.js` or `.svelte.ts`.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.$set({ foo: 'baz' }); const ````
const props: {
    foo: string;
}
```
`props = ````
function $state<{
    foo: string;
}>(initial: {
    foo: string;
}): {
    foo: string;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `foo: string`foo: 'bar' }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `props?: Record<string, any> | undefined`
Component properties.
props }); ````
const props: {
    foo: string;
}
```
`props.`foo: string`foo = 'baz';`
```

For `$destroy`, use `unmount` instead.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.$destroy(); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app);`
```

As a stop-gap-solution, you can also use `createClassComponent` or `asClassComponent` (imported from `svelte/legacy`) instead to keep the same API known from Svelte 4 after instantiating.
```
import { ```
function createClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(options: ComponentConstructorOptions<Props> & {
    component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
}): SvelteComponent<Props, Events, Slots> & Exports
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent } from 'svelte/legacy'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); const `const app: SvelteComponent<Record<string, any>, any, any> & Record<string, any>`app = ````
createClassComponent<Record<string, any>, Record<string, any>, any, any>(options: ComponentConstructorOptions<Record<string, any>> & {
    component: Component<...> | ComponentType<...>;
}): SvelteComponent<...> & Record<...>
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent({ `component: Component<Record<string, any>, {}, string> | ComponentType<SvelteComponent<Record<string, any>, any, any>>`component: `const App: LegacyComponentType`App, `ComponentConstructorOptions<Props extends Record<string, any> = Record<string, any>>.target: Document | Element | ShadowRoot`target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); export default `const app: SvelteComponent<Record<string, any>, any, any> & Record<string, any>`app;`
```

If this component is not under your control, you can use the `compatibility.componentApi` compiler option for auto-applied backwards compatibility, which means code using `new Component(...)` keeps working without adjustments (note that this adds a bit of overhead to each component). This will also add `$set` and `$on` methods for all component instances you get through `bind:this`.
```
/// svelte.config.js
export default {
	```
compilerOptions: {
    compatibility: {
        componentApi: number;
    };
}
```
`compilerOptions: { ````
compatibility: {
    componentApi: number;
}
```
`compatibility: { `componentApi: number`componentApi: 4 } } };`
```

Note that `mount` and `hydrate` are _not_ synchronous, so things like `onMount` won’t have been called by the time the function returns and the pending block of promises will not have been rendered yet (because `#await` waits a microtask to wait for a potentially immediately-resolved promise). If you need that guarantee, call `flushSync` (import from `'svelte'`) after calling `mount/hydrate`.
###  Server API changes
Similarly, components no longer have a `render` method when compiled for server side rendering. Instead, pass the function to `render` from `svelte/server`:
```
import { ```
function render<Comp extends SvelteComponent<any> | Component<any>, Props extends ComponentProps<Comp> = ComponentProps<Comp>>(...args: {} extends Props ? [component: Comp extends SvelteComponent<any> ? ComponentType<Comp> : Comp, options?: {
    props?: Omit<Props, "$$slots" | "$$events">;
    context?: Map<any, any>;
    idPrefix?: string;
}] : [component: Comp extends SvelteComponent<any> ? ComponentType<Comp> : Comp, options: {
    props: Omit<Props, "$$slots" | "$$events">;
    context?: Map<any, any>;
    idPrefix?: string;
}]): RenderOutput
```
`
Only available on the server and when compiling with the `server` option. Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
render } from 'svelte/server'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte'; const { html, head } = App.render({ props: { message: 'hello' }}); const { `const html: string`html, `const head: string`
HTML that goes into the `&#x3C;head>`
head } = ````
render<SvelteComponent<Record<string, any>, any, any>, Record<string, any>>(component: ComponentType<SvelteComponent<Record<string, any>, any, any>>, options?: {
    ...;
} | undefined): RenderOutput
```
`
Only available on the server and when compiling with the `server` option. Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
render(`const App: LegacyComponentType`App, { `props?: Omit<Record<string, any>, "$$slots" | "$$events"> | undefined`props: { `message: string`message: 'hello' }});`
```

In Svelte 4, rendering a component to a string also returned the CSS of all components. In Svelte 5, this is no longer the case by default because most of the time you’re using a tooling chain that takes care of it in other ways (like SvelteKit). If you need CSS to be returned from `render`, you can set the `css` compiler option to `'injected'` and it will add `<style>` elements to the `head`.
###  Component typing changes
The change from classes towards functions is also reflected in the typings: `SvelteComponent`, the base class from Svelte 4, is deprecated in favour of the new `Component` type which defines the function shape of a Svelte component. To manually define a component shape in a `d.ts` file:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; export declare const ````
const MyComponent: Component<{
    foo: string;
}, {}, string>
```
`MyComponent: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string; }>;`
```

To declare that a component of a certain type is required:
```
import { import ComponentAComponentA, import ComponentBComponentB } from 'component-library';
import type { SvelteComponent } from 'svelte';
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; let C: typeof SvelteComponent<{ foo: string }> = $state( let ````
let C: Component<{
    foo: string;
}, {}, string>
```
`C: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string }> = ````
function $state<any>(initial: any): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state( `var Math: Math`
An intrinsic object that provides basic mathematics functionality and constants.
Math.`Math.random(): number`
Returns a pseudorandom number between 0 and 1.
random() ? `import ComponentA`ComponentA : `import ComponentB`ComponentB );`
```

The two utility types `ComponentEvents` and `ComponentType` are also deprecated. `ComponentEvents` is obsolete because events are defined as callback props now, and `ComponentType` is obsolete because the new `Component` type is the component type already (i.e. `ComponentType<SvelteComponent<{ prop: string }>>` is equivalent to `Component<{ prop: string }>`).
###  bind:this changes
Because components are no longer classes, using `bind:this` no longer returns a class instance with `$set`, `$on` and `$destroy` methods on it. It only returns the instance exports (`export function/const`) and, if you’re using the `accessors` option, a getter/setter-pair for each property.
##  <svelte:component> is no longer necessary
In Svelte 4, components are _static_ — if you render `<Thing>`, and the value of `Thing` changes, nothing happens. To make it dynamic you had to use `<svelte:component>`.
This is no longer true in Svelte 5:
```
<script>
	import A from './A.svelte';
	import B from './B.svelte';

	let Thing = $state();
</script>

<select bind:value={Thing}>
	<option value={A}>A</option>
	<option value={B}>B</option>
</select>

<!-- these are equivalent -->
<Thing />
<svelte:component this={Thing} />
```

While migrating, keep in mind that your component’s name should be capitalized (`Thing`) to distinguish it from elements, unless using dot notation.
###  Dot notation indicates a component
In Svelte 4, `<foo.bar>` would create an element with a tag name of `"foo.bar"`. In Svelte 5, `foo.bar` is treated as a component instead. This is particularly useful inside `each` blocks:
```
{#each items as item}
	<item.component {...item.props} />
{/each}
```

##  Whitespace handling changed
Previously, Svelte employed a very complicated algorithm to determine if whitespace should be kept or not. Svelte 5 simplifies this which makes it easier to reason about as a developer. The rules are:
  * Whitespace between nodes is collapsed to one whitespace
  * Whitespace at the start and end of a tag is removed completely
  * Certain exceptions apply such as keeping whitespace inside `pre` tags


As before, you can disable whitespace trimming by setting the `preserveWhitespace` option in your compiler settings or on a per-component basis in `<svelte:options>`.
##  Modern browser required
Svelte 5 requires a modern browser (in other words, not Internet Explorer) for various reasons:
  * it uses `Proxies`
  * elements with `clientWidth` / `clientHeight`/`offsetWidth`/`offsetHeight` bindings use a `ResizeObserver` rather than a convoluted `<iframe>` hack
  * `<input type="range" bind:value={...} />` only uses an `input` event listener, rather than also listening for `change` events as a fallback


The `legacy` compiler option, which generated bulkier but IE-friendly code, no longer exists.
##  Changes to compiler options
  * The `false` / `true` (already deprecated previously) and the `"none"` values were removed as valid values from the `css` option
  * The `legacy` option was repurposed
  * The `hydratable` option has been removed. Svelte components are always hydratable now
  * The `enableSourcemap` option has been removed. Source maps are always generated now, tooling can choose to ignore it
  * The `tag` option was removed. Use `<svelte:options customElement="tag-name" />` inside the component instead
  * The `loopGuardTimeout`, `format`, `sveltePath`, `errorMode` and `varsReport` options were removed


##  The children prop is reserved
Content inside component tags becomes a snippet prop called `children`. You cannot have a separate prop by that name.
##  Breaking changes in runes mode
Some breaking changes only apply once your component is in runes mode.
###  Bindings to component exports are not allowed
Exports from runes mode components cannot be bound to directly. For example, having `export const foo = ...` in component `A` and then doing `<A bind:foo />` causes an error. Use `bind:this` instead — `<A bind:this={a} />` — and access the export as `a.foo`. This change makes things easier to reason about, as it enforces a clear separation between props and exports.
###  Bindings need to be explicitly defined using $bindable()
In Svelte 4 syntax, every property (declared via `export let`) is bindable, meaning you can `bind:` to it. In runes mode, properties are not bindable by default: you need to denote bindable props with the `$bindable` rune.
If a bindable property has a default value (e.g. `let { foo = $bindable('bar') } = $props();`), you need to pass a non-`undefined` value to that property if you’re binding to it. This prevents ambiguous behavior — the parent and child must have the same value — and results in better performance (in Svelte 4, the default value was reflected back to the parent, resulting in wasteful additional render cycles).
###  accessors option is ignored
Setting the `accessors` option to `true` makes properties of a component directly accessible on the component instance.
```
<svelte:options accessors={true} />

<script>
	// available via componentInstance.name
	export let name;
</script>
```

In runes mode, properties are never accessible on the component instance. You can use component exports instead if you need to expose them.
```
<script>
	let { name } = $props();
	// available via componentInstance.getName()
	export const getName = () => name;
</script>
```

Alternatively, if the place where they are instantiated is under your control, you can also make use of runes inside `.js/.ts` files by adjusting their ending to include `.svelte`, i.e. `.svelte.js` or `.svelte.ts`, and then use `$state`:
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.foo = 'baz' const ````
const props: {
    foo: string;
}
```
`props = ````
function $state<{
    foo: string;
}>(initial: {
    foo: string;
}): {
    foo: string;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `foo: string`foo: 'bar' }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `props?: Record<string, any> | undefined`
Component properties.
props }); ````
const props: {
    foo: string;
}
```
`props.`foo: string`foo = 'baz';`
```

###  immutable option is ignored
Setting the `immutable` option has no effect in runes mode. This concept is replaced by how `$state` and its variations work.
###  Classes are no longer “auto-reactive”
In Svelte 4, doing the following triggered reactivity:
```
<script>
	let foo = new Foo();
</script>

<button on:click={() => (foo.value = 1)}>{foo.value}</button
>
```

This is because the Svelte compiler treated the assignment to `foo.value` as an instruction to update anything that referenced `foo`. In Svelte 5, reactivity is determined at runtime rather than compile time, so you should define `value` as a reactive `$state` field on the `Foo` class. Wrapping `new Foo()` with `$state(...)` will have no effect — only vanilla objects and arrays are made deeply reactive.
###  Touch and wheel events are passive
When using `onwheel`, `onmousewheel`, `ontouchstart` and `ontouchmove` event attributes, the handlers are passive to align with browser defaults. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls `event.preventDefault()`.
In the very rare cases that you need to prevent these event defaults, you should use `on` instead (for example inside an action).
###  Attribute/prop syntax is stricter
In Svelte 4, complex attribute values needn’t be quoted:
```
<Component prop=this{is}valid />
```

This is a footgun. In runes mode, if you want to concatenate stuff you must wrap the value in quotes:
```
<Component prop="this{is}valid" />
```

Note that Svelte 5 will also warn if you have a single expression wrapped in quotes, like `answer="{42}"` — in Svelte 6, that will cause the value to be converted to a string, rather than passed as a number.
###  HTML structure is stricter
In Svelte 4, you were allowed to write HTML code that would be repaired by the browser when server side rendering it. For example you could write this...
```
<table>
	<tr>
		<td>hi</td>
	</tr>
</table>
```

... and the browser would auto-insert a `<tbody>` element:
```
<table>
	<tbody>
		<tr>
			<td>hi</td>
		</tr>
	</tbody>
</table>
```

Svelte 5 is more strict about the HTML structure and will throw a compiler error in cases where the browser would repair the DOM.
##  Other breaking changes
###  Stricter @const assignment validation
Assignments to destructured parts of a `@const` declaration are no longer allowed. It was an oversight that this was ever allowed.
###  :is(...) and :where(...) are scoped
Previously, Svelte did not analyse selectors inside `:is(...)` and `:where(...)`, effectively treating them as global. Svelte 5 analyses them in the context of the current component. As such, some selectors may now be treated as unused if they were relying on this treatment. To fix this, use `:global(...)` inside the `:is(...)/:where(...)` selectors.
When using Tailwind’s `@apply` directive, add a `:global` selector to preserve rules that use Tailwind-generated `:is(...)` selectors:
```
main :global {
	@apply bg-blue-100 dark:bg-blue-900;
}
```

###  CSS hash position no longer deterministic
Previously Svelte would always insert the CSS hash last. This is no longer guaranteed in Svelte 5. This is only breaking if you have very weird css selectors.
###  Scoped CSS uses :where(...)
To avoid issues caused by unpredictable specificity changes, scoped CSS selectors now use `:where(.svelte-xyz123)` selector modifiers alongside `.svelte-xyz123` (where `xyz123` is, as previously, a hash of the `<style>` contents). You can read more detail here.
In the event that you need to support ancient browsers that don’t implement `:where`, you can manually alter the emitted CSS, at the cost of unpredictable specificity changes:
```
css = css.replace(/:where\((.+?)\)/, '$1');


```

###  Error/warning codes have been renamed
Error and warning codes have been renamed. Previously they used dashes to separate the words, they now use underscores (e.g. foo-bar becomes foo_bar). Additionally, a handful of codes have been reworded slightly.
###  Reduced number of namespaces
The number of valid namespaces you can pass to the compiler option `namespace` has been reduced to `html` (the default), `mathml` and `svg`.
The `foreign` namespace was only useful for Svelte Native, which we’re planning to support differently in a 5.x minor.
###  beforeUpdate/afterUpdate changes
`beforeUpdate` no longer runs twice on initial render if it modifies a variable referenced in the template.
`afterUpdate` callbacks in a parent component will now run after `afterUpdate` callbacks in any child components.
`beforeUpdate/afterUpdate` no longer run when the component contains a `<slot>` and its content is updated.
Both functions are disallowed in runes mode — use `$effect.pre(...)` and `$effect(...)` instead.
###  contenteditable behavior change
If you have a `contenteditable` node with a corresponding binding _and_ a reactive value inside it (example: `<div contenteditable=true bind:textContent>count is {count}</div>`), then the value inside the contenteditable will not be updated by updates to `count` because the binding takes full control over the content immediately and it should only be updated through it.
###  oneventname attributes no longer accept string values
In Svelte 4, it was possible to specify event attributes on HTML elements as a string:
```
<button onclick="alert('hello')">...</button>
```

This is not recommended, and is no longer possible in Svelte 5, where properties like `onclick` replace `on:click` as the mechanism for adding event handlers.
###  null and undefined become the empty string
In Svelte 4, `null` and `undefined` were printed as the corresponding string. In 99 out of 100 cases you want this to become the empty string instead, which is also what most other frameworks out there do. Therefore, in Svelte 5, `null` and `undefined` become the empty string.
###  bind:files values can only be null, undefined or FileList
`bind:files` is now a two-way binding. As such, when setting a value, it needs to be either falsy (`null` or `undefined`) or of type `FileList`.
###  Bindings now react to form resets
Previously, bindings did not take into account `reset` event of forms, and therefore values could get out of sync with the DOM. Svelte 5 fixes this by placing a `reset` listener on the document and invoking bindings where necessary.
###  walk no longer exported
`svelte/compiler` reexported `walk` from `estree-walker` for convenience. This is no longer true in Svelte 5, import it directly from that package instead in case you need it.
###  Content inside svelte:options is forbidden
In Svelte 4 you could have content inside a `<svelte:options />` tag. It was ignored, but you could write something in there. In Svelte 5, content inside that tag is a compiler error.
###  <slot> elements in declarative shadow roots are preserved
Svelte 4 replaced the `<slot />` tag in all places with its own version of slots. Svelte 5 preserves them in the case they are a child of a `<template shadowrootmode="...">` element.
###  <svelte:element> tag must be an expression
In Svelte 4, `<svelte:element this="div">` is valid code. This makes little sense — you should just do `<div>`. In the vanishingly rare case that you _do_ need to use a literal value for some reason, you can do this:
```
<svelte:element this={"div"}>
```

Note that whereas Svelte 4 would treat `<svelte:element this="input">` (for example) identically to `<input>` for the purposes of determining which `bind:` directives could be applied, Svelte 5 does not.
###  mount plays transitions by default
The `mount` function used to render a component tree plays transitions by default unless the `intro` option is set to `false`. This is different from legacy class components which, when manually instantiated, didn’t play transitions by default.
###  <img src={...}> and {@html ...} hydration mismatches are not repaired
In Svelte 4, if the value of a `src` attribute or `{@html ...}` tag differ between server and client (a.k.a. a hydration mismatch), the mismatch is repaired. This is very costly: setting a `src` attribute (even if it evaluates to the same thing) causes images and iframes to be reloaded, and reinserting a large blob of HTML is slow.
Since these mismatches are extremely rare, Svelte 5 assumes that the values are unchanged, but in development will warn you if they are not. To force an update you can do something like this:
```
<script>
	let { markup, src } = $props();

	if (typeof window !== 'undefined') {
		// stash the values...
		const initial = { markup, src };

		// unset them...
		markup = src = undefined;

		$effect(() => {
			// ...and reset after we've mounted
			markup = initial.markup;
			src = initial.src;
		});
	}
</script>

{@html markup}
<img {src} />
```

###  Hydration works differently
Svelte 5 makes use of comments during server side rendering which are used for more robust and efficient hydration on the client. As such, you shouldn’t remove comments from your HTML output if you intend to hydrate it, and if you manually authored HTML to be hydrated by a Svelte component, you need to adjust that HTML to include said comments at the correct positions.
###  onevent attributes are delegated
Event attributes replace event directives: Instead of `on:click={handler}` you write `onclick={handler}`. For backwards compatibility the `on:event` syntax is still supported and behaves the same as in Svelte 4. Some of the `onevent` attributes however are delegated, which means you need to take care to not stop event propagation on those manually, as they then might never reach the listener for this event type at the root.
###  --style-props uses a different element
Svelte 5 uses an extra `<svelte-css-wrapper>` element instead of a `<div>` to wrap the component when using CSS custom properties.
Edit this page on GitHub llms.txt
previous next
Svelte 4 migration guide Frequently asked questions
Version 5 comes with an overhauled syntax and reactivity system. While it may look different at first, you’ll soon notice many similarities. This guide goes over the changes in detail and shows you how to upgrade. Along with it, we also provide information on _why_ we did these changes.
You don’t have to migrate to the new syntax right away - Svelte 5 still supports the old Svelte 4 syntax, and you can mix and match components using the new syntax with components using the old and vice versa. We expect many people to be able to upgrade with only a few lines of code changed initially. There’s also a migration script that helps you with many of these steps automatically.
##  Reactivity syntax changes
At the heart of Svelte 5 is the new runes API. Runes are basically compiler instructions that inform Svelte about reactivity. Syntactically, runes are functions starting with a dollar-sign.
###  let → $state
In Svelte 4, a `let` declaration at the top level of a component was implicitly reactive. In Svelte 5, things are more explicit: a variable is reactive when created using the `$state` rune. Let’s migrate the counter to runes mode by wrapping the counter in `$state`:
```
<script>
	let count = $state(0);
</script>
```

Nothing else changes. `count` is still the number itself, and you read and write directly to it, without a wrapper like `.value` or `getCount()`.
> Why we did this
> `let` being implicitly reactive at the top level worked great, but it meant that reactivity was constrained - a `let` declaration anywhere else was not reactive. This forced you to resort to using stores when refactoring code out of the top level of components for reuse. This meant you had to learn an entirely separate reactivity model, and the result often wasn’t as nice to work with. Because reactivity is more explicit in Svelte 5, you can keep using the same API outside the top level of components. Head to the tutorial to learn more.
###  $: → $derived/$effect
In Svelte 4, a `$:` statement at the top level of a component could be used to declare a derivation, i.e. state that is entirely defined through a computation of other state. In Svelte 5, this is achieved using the `$derived` rune:
```
<script>
	let count = $state(0);
	$: const double = $derived(count * 2);
</script>
```

As with `$state`, nothing else changes. `double` is still the number itself, and you read it directly, without a wrapper like `.value` or `getDouble()`.
A `$:` statement could also be used to create side effects. In Svelte 5, this is achieved using the `$effect` rune:
```
<script>
	let count = $state(0);

	$:$effect(() => {
		if (count > 5) {
			alert('Count is too high!');
		}
	});
</script>
```

Note that when `$effect` runs is different than when `$:` runs.
> Why we did this
> `$:` was a great shorthand and easy to get started with: you could slap a `$:` in front of most code and it would somehow work. This intuitiveness was also its drawback the more complicated your code became, because it wasn’t as easy to reason about. Was the intent of the code to create a derivation, or a side effect? With `$derived` and `$effect`, you have a bit more up-front decision making to do (spoiler alert: 90% of the time you want `$derived`), but future-you and other developers on your team will have an easier time.
> There were also gotchas that were hard to spot:
>   * `$:` only updated directly before rendering, which meant you could read stale values in-between rerenders
>   * `$:` only ran once per tick, which meant that statements may run less often than you think
>   * `$:` dependencies were determined through static analysis of the dependencies. This worked in most cases, but could break in subtle ways during a refactoring where dependencies would be for example moved into a function and no longer be visible as a result
>   * `$:` statements were also ordered by using static analysis of the dependencies. In some cases there could be ties and the ordering would be wrong as a result, needing manual interventions. Ordering could also break while refactoring code and some dependencies no longer being visible as a result.
> 

> Lastly, it wasn’t TypeScript-friendly (our editor tooling had to jump through some hoops to make it valid for TypeScript), which was a blocker for making Svelte’s reactivity model truly universal.
> `$derived` and `$effect` fix all of these by
>   * always returning the latest value
>   * running as often as needed to be stable
>   * determining the dependencies at runtime, and therefore being immune to refactorings
>   * executing dependencies as needed and therefore being immune to ordering problems
>   * being TypeScript-friendly
> 

###  export let → $props
In Svelte 4, properties of a component were declared using `export let`. Each property was one declaration. In Svelte 5, all properties are declared through the `$props` rune, through destructuring:
```
<script>
	export let optional = 'unset';
	export let required;
	let { optional = 'unset', required } = $props();
</script>
```

There are multiple cases where declaring properties becomes less straightforward than having a few `export let` declarations:
  * you want to rename the property, for example because the name is a reserved identifier (e.g. `class`)
  * you don’t know which other properties to expect in advance
  * you want to forward every property to another component


All these cases need special syntax in Svelte 4:
  * renaming: `export { klass as class}`
  * other properties: `$$restProps`
  * all properties `$$props`


In Svelte 5, the `$props` rune makes this straightforward without any additional Svelte-specific syntax:
  * renaming: use property renaming `let { class: klass } = $props();`
  * other properties: use spreading `let { foo, bar, ...rest } = $props();`
  * all properties: don’t destructure `let props = $props();`


```
<script>
	let klass = '';
	export { klass as class};
	let { class: klass, ...rest } = $props();
</script>
<button class={klass} {...$$restPropsrest}>click me</button>
```

> Why we did this
> `export let` was one of the more controversial API decisions, and there was a lot of debate about whether you should think about a property being `export`ed or `import`ed. `$props` doesn’t have this trait. It’s also in line with the other runes, and the general thinking reduces to “everything special to reactivity in Svelte is a rune”.
> There were also a lot of limitations around `export let`, which required additional API, as shown above. `$props` unite this in one syntactical concept that leans heavily on regular JavaScript destructuring syntax.
##  Event changes
Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the `on:` directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):
```
<script>
	let count = $state(0);
</script>

<button on:click={() => count++}>
	clicks: {count}
</button>
```

Since they’re just properties, you can use the normal shorthand syntax...
```
<script>
	let count = $state(0);

	function onclick() {
		count++;
	}
</script>

<button {onclick}>
	clicks: {count}
</button>
```

...though when using a named event handler function it’s usually better to use a more descriptive name.
###  Component events
In Svelte 4, components could emit events by creating a dispatcher with `createEventDispatcher`.
This function is deprecated in Svelte 5. Instead, components should accept _callback props_ - which means you then pass functions as properties to these components:
App
```
<script>
	import Pump from './Pump.svelte';

	let size = $state(15);
	let burst = $state(false);

	function reset() {
		size = 15;
		burst = false;
	}
</script>

<Pump
	on:inflate={(power) => {
		size += power.detail;
		if (size > 75) burst = true;
	}}
	on:deflate={(power) => {
		if (size > 0) size -= power.detail;
	}}
/>

{#if burst}
	<button onclick={reset}>new balloon</button>
	<span class="boom">💥</span>
{:else}
	<span class="balloon" style="scale: {0.01 * size}">
		🎈
	</span>
{/if}
```
```
<script lang="ts">
	import Pump from './Pump.svelte';

	let size = $state(15);
	let burst = $state(false);

	function reset() {
		size = 15;
		burst = false;
	}
</script>

<Pump
	on:inflate={(power) => {
		size += power.detail;
		if (size > 75) burst = true;
	}}
	on:deflate={(power) => {
		if (size > 0) size -= power.detail;
	}}
/>

{#if burst}
	<button onclick={reset}>new balloon</button>
	<span class="boom">💥</span>
{:else}
	<span class="balloon" style="scale: {0.01 * size}">
		🎈
	</span>
{/if}
```

Pump
```
<script>
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();

	let { inflate, deflate } = $props();
	let power = $state(5);
</script>

<button onclick={() => dispatch('inflate', power)inflate(power)}>
	inflate
</button>
<button onclick={() => dispatch('deflate', power)deflate(power)}>
	deflate
</button>
<button onclick={() => power--}>-</button>
Pump power: {power}
<button onclick={() => power++}>+</button>
```
```
<script lang="ts">
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();

	let { inflate, deflate } = $props();
	let power = $state(5);
</script>

<button onclick={() => dispatch('inflate', power)inflate(power)}>
	inflate
</button>
<button onclick={() => dispatch('deflate', power)deflate(power)}>
	deflate
</button>
<button onclick={() => power--}>-</button>
Pump power: {power}
<button onclick={() => power++}>+</button>
```

###  Bubbling events
Instead of doing `<button on:click>` to ‘forward’ the event from the element to the component, the component should accept an `onclick` callback prop:
```
<script>
	let { onclick } = $props();
</script>

<button on:click {onclick}>
	click me
</button>
```

Note that this also means you can ‘spread’ event handlers onto the element along with other props instead of tediously forwarding each event separately:
```
<script>
	let props = $props();
</script>

<button {...$$props} on:click on:keydown on:all_the_other_stuff {...props}>
	click me
</button>
```

###  Event modifiers
In Svelte 4, you can add event modifiers to handlers:
```
<button on:click|once|preventDefault={handler}>...</button>
```

Modifiers are specific to `on:` and as such do not work with modern event handlers. Adding things like `event.preventDefault()` inside the handler itself is preferable, since all the logic lives in one place rather than being split between handler and modifiers.
Since event handlers are just functions, you can create your own wrappers as necessary:
```
<script>
	function once(fn) {
		return function (event) {
			if (fn) fn.call(this, event);
			fn = null;
		};
	}

	function preventDefault(fn) {
		return function (event) {
			event.preventDefault();
			fn.call(this, event);
		};
	}
</script>

<button onclick={once(preventDefault(handler))}>...</button>
```

There are three modifiers — `capture`, `passive` and `nonpassive` — that can’t be expressed as wrapper functions, since they need to be applied when the event handler is bound rather than when it runs.
For `capture`, we add the modifier to the event name:
```
<button onclickcapture={...}>...</button>
```

Changing the `passive` option of an event handler, meanwhile, is not something to be done lightly. If you have a use case for it — and you probably don’t! — then you will need to use an action to apply the event handler yourself.
###  Multiple event handlers
In Svelte 4, this is possible:
```
<button on:click={one} on:click={two}>...</button>
```

Duplicate attributes/properties on elements — which now includes event handlers — are not allowed. Instead, do this:
```
<button
	onclick={(e) => {
		one(e);
		two(e);
	}}
>
	...
</button>
```

When spreading props, local event handlers must go _after_ the spread, or they risk being overwritten:
```
<button
	{...props}
	onclick={(e) => {
		doStuff(e);
		props.onclick?.(e);
	}}
>
	...
</button>
```

> Why we did this
> `createEventDispatcher` was always a bit boilerplate-y:
>   * import the function
>   * call the function to get a dispatch function
>   * call said dispatch function with a string and possibly a payload
>   * retrieve said payload on the other end through a `.detail` property, because the event itself was always a `CustomEvent`
> 

> It was always possible to use component callback props, but because you had to listen to DOM events using `on:`, it made sense to use `createEventDispatcher` for component events due to syntactical consistency. Now that we have event attributes (`onclick`), it’s the other way around: Callback props are now the more sensible thing to do.
> The removal of event modifiers is arguably one of the changes that seems like a step back for those who’ve liked the shorthand syntax of event modifiers. Given that they are not used that frequently, we traded a smaller surface area for more explicitness. Modifiers also were inconsistent, because most of them were only useable on DOM elements.
> Multiple listeners for the same event are also no longer possible, but it was something of an anti-pattern anyway, since it impedes readability: if there are many attributes, it becomes harder to spot that there are two handlers unless they are right next to each other. It also implies that the two handlers are independent, when in fact something like `event.stopImmediatePropagation()` inside `one` would prevent `two` from being called.
> By deprecating `createEventDispatcher` and the `on:` directive in favour of callback props and normal element properties, we:
>   * reduce Svelte’s learning curve
>   * remove boilerplate, particularly around `createEventDispatcher`
>   * remove the overhead of creating `CustomEvent` objects for events that may not even have listeners
>   * add the ability to spread event handlers
>   * add the ability to know which event handlers were provided to a component
>   * add the ability to express whether a given event handler is required or optional
>   * increase type safety (previously, it was effectively impossible for Svelte to guarantee that a component didn’t emit a particular event)
> 

##  Snippets instead of slots
In Svelte 4, content can be passed to components using slots. Svelte 5 replaces them with snippets which are more powerful and flexible, and as such slots are deprecated in Svelte 5.
They continue to work, however, and you can pass snippets to a component that uses slots:
Child
```
<slot />
<hr />
<slot name="foo" message="hello" />
```

Parent
```
<script>
	import Child from './Child.svelte';
</script>

<Child>
	default child content

	{#snippet foo({ message })}
		message from child: {message}
	{/snippet}
</Child>
```
```
<script lang="ts">
	import Child from './Child.svelte';
</script>

<Child>
	default child content

	{#snippet foo({ message })}
		message from child: {message}
	{/snippet}
</Child>
```

(The reverse is not true — you cannot pass slotted content to a component that uses `{@render ...}` tags.)
When using custom elements, you should still use `<slot />` like before. In a future version, when Svelte removes its internal version of slots, it will leave those slots as-is, i.e. output a regular DOM tag instead of transforming it.
###  Default content
In Svelte 4, the easiest way to pass a piece of UI to the child was using a `<slot />`. In Svelte 5, this is done using the `children` prop instead, which is then shown with `{@render children()}`:
```
<script>
	let { children } = $props();
</script>

<slot />
{@render children?.()}
```

###  Multiple content placeholders
If you wanted multiple UI placeholders, you had to use named slots. In Svelte 5, use props instead, name them however you like and `{@render ...}` them:
```
<script>
	let { header, main, footer } = $props();
</script>

<header>
	<slot name="header" />
	{@render header()}
</header>

<main>
	<slot name="main" />
	{@render main()}
</main>

<footer>
	<slot name="footer" />
	{@render footer()}
</footer>
```

###  Passing data back up
In Svelte 4, you would pass data to a `<slot />` and then retrieve it with `let:` in the parent component. In Svelte 5, snippets take on that responsibility:
App
```
<script>
	import List from './List.svelte';
</script>

<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```
```
<script lang="ts">
	import List from './List.svelte';
</script>

<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```

List
```
<script>
	let { items, item, empty } = $props();
</script>

{#if items.length}
	<ul>
		{#each items as entry}
			<li>
				<slot item={entry} />
				{@render item(entry)}
			</li>
		{/each}
	</ul>
{:else}
	<slot name="empty" />
	{@render empty?.()}
{/if}
```
```
<script lang="ts">
	let { items, item, empty } = $props();
</script>

{#if items.length}
	<ul>
		{#each items as entry}
			<li>
				<slot item={entry} />
				{@render item(entry)}
			</li>
		{/each}
	</ul>
{:else}
	<slot name="empty" />
	{@render empty?.()}
{/if}
```

> Why we did this
> Slots were easy to get started with, but the more advanced the use case became, the more involved and confusing the syntax became:
>   * the `let:` syntax was confusing to many people as it _creates_ a variable whereas all other `:` directives _receive_ a variable
>   * the scope of a variable declared with `let:` wasn’t clear. In the example above, it may look like you can use the `item` slot prop in the `empty` slot, but that’s not true
>   * named slots had to be applied to an element using the `slot` attribute. Sometimes you didn’t want to create an element, so we had to add the `<svelte:fragment>` API
>   * named slots could also be applied to a component, which changed the semantics of where `let:` directives are available (even today us maintainers often don’t know which way around it works)
> 

> Snippets solve all of these problems by being much more readable and clear. At the same time they’re more powerful as they allow you to define sections of UI that you can render _anywhere_ , not just passing them as props to a component.
##  Migration script
By now you should have a pretty good understanding of the before/after and how the old syntax relates to the new syntax. It probably also became clear that a lot of these migrations are rather technical and repetitive - something you don’t want to do by hand.
We thought the same, which is why we provide a migration script to do most of the migration automatically. You can upgrade your project by using `npx sv migrate svelte-5`. This will do the following things:
  * bump core dependencies in your `package.json`
  * migrate to runes (`let` → `$state` etc)
  * migrate to event attributes for DOM elements (`on:click` → `onclick`)
  * migrate slot creations to render tags (`<slot />` → `{@render children()}`)
  * migrate slot usages to snippets (`<div slot="x">...</div>` → `{#snippet x()}<div>...</div>{/snippet}`)
  * migrate obvious component creations (`new Component(...)` → `mount(Component, ...)`)


You can also migrate a single component in VS Code through the `Migrate Component to Svelte 5 Syntax` command, or in our Playground through the `Migrate` button.
Not everything can be migrated automatically, and some migrations need manual cleanup afterwards. The following sections describe these in more detail.
###  run
You may see that the migration script converts some of your `$:` statements to a `run` function which is imported from `svelte/legacy`. This happens if the migration script couldn’t reliably migrate the statement to a `$derived` and concluded this is a side effect instead. In some cases this may be wrong and it’s best to change this to use a `$derived` instead. In other cases it may be right, but since `$:` statements also ran on the server but `$effect` does not, it isn’t safe to transform it as such. Instead, `run` is used as a stopgap solution. `run` mimics most of the characteristics of `$:`, in that it runs on the server once, and runs as `$effect.pre` on the client (`$effect.pre` runs _before_ changes are applied to the DOM; most likely you want to use `$effect` instead).
```
<script>
	import { run } from 'svelte/legacy';
	run(() => {
	$effect(() => {
		// some side effect code
	})
</script>
```

###  Event modifiers
Event modifiers are not applicable to event attributes (e.g. you can’t do `onclick|preventDefault={...}`). Therefore, when migrating event directives to event attributes, we need a function-replacement for these modifiers. These are imported from `svelte/legacy`, and should be migrated away from in favor of e.g. just using `event.preventDefault()`.
```
<script>
	import { preventDefault } from 'svelte/legacy';
</script>

<button
	onclick={preventDefault((event) => {
		event.preventDefault();
		// ...
	})}
>
	click me
</button>
```

###  Things that are not automigrated
The migration script does not convert `createEventDispatcher`. You need to adjust those parts manually. It doesn’t do it because it’s too risky because it could result in breakage for users of the component, which the migration script cannot find out.
The migration script does not convert `beforeUpdate/afterUpdate`. It doesn’t do it because it’s impossible to determine the actual intent of the code. As a rule of thumb you can often go with a combination of `$effect.pre` (runs at the same time as `beforeUpdate` did) and `tick` (imported from `svelte`, allows you to wait until changes are applied to the DOM and then do some work).
##  Components are no longer classes
In Svelte 3 and 4, components are classes. In Svelte 5 they are functions and should be instantiated differently. If you need to manually instantiate components, you should use `mount` or `hydrate` (imported from `svelte`) instead. If you see this error using SvelteKit, try updating to the latest version of SvelteKit first, which adds support for Svelte 5. If you’re using Svelte without SvelteKit, you’ll likely have a `main.js` file (or similar) which you need to adjust:
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); export default ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app;`
```

`mount` and `hydrate` have the exact same API. The difference is that `hydrate` will pick up the Svelte’s server-rendered HTML inside its target and hydrate it. Both return an object with the exports of the component and potentially property accessors (if compiled with `accessors: true`). They do not come with the `$on`, `$set` and `$destroy` methods you may know from the class component API. These are its replacements:
For `$on`, instead of listening to events, pass them via the `events` property on the options argument.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); app.$on('event', callback); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `events?: Record<string, (e: any) => any> | undefined`
Allows the specification of events.
@deprecatedUse callback props instead.
events: { `event: any`event: callback } });`
```

> Note that using `events` is discouraged — instead, use callbacks
For `$set`, use `$state` instead to create a reactive property object and manipulate it. If you’re doing this inside a `.js` or `.ts` file, adjust the ending to include `.svelte`, i.e. `.svelte.js` or `.svelte.ts`.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.$set({ foo: 'baz' }); const ````
const props: {
    foo: string;
}
```
`props = ````
function $state<{
    foo: string;
}>(initial: {
    foo: string;
}): {
    foo: string;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `foo: string`foo: 'bar' }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `props?: Record<string, any> | undefined`
Component properties.
props }); ````
const props: {
    foo: string;
}
```
`props.`foo: string`foo = 'baz';`
```

For `$destroy`, use `unmount` instead.
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.$destroy(); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app);`
```

As a stop-gap-solution, you can also use `createClassComponent` or `asClassComponent` (imported from `svelte/legacy`) instead to keep the same API known from Svelte 4 after instantiating.
```
import { ```
function createClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(options: ComponentConstructorOptions<Props> & {
    component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
}): SvelteComponent<Props, Events, Slots> & Exports
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent } from 'svelte/legacy'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app") }); const `const app: SvelteComponent<Record<string, any>, any, any> & Record<string, any>`app = ````
createClassComponent<Record<string, any>, Record<string, any>, any, any>(options: ComponentConstructorOptions<Record<string, any>> & {
    component: Component<...> | ComponentType<...>;
}): SvelteComponent<...> & Record<...>
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent({ `component: Component<Record<string, any>, {}, string> | ComponentType<SvelteComponent<Record<string, any>, any, any>>`component: `const App: LegacyComponentType`App, `ComponentConstructorOptions<Props extends Record<string, any> = Record<string, any>>.target: Document | Element | ShadowRoot`target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app") }); export default `const app: SvelteComponent<Record<string, any>, any, any> & Record<string, any>`app;`
```

If this component is not under your control, you can use the `compatibility.componentApi` compiler option for auto-applied backwards compatibility, which means code using `new Component(...)` keeps working without adjustments (note that this adds a bit of overhead to each component). This will also add `$set` and `$on` methods for all component instances you get through `bind:this`.
```
/// svelte.config.js
export default {
	```
compilerOptions: {
    compatibility: {
        componentApi: number;
    };
}
```
`compilerOptions: { ````
compatibility: {
    componentApi: number;
}
```
`compatibility: { `componentApi: number`componentApi: 4 } } };`
```

Note that `mount` and `hydrate` are _not_ synchronous, so things like `onMount` won’t have been called by the time the function returns and the pending block of promises will not have been rendered yet (because `#await` waits a microtask to wait for a potentially immediately-resolved promise). If you need that guarantee, call `flushSync` (import from `'svelte'`) after calling `mount/hydrate`.
###  Server API changes
Similarly, components no longer have a `render` method when compiled for server side rendering. Instead, pass the function to `render` from `svelte/server`:
```
import { ```
function render<Comp extends SvelteComponent<any> | Component<any>, Props extends ComponentProps<Comp> = ComponentProps<Comp>>(...args: {} extends Props ? [component: Comp extends SvelteComponent<any> ? ComponentType<Comp> : Comp, options?: {
    props?: Omit<Props, "$$slots" | "$$events">;
    context?: Map<any, any>;
    idPrefix?: string;
}] : [component: Comp extends SvelteComponent<any> ? ComponentType<Comp> : Comp, options: {
    props: Omit<Props, "$$slots" | "$$events">;
    context?: Map<any, any>;
    idPrefix?: string;
}]): RenderOutput
```
`
Only available on the server and when compiling with the `server` option. Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
render } from 'svelte/server'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte'; const { html, head } = App.render({ props: { message: 'hello' }}); const { `const html: string`html, `const head: string`
HTML that goes into the `&#x3C;head>`
head } = ````
render<SvelteComponent<Record<string, any>, any, any>, Record<string, any>>(component: ComponentType<SvelteComponent<Record<string, any>, any, any>>, options?: {
    ...;
} | undefined): RenderOutput
```
`
Only available on the server and when compiling with the `server` option. Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
render(`const App: LegacyComponentType`App, { `props?: Omit<Record<string, any>, "$$slots" | "$$events"> | undefined`props: { `message: string`message: 'hello' }});`
```

In Svelte 4, rendering a component to a string also returned the CSS of all components. In Svelte 5, this is no longer the case by default because most of the time you’re using a tooling chain that takes care of it in other ways (like SvelteKit). If you need CSS to be returned from `render`, you can set the `css` compiler option to `'injected'` and it will add `<style>` elements to the `head`.
###  Component typing changes
The change from classes towards functions is also reflected in the typings: `SvelteComponent`, the base class from Svelte 4, is deprecated in favour of the new `Component` type which defines the function shape of a Svelte component. To manually define a component shape in a `d.ts` file:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; export declare const ````
const MyComponent: Component<{
    foo: string;
}, {}, string>
```
`MyComponent: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string; }>;`
```

To declare that a component of a certain type is required:
```
import { import ComponentAComponentA, import ComponentBComponentB } from 'component-library';
import type { SvelteComponent } from 'svelte';
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; let C: typeof SvelteComponent<{ foo: string }> = $state( let ````
let C: Component<{
    foo: string;
}, {}, string>
```
`C: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string }> = ````
function $state<any>(initial: any): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state( `var Math: Math`
An intrinsic object that provides basic mathematics functionality and constants.
Math.`Math.random(): number`
Returns a pseudorandom number between 0 and 1.
random() ? `import ComponentA`ComponentA : `import ComponentB`ComponentB );`
```

The two utility types `ComponentEvents` and `ComponentType` are also deprecated. `ComponentEvents` is obsolete because events are defined as callback props now, and `ComponentType` is obsolete because the new `Component` type is the component type already (i.e. `ComponentType<SvelteComponent<{ prop: string }>>` is equivalent to `Component<{ prop: string }>`).
###  bind:this changes
Because components are no longer classes, using `bind:this` no longer returns a class instance with `$set`, `$on` and `$destroy` methods on it. It only returns the instance exports (`export function/const`) and, if you’re using the `accessors` option, a getter/setter-pair for each property.
##  <svelte:component> is no longer necessary
In Svelte 4, components are _static_ — if you render `<Thing>`, and the value of `Thing` changes, nothing happens. To make it dynamic you had to use `<svelte:component>`.
This is no longer true in Svelte 5:
```
<script>
	import A from './A.svelte';
	import B from './B.svelte';

	let Thing = $state();
</script>

<select bind:value={Thing}>
	<option value={A}>A</option>
	<option value={B}>B</option>
</select>

<!-- these are equivalent -->
<Thing />
<svelte:component this={Thing} />
```

While migrating, keep in mind that your component’s name should be capitalized (`Thing`) to distinguish it from elements, unless using dot notation.
###  Dot notation indicates a component
In Svelte 4, `<foo.bar>` would create an element with a tag name of `"foo.bar"`. In Svelte 5, `foo.bar` is treated as a component instead. This is particularly useful inside `each` blocks:
```
{#each items as item}
	<item.component {...item.props} />
{/each}
```

##  Whitespace handling changed
Previously, Svelte employed a very complicated algorithm to determine if whitespace should be kept or not. Svelte 5 simplifies this which makes it easier to reason about as a developer. The rules are:
  * Whitespace between nodes is collapsed to one whitespace
  * Whitespace at the start and end of a tag is removed completely
  * Certain exceptions apply such as keeping whitespace inside `pre` tags


As before, you can disable whitespace trimming by setting the `preserveWhitespace` option in your compiler settings or on a per-component basis in `<svelte:options>`.
##  Modern browser required
Svelte 5 requires a modern browser (in other words, not Internet Explorer) for various reasons:
  * it uses `Proxies`
  * elements with `clientWidth` / `clientHeight`/`offsetWidth`/`offsetHeight` bindings use a `ResizeObserver` rather than a convoluted `<iframe>` hack
  * `<input type="range" bind:value={...} />` only uses an `input` event listener, rather than also listening for `change` events as a fallback


The `legacy` compiler option, which generated bulkier but IE-friendly code, no longer exists.
##  Changes to compiler options
  * The `false` / `true` (already deprecated previously) and the `"none"` values were removed as valid values from the `css` option
  * The `legacy` option was repurposed
  * The `hydratable` option has been removed. Svelte components are always hydratable now
  * The `enableSourcemap` option has been removed. Source maps are always generated now, tooling can choose to ignore it
  * The `tag` option was removed. Use `<svelte:options customElement="tag-name" />` inside the component instead
  * The `loopGuardTimeout`, `format`, `sveltePath`, `errorMode` and `varsReport` options were removed


##  The children prop is reserved
Content inside component tags becomes a snippet prop called `children`. You cannot have a separate prop by that name.
##  Breaking changes in runes mode
Some breaking changes only apply once your component is in runes mode.
###  Bindings to component exports are not allowed
Exports from runes mode components cannot be bound to directly. For example, having `export const foo = ...` in component `A` and then doing `<A bind:foo />` causes an error. Use `bind:this` instead — `<A bind:this={a} />` — and access the export as `a.foo`. This change makes things easier to reason about, as it enforces a clear separation between props and exports.
###  Bindings need to be explicitly defined using $bindable()
In Svelte 4 syntax, every property (declared via `export let`) is bindable, meaning you can `bind:` to it. In runes mode, properties are not bindable by default: you need to denote bindable props with the `$bindable` rune.
If a bindable property has a default value (e.g. `let { foo = $bindable('bar') } = $props();`), you need to pass a non-`undefined` value to that property if you’re binding to it. This prevents ambiguous behavior — the parent and child must have the same value — and results in better performance (in Svelte 4, the default value was reflected back to the parent, resulting in wasteful additional render cycles).
###  accessors option is ignored
Setting the `accessors` option to `true` makes properties of a component directly accessible on the component instance.
```
<svelte:options accessors={true} />

<script>
	// available via componentInstance.name
	export let name;
</script>
```

In runes mode, properties are never accessible on the component instance. You can use component exports instead if you need to expose them.
```
<script>
	let { name } = $props();
	// available via componentInstance.getName()
	export const getName = () => name;
</script>
```

Alternatively, if the place where they are instantiated is under your control, you can also make use of runes inside `.js/.ts` files by adjusting their ending to include `.svelte`, i.e. `.svelte.js` or `.svelte.ts`, and then use `$state`:
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.



mount } from 'svelte';
import ```
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte' const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } }); app.foo = 'baz' const ````
const props: {
    foo: string;
}
```
`props = ````
function $state<{
    foo: string;
}>(initial: {
    foo: string;
}): {
    foo: string;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `foo: string`foo: 'bar' }); const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.getElementById(elementId: string): HTMLElement | null`
Returns a reference to the first object with the specified value of the ID attribute.
@paramelementId String that specifies the ID value.
getElementById("app"), `props?: Record<string, any> | undefined`
Component properties.
props }); ````
const props: {
    foo: string;
}
```
`props.`foo: string`foo = 'baz';`
```

###  immutable option is ignored
Setting the `immutable` option has no effect in runes mode. This concept is replaced by how `$state` and its variations work.
###  Classes are no longer “auto-reactive”
In Svelte 4, doing the following triggered reactivity:
```
<script>
	let foo = new Foo();
</script>

<button on:click={() => (foo.value = 1)}>{foo.value}</button
>
```

This is because the Svelte compiler treated the assignment to `foo.value` as an instruction to update anything that referenced `foo`. In Svelte 5, reactivity is determined at runtime rather than compile time, so you should define `value` as a reactive `$state` field on the `Foo` class. Wrapping `new Foo()` with `$state(...)` will have no effect — only vanilla objects and arrays are made deeply reactive.
###  Touch and wheel events are passive
When using `onwheel`, `onmousewheel`, `ontouchstart` and `ontouchmove` event attributes, the handlers are passive to align with browser defaults. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls `event.preventDefault()`.
In the very rare cases that you need to prevent these event defaults, you should use `on` instead (for example inside an action).
###  Attribute/prop syntax is stricter
In Svelte 4, complex attribute values needn’t be quoted:
```
<Component prop=this{is}valid />
```

This is a footgun. In runes mode, if you want to concatenate stuff you must wrap the value in quotes:
```
<Component prop="this{is}valid" />
```

Note that Svelte 5 will also warn if you have a single expression wrapped in quotes, like `answer="{42}"` — in Svelte 6, that will cause the value to be converted to a string, rather than passed as a number.
###  HTML structure is stricter
In Svelte 4, you were allowed to write HTML code that would be repaired by the browser when server side rendering it. For example you could write this...
```
<table>
	<tr>
		<td>hi</td>
	</tr>
</table>
```

... and the browser would auto-insert a `<tbody>` element:
```
<table>
	<tbody>
		<tr>
			<td>hi</td>
		</tr>
	</tbody>
</table>
```

Svelte 5 is more strict about the HTML structure and will throw a compiler error in cases where the browser would repair the DOM.
##  Other breaking changes
###  Stricter @const assignment validation
Assignments to destructured parts of a `@const` declaration are no longer allowed. It was an oversight that this was ever allowed.
###  :is(...) and :where(...) are scoped
Previously, Svelte did not analyse selectors inside `:is(...)` and `:where(...)`, effectively treating them as global. Svelte 5 analyses them in the context of the current component. As such, some selectors may now be treated as unused if they were relying on this treatment. To fix this, use `:global(...)` inside the `:is(...)/:where(...)` selectors.
When using Tailwind’s `@apply` directive, add a `:global` selector to preserve rules that use Tailwind-generated `:is(...)` selectors:
```
main :global {
	@apply bg-blue-100 dark:bg-blue-900;
}
```

###  CSS hash position no longer deterministic
Previously Svelte would always insert the CSS hash last. This is no longer guaranteed in Svelte 5. This is only breaking if you have very weird css selectors.
###  Scoped CSS uses :where(...)
To avoid issues caused by unpredictable specificity changes, scoped CSS selectors now use `:where(.svelte-xyz123)` selector modifiers alongside `.svelte-xyz123` (where `xyz123` is, as previously, a hash of the `<style>` contents). You can read more detail here.
In the event that you need to support ancient browsers that don’t implement `:where`, you can manually alter the emitted CSS, at the cost of unpredictable specificity changes:
```
css = css.replace(/:where\((.+?)\)/, '$1');


```

###  Error/warning codes have been renamed
Error and warning codes have been renamed. Previously they used dashes to separate the words, they now use underscores (e.g. foo-bar becomes foo_bar). Additionally, a handful of codes have been reworded slightly.
###  Reduced number of namespaces
The number of valid namespaces you can pass to the compiler option `namespace` has been reduced to `html` (the default), `mathml` and `svg`.
The `foreign` namespace was only useful for Svelte Native, which we’re planning to support differently in a 5.x minor.
###  beforeUpdate/afterUpdate changes
`beforeUpdate` no longer runs twice on initial render if it modifies a variable referenced in the template.
`afterUpdate` callbacks in a parent component will now run after `afterUpdate` callbacks in any child components.
`beforeUpdate/afterUpdate` no longer run when the component contains a `<slot>` and its content is updated.
Both functions are disallowed in runes mode — use `$effect.pre(...)` and `$effect(...)` instead.
###  contenteditable behavior change
If you have a `contenteditable` node with a corresponding binding _and_ a reactive value inside it (example: `<div contenteditable=true bind:textContent>count is {count}</div>`), then the value inside the contenteditable will not be updated by updates to `count` because the binding takes full control over the content immediately and it should only be updated through it.
###  oneventname attributes no longer accept string values
In Svelte 4, it was possible to specify event attributes on HTML elements as a string:
```
<button onclick="alert('hello')">...</button>
```

This is not recommended, and is no longer possible in Svelte 5, where properties like `onclick` replace `on:click` as the mechanism for adding event handlers.
###  null and undefined become the empty string
In Svelte 4, `null` and `undefined` were printed as the corresponding string. In 99 out of 100 cases you want this to become the empty string instead, which is also what most other frameworks out there do. Therefore, in Svelte 5, `null` and `undefined` become the empty string.
###  bind:files values can only be null, undefined or FileList
`bind:files` is now a two-way binding. As such, when setting a value, it needs to be either falsy (`null` or `undefined`) or of type `FileList`.
###  Bindings now react to form resets
Previously, bindings did not take into account `reset` event of forms, and therefore values could get out of sync with the DOM. Svelte 5 fixes this by placing a `reset` listener on the document and invoking bindings where necessary.
###  walk no longer exported
`svelte/compiler` reexported `walk` from `estree-walker` for convenience. This is no longer true in Svelte 5, import it directly from that package instead in case you need it.
###  Content inside svelte:options is forbidden
In Svelte 4 you could have content inside a `<svelte:options />` tag. It was ignored, but you could write something in there. In Svelte 5, content inside that tag is a compiler error.
###  <slot> elements in declarative shadow roots are preserved
Svelte 4 replaced the `<slot />` tag in all places with its own version of slots. Svelte 5 preserves them in the case they are a child of a `<template shadowrootmode="...">` element.
###  <svelte:element> tag must be an expression
In Svelte 4, `<svelte:element this="div">` is valid code. This makes little sense — you should just do `<div>`. In the vanishingly rare case that you _do_ need to use a literal value for some reason, you can do this:
```
<svelte:element this={"div"}>
```

Note that whereas Svelte 4 would treat `<svelte:element this="input">` (for example) identically to `<input>` for the purposes of determining which `bind:` directives could be applied, Svelte 5 does not.
###  mount plays transitions by default
The `mount` function used to render a component tree plays transitions by default unless the `intro` option is set to `false`. This is different from legacy class components which, when manually instantiated, didn’t play transitions by default.
###  <img src={...}> and {@html ...} hydration mismatches are not repaired
In Svelte 4, if the value of a `src` attribute or `{@html ...}` tag differ between server and client (a.k.a. a hydration mismatch), the mismatch is repaired. This is very costly: setting a `src` attribute (even if it evaluates to the same thing) causes images and iframes to be reloaded, and reinserting a large blob of HTML is slow.
Since these mismatches are extremely rare, Svelte 5 assumes that the values are unchanged, but in development will warn you if they are not. To force an update you can do something like this:
```
<script>
	let { markup, src } = $props();

	if (typeof window !== 'undefined') {
		// stash the values...
		const initial = { markup, src };

		// unset them...
		markup = src = undefined;

		$effect(() => {
			// ...and reset after we've mounted
			markup = initial.markup;
			src = initial.src;
		});
	}
</script>

{@html markup}
<img {src} />
```

###  Hydration works differently
Svelte 5 makes use of comments during server side rendering which are used for more robust and efficient hydration on the client. As such, you shouldn’t remove comments from your HTML output if you intend to hydrate it, and if you manually authored HTML to be hydrated by a Svelte component, you need to adjust that HTML to include said comments at the correct positions.
###  onevent attributes are delegated
Event attributes replace event directives: Instead of `on:click={handler}` you write `onclick={handler}`. For backwards compatibility the `on:event` syntax is still supported and behaves the same as in Svelte 4. Some of the `onevent` attributes however are delegated, which means you need to take care to not stop event propagation on those manually, as they then might never reach the listener for this event type at the root.
###  --style-props uses a different element
Svelte 5 uses an extra `<svelte-css-wrapper>` element instead of a `<div>` to wrap the component when using CSS custom properties.


---




---

The easiest way to start building a SvelteKit app is to run `npx sv create`:
```
npx sv create my-app
cd my-app
npm install
npm run dev
```

The first command will scaffold a new project in the `my-app` directory asking you if you’d like to set up some basic tooling such as TypeScript. See integrations for pointers on setting up additional tooling. The subsequent commands will then install its dependencies and start a server on localhost:5173.
There are two basic concepts:
  * Each page of your app is a Svelte component
  * You create pages by adding files to the `src/routes` directory of your project. These will be server-rendered so that a user’s first visit to your app is as fast as possible, then a client-side app takes over


Try editing the files to get a feel for how everything works.
##  Editor setup
We recommend using Visual Studio Code (aka VS Code) with the Svelte extension, but support also exists for numerous other editors.
Edit this page on GitHub llms.txt
previous next
Introduction Project types
The easiest way to start building a SvelteKit app is to run `npx sv create`:
```
npx sv create my-app
cd my-app
npm install
npm run dev
```

The first command will scaffold a new project in the `my-app` directory asking you if you’d like to set up some basic tooling such as TypeScript. See integrations for pointers on setting up additional tooling. The subsequent commands will then install its dependencies and start a server on localhost:5173.
There are two basic concepts:
  * Each page of your app is a Svelte component
  * You create pages by adding files to the `src/routes` directory of your project. These will be server-rendered so that a user’s first visit to your app is as fast as possible, then a client-side app takes over


Try editing the files to get a feel for how everything works.
##  Editor setup
We recommend using Visual Studio Code (aka VS Code) with the Svelte extension, but support also exists for numerous other editors.
Edit this page on GitHub llms.txt
previous next
Introduction Project types
The easiest way to start building a SvelteKit app is to run `npx sv create`:
```
npx sv create my-app
cd my-app
npm install
npm run dev
```

The first command will scaffold a new project in the `my-app` directory asking you if you’d like to set up some basic tooling such as TypeScript. See integrations for pointers on setting up additional tooling. The subsequent commands will then install its dependencies and start a server on localhost:5173.
There are two basic concepts:
  * Each page of your app is a Svelte component
  * You create pages by adding files to the `src/routes` directory of your project. These will be server-rendered so that a user’s first visit to your app is as fast as possible, then a client-side app takes over


Try editing the files to get a feel for how everything works.
##  Editor setup
We recommend using Visual Studio Code (aka VS Code) with the Svelte extension, but support also exists for numerous other editors.


---

##  Before we begin
> If you’re new to Svelte or SvelteKit we recommend checking out the interactive tutorial.
> If you get stuck, reach out for help in the Discord chatroom.
##  What is SvelteKit?
SvelteKit is a framework for rapidly developing robust, performant web applications using Svelte. If you’re coming from React, SvelteKit is similar to Next. If you’re coming from Vue, SvelteKit is similar to Nuxt.
To learn more about the kinds of applications you can build with SvelteKit, see the documentation regarding project types.
##  What is Svelte?
In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don’t need to know Svelte to understand the rest of this guide, but it will help. If you’d like to learn more, check out the Svelte tutorial.
##  SvelteKit vs Svelte
Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.
SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a router that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes build optimizations to load only the minimal required code; offline support; preloading pages before user navigation; configurable rendering to handle different parts of your app on the server via SSR, in the browser through client-side rendering, or at build-time with prerendering; image optimization; and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.
It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging Vite with a Svelte plugin to do Hot Module Replacement (HMR).
Edit this page on GitHub llms.txt
previous next
Creating a project
##  Before we begin
> If you’re new to Svelte or SvelteKit we recommend checking out the interactive tutorial.
> If you get stuck, reach out for help in the Discord chatroom.
##  What is SvelteKit?
SvelteKit is a framework for rapidly developing robust, performant web applications using Svelte. If you’re coming from React, SvelteKit is similar to Next. If you’re coming from Vue, SvelteKit is similar to Nuxt.
To learn more about the kinds of applications you can build with SvelteKit, see the documentation regarding project types.
##  What is Svelte?
In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don’t need to know Svelte to understand the rest of this guide, but it will help. If you’d like to learn more, check out the Svelte tutorial.
##  SvelteKit vs Svelte
Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.
SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a router that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes build optimizations to load only the minimal required code; offline support; preloading pages before user navigation; configurable rendering to handle different parts of your app on the server via SSR, in the browser through client-side rendering, or at build-time with prerendering; image optimization; and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.
It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging Vite with a Svelte plugin to do Hot Module Replacement (HMR).
Edit this page on GitHub llms.txt
previous next
Creating a project
##  Before we begin
> If you’re new to Svelte or SvelteKit we recommend checking out the interactive tutorial.
> If you get stuck, reach out for help in the Discord chatroom.
##  What is SvelteKit?
SvelteKit is a framework for rapidly developing robust, performant web applications using Svelte. If you’re coming from React, SvelteKit is similar to Next. If you’re coming from Vue, SvelteKit is similar to Nuxt.
To learn more about the kinds of applications you can build with SvelteKit, see the documentation regarding project types.
##  What is Svelte?
In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don’t need to know Svelte to understand the rest of this guide, but it will help. If you’d like to learn more, check out the Svelte tutorial.
##  SvelteKit vs Svelte
Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.
SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a router that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes build optimizations to load only the minimal required code; offline support; preloading pages before user navigation; configurable rendering to handle different parts of your app on the server via SSR, in the browser through client-side rendering, or at build-time with prerendering; image optimization; and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.
It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging Vite with a Svelte plugin to do Hot Module Replacement (HMR).


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---




---




---




---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

The `$state` rune allows you to create _reactive state_ , which means that your UI _reacts_ when it changes.
```
<script>
	let count = $state(0);
</script>

<button onclick={() => count++}>
	clicks: {count}
</button>
```

Unlike other frameworks you may have encountered, there is no API for interacting with state — `count` is just a number, rather than an object or a function, and you can update it like you would update any other variable.
###  Deep state
If `$state` is used with an array or a simple object, the result is a deeply reactive _state proxy_. Proxies allow Svelte to run code when you read or write properties, including via methods like `array.push(...)`, triggering granular updates.
> Classes like `Set` and `Map` will not be proxied, but Svelte provides reactive implementations for various built-ins like these that can be imported from `svelte/reactivity`.
State is proxified recursively until Svelte finds something other than an array or simple object. In a case like this...
```
let ```
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos = ````
function $state<{
    done: boolean;
    text: string;
}[]>(initial: {
    done: boolean;
    text: string;
}[]): {
    done: boolean;
    text: string;
}[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([ { `done: boolean`done: false, `text: string`text: 'add more todos' } ]);`
```

...modifying an individual todo’s property will trigger updates to anything in your UI that depends on that specific property:
```
```
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done = !````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done;`
```

If you push a new object to the array, it will also be proxified:
```
```
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos.````
Array<{ done: boolean; text: string; }>.push(...items: {
    done: boolean;
    text: string;
}[]): number
```
`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push({ `done: boolean`done: false, `text: string`text: 'eat lunch' });`
```

> When you update properties of proxies, the original object is _not_ mutated.
Note that if you destructure a reactive value, the references are not reactive — as in normal JavaScript, they are evaluated at the point of destructuring:
```
let { let done: booleandone, let text: stringtext } = ```
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0]; // this will not affect the value of `done` ````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done = !````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done;`
```

###  Classes
You can also use `$state` in class fields (whether public or private):
```
class class TodoTodo {
	Todo.done: booleandone = ```
function $state<false>(initial: false): false (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(false); `Todo.text: any`text = ````
function $state<any>(): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(); constructor(text) { this.`Todo.text: any`text = `text: any`text; } `Todo.reset(): void`reset() { this.`Todo.text: any`text = ''; this.`Todo.done: boolean`done = false; } }`
```

> The compiler transforms `done` and `text` into `get` / `set` methods on the class prototype referencing private fields. This means the properties are not enumerable.
When calling methods in JavaScript, the value of `this` matters. This won’t work, because `this` inside the `reset` method will be the `<button>` rather than the `Todo`:
```
<button onclick={todo.reset}>
	reset
</button>
```

You can either use an inline function...
```
<button onclick={() => todo.reset()}>
	reset
</button>
```

...or use an arrow function in the class definition:
```
class class TodoTodo {
	Todo.done: booleandone = ```
function $state<false>(initial: false): false (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(false); `Todo.text: any`text = ````
function $state<any>(): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(); constructor(text) { this.`Todo.text: any`text = `text: any`text; } `Todo.reset: () => void`reset = () => { this.`Todo.text: any`text = ''; this.`Todo.done: boolean`done = false; } }`
```

##  $state.raw
In cases where you don’t want objects and arrays to be deeply reactive you can use `$state.raw`.
State declared with `$state.raw` cannot be mutated; it can only be _reassigned_. In other words, rather than assigning to a property of an object, or using an array method like `push`, replace the object or array altogether if you’d like to update it:
```
let ```
let person: {
    name: string;
    age: number;
}
```
`person = ````
namespace $state
function $state<T>(initial: T): T (+1 overload)
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state.````
function $state.raw<{
    name: string;
    age: number;
}>(initial: {
    name: string;
    age: number;
}): {
    name: string;
    age: number;
} (+1 overload)
```
`
Declares state that is _not_ made deeply reactive — instead of mutating it, you must reassign it.
Example:
```
&#x3C;script>
  let items = $state.raw([0]);

  const addItem = () => {
	items = [...items, items.length];
  };
&#x3C;/script>

&#x3C;button on:click={addItem}>
  {items.join(', ')}
&#x3C;/button>
```

https://svelte.dev/docs/svelte/$state#$state.raw
@paraminitial The initial value
raw({ `name: string`name: 'Heraclitus', `age: number`age: 49 }); // this will have no effect ````
let person: {
    name: string;
    age: number;
}
```
`person.`age: number`age += 1; // this will work, because we're creating a new person ````
let person: {
    name: string;
    age: number;
}
```
`person = { `name: string`name: 'Heraclitus', `age: number`age: 50 };`
```

This can improve performance with large arrays and objects that you weren’t planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can _contain_ reactive state (for example, a raw array of reactive objects).
##  $state.snapshot
To take a static snapshot of a deeply reactive `$state` proxy, use `$state.snapshot`:
```
<script>
	let counter = $state({ count: 0 });

	function onclick() {
		// Will log `{ count: ... }` rather than `Proxy { ... }`
		console.log($state.snapshot(counter));
	}
</script>
```

This is handy when you want to pass some state to an external library or API that doesn’t expect a proxy, such as `structuredClone`.
##  Passing state into functions
JavaScript is a _pass-by-value_ language — when you call a function, the arguments are the _values_ rather than the _variables_. In other words:
index
```
/**
 * @param {number} a
 * @param {number} b
 */
function function add(a: number, b: number): number



@parama 



@paramb 


add(a: number

@parama 
a, b: number

@paramb 
b) {
	return a: number

@parama 
a + b: number

@paramb 
b;
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: numbertotal = function add(a: number, b: number): number



@parama 



@paramb 


add(let a: numbera, let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // still 3!`
```
```
function function add(a: number, b: number): numberadd(a: numbera: number, b: numberb: number) {
	return a: numbera + b: numberb;
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: numbertotal = function add(a: number, b: number): numberadd(let a: numbera, let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // still 3!`
```

If `add` wanted to have access to the _current_ values of `a` and `b`, and to return the current `total` value, you would need to use functions instead:
index
```
/**
 * @param {() => number} getA
 * @param {() => number} getB
 */
function function add(getA: () => number, getB: () => number): () => number



@paramgetA 



@paramgetB 


add(getA: () => number

@paramgetA 
getA, getB: () => number

@paramgetB 
getB) {
	return () => getA: () => number

@paramgetA 
getA() + getB: () => number

@paramgetB 
getB();
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: () => numbertotal = function add(getA: () => number, getB: () => number): () => number



@paramgetA 



@paramgetB 


add(() => let a: numbera, () => let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 7`
```
```
function function add(getA: () => number, getB: () => number): () => numberadd(getA: () => numbergetA: () => number, getB: () => numbergetB: () => number) {
	return () => getA: () => numbergetA() + getB: () => numbergetB();
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: () => numbertotal = function add(getA: () => number, getB: () => number): () => numberadd(() => let a: numbera, () => let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 7`
```

State in Svelte is no different — when you reference something declared with the `$state` rune...
```
let let a: numbera = ```
function $state<1>(initial: 1): 1 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(1); let `let b: number`b = ````
function $state<2>(initial: 2): 2 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(2);`
```

...you’re accessing its _current value_.
Note that ‘functions’ is broad — it encompasses properties of proxies and `get`/`set` properties...
index
```
/**
 * @param {{ a: number, b: number }} input
 */
function ```
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`
@paraminput
add(````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input) { return { get `value: number`value() { return ````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input.`a: number`a + ````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input.`b: number`b; } }; } let ````
module input
let input: {
    a: number;
    b: number;
}
```
`input = ````
function $state<{
    a: number;
    b: number;
}>(initial: {
    a: number;
    b: number;
}): {
    a: number;
    b: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `a: number`a: 1, `b: number`b: 2 }); let ````
let total: {
    readonly value: number;
}
```
`total = ````
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`
@paraminput
add(````
module input
let input: {
    a: number;
    b: number;
}
```
`input); `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 3 ````
module input
let input: {
    a: number;
    b: number;
}
```
`input.`a: number`a = 3; ````
module input
let input: {
    a: number;
    b: number;
}
```
`input.`b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 7`
```
```
function ```
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`add(````
input: {
    a: number;
    b: number;
}
```
`input: { `a: number`a: number, `b: number`b: number }) { return { get `value: number`value() { return ````
input: {
    a: number;
    b: number;
}
```
`input.`a: number`a + ````
input: {
    a: number;
    b: number;
}
```
`input.`b: number`b; } }; } let ````
let input: {
    a: number;
    b: number;
}
```
`input = ````
function $state<{
    a: number;
    b: number;
}>(initial: {
    a: number;
    b: number;
}): {
    a: number;
    b: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `a: number`a: 1, `b: number`b: 2 }); let ````
let total: {
    readonly value: number;
}
```
`total = ````
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`add(````
let input: {
    a: number;
    b: number;
}
```
`input); `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 3 ````
let input: {
    a: number;
    b: number;
}
```
`input.`a: number`a = 3; ````
let input: {
    a: number;
    b: number;
}
```
`input.`b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 7`
```

...though if you find yourself writing code like that, consider using classes instead.
##  Passing state across modules
You can declare state in `.svelte.js` and `.svelte.ts` files, but you can only _export_ that state if it’s not directly reassigned. In other words you can’t do this:
state.svelte
```
export let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); export function `function increment(): void`increment() { `let count: number`count += 1; }`
```

That’s because every reference to `count` is transformed by the Svelte compiler — the code above is roughly equivalent to this:
state.svelte
```
export let let count: Signal<number>count = const $: Svelte$.Svelte.state<number>(value?: number | undefined): Signal<number>state(0);

export function function increment(): voidincrement() {
	const $: Svelte$.Svelte.set<number>(source: Signal<number>, value: number): voidset(let count: Signal<number>count, const $: Svelte$.Svelte.get<number>(source: Signal<number>): numberget(let count: Signal<number>count) + 1);
}
```

> You can see the code Svelte generates by clicking the ‘JS Output’ tab in the playground.
Since the compiler only operates on one file at a time, if another file imports `count` Svelte doesn’t know that it needs to wrap each reference in `$.get` and `$.set`:
```
import { let count: numbercount } from './state.svelte.js';

var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(typeof `let count: number`count); // 'object', not 'number'`
```

This leaves you with two options for sharing state between modules — either don’t reassign it...
```
// This is allowed — since we're updating
// `counter.count` rather than `counter`,
// Svelte doesn't wrap it in `$.state`
export const ```
const counter: {
    count: number;
}
```
`counter = ````
function $state<{
    count: number;
}>(initial: {
    count: number;
}): {
    count: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `count: number`count: 0 }); export function `function increment(): void`increment() { ````
const counter: {
    count: number;
}
```
`counter.`count: number`count += 1; }`
```

...or don’t directly export it:
```
let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); export function `function getCount(): number`getCount() { return `let count: number`count; } export function `function increment(): void`increment() { `let count: number`count += 1; }`
```

Edit this page on GitHub llms.txt
previous next
What are runes? $derived
The `$state` rune allows you to create _reactive state_ , which means that your UI _reacts_ when it changes.
```
<script>
	let count = $state(0);
</script>

<button onclick={() => count++}>
	clicks: {count}
</button>
```

Unlike other frameworks you may have encountered, there is no API for interacting with state — `count` is just a number, rather than an object or a function, and you can update it like you would update any other variable.
###  Deep state
If `$state` is used with an array or a simple object, the result is a deeply reactive _state proxy_. Proxies allow Svelte to run code when you read or write properties, including via methods like `array.push(...)`, triggering granular updates.
> Classes like `Set` and `Map` will not be proxied, but Svelte provides reactive implementations for various built-ins like these that can be imported from `svelte/reactivity`.
State is proxified recursively until Svelte finds something other than an array or simple object. In a case like this...
```
let ```
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos = ````
function $state<{
    done: boolean;
    text: string;
}[]>(initial: {
    done: boolean;
    text: string;
}[]): {
    done: boolean;
    text: string;
}[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([ { `done: boolean`done: false, `text: string`text: 'add more todos' } ]);`
```

...modifying an individual todo’s property will trigger updates to anything in your UI that depends on that specific property:
```
```
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done = !````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done;`
```

If you push a new object to the array, it will also be proxified:
```
```
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos.````
Array<{ done: boolean; text: string; }>.push(...items: {
    done: boolean;
    text: string;
}[]): number
```
`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push({ `done: boolean`done: false, `text: string`text: 'eat lunch' });`
```

> When you update properties of proxies, the original object is _not_ mutated.
Note that if you destructure a reactive value, the references are not reactive — as in normal JavaScript, they are evaluated at the point of destructuring:
```
let { let done: booleandone, let text: stringtext } = ```
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0]; // this will not affect the value of `done` ````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done = !````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done;`
```

###  Classes
You can also use `$state` in class fields (whether public or private):
```
class class TodoTodo {
	Todo.done: booleandone = ```
function $state<false>(initial: false): false (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(false); `Todo.text: any`text = ````
function $state<any>(): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(); constructor(text) { this.`Todo.text: any`text = `text: any`text; } `Todo.reset(): void`reset() { this.`Todo.text: any`text = ''; this.`Todo.done: boolean`done = false; } }`
```

> The compiler transforms `done` and `text` into `get` / `set` methods on the class prototype referencing private fields. This means the properties are not enumerable.
When calling methods in JavaScript, the value of `this` matters. This won’t work, because `this` inside the `reset` method will be the `<button>` rather than the `Todo`:
```
<button onclick={todo.reset}>
	reset
</button>
```

You can either use an inline function...
```
<button onclick={() => todo.reset()}>
	reset
</button>
```

...or use an arrow function in the class definition:
```
class class TodoTodo {
	Todo.done: booleandone = ```
function $state<false>(initial: false): false (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(false); `Todo.text: any`text = ````
function $state<any>(): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(); constructor(text) { this.`Todo.text: any`text = `text: any`text; } `Todo.reset: () => void`reset = () => { this.`Todo.text: any`text = ''; this.`Todo.done: boolean`done = false; } }`
```

##  $state.raw
In cases where you don’t want objects and arrays to be deeply reactive you can use `$state.raw`.
State declared with `$state.raw` cannot be mutated; it can only be _reassigned_. In other words, rather than assigning to a property of an object, or using an array method like `push`, replace the object or array altogether if you’d like to update it:
```
let ```
let person: {
    name: string;
    age: number;
}
```
`person = ````
namespace $state
function $state<T>(initial: T): T (+1 overload)
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state.````
function $state.raw<{
    name: string;
    age: number;
}>(initial: {
    name: string;
    age: number;
}): {
    name: string;
    age: number;
} (+1 overload)
```
`
Declares state that is _not_ made deeply reactive — instead of mutating it, you must reassign it.
Example:
```
&#x3C;script>
  let items = $state.raw([0]);

  const addItem = () => {
	items = [...items, items.length];
  };
&#x3C;/script>

&#x3C;button on:click={addItem}>
  {items.join(', ')}
&#x3C;/button>
```

https://svelte.dev/docs/svelte/$state#$state.raw
@paraminitial The initial value
raw({ `name: string`name: 'Heraclitus', `age: number`age: 49 }); // this will have no effect ````
let person: {
    name: string;
    age: number;
}
```
`person.`age: number`age += 1; // this will work, because we're creating a new person ````
let person: {
    name: string;
    age: number;
}
```
`person = { `name: string`name: 'Heraclitus', `age: number`age: 50 };`
```

This can improve performance with large arrays and objects that you weren’t planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can _contain_ reactive state (for example, a raw array of reactive objects).
##  $state.snapshot
To take a static snapshot of a deeply reactive `$state` proxy, use `$state.snapshot`:
```
<script>
	let counter = $state({ count: 0 });

	function onclick() {
		// Will log `{ count: ... }` rather than `Proxy { ... }`
		console.log($state.snapshot(counter));
	}
</script>
```

This is handy when you want to pass some state to an external library or API that doesn’t expect a proxy, such as `structuredClone`.
##  Passing state into functions
JavaScript is a _pass-by-value_ language — when you call a function, the arguments are the _values_ rather than the _variables_. In other words:
index
```
/**
 * @param {number} a
 * @param {number} b
 */
function function add(a: number, b: number): number



@parama 



@paramb 


add(a: number

@parama 
a, b: number

@paramb 
b) {
	return a: number

@parama 
a + b: number

@paramb 
b;
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: numbertotal = function add(a: number, b: number): number



@parama 



@paramb 


add(let a: numbera, let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // still 3!`
```
```
function function add(a: number, b: number): numberadd(a: numbera: number, b: numberb: number) {
	return a: numbera + b: numberb;
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: numbertotal = function add(a: number, b: number): numberadd(let a: numbera, let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // still 3!`
```

If `add` wanted to have access to the _current_ values of `a` and `b`, and to return the current `total` value, you would need to use functions instead:
index
```
/**
 * @param {() => number} getA
 * @param {() => number} getB
 */
function function add(getA: () => number, getB: () => number): () => number



@paramgetA 



@paramgetB 


add(getA: () => number

@paramgetA 
getA, getB: () => number

@paramgetB 
getB) {
	return () => getA: () => number

@paramgetA 
getA() + getB: () => number

@paramgetB 
getB();
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: () => numbertotal = function add(getA: () => number, getB: () => number): () => number



@paramgetA 



@paramgetB 


add(() => let a: numbera, () => let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 7`
```
```
function function add(getA: () => number, getB: () => number): () => numberadd(getA: () => numbergetA: () => number, getB: () => numbergetB: () => number) {
	return () => getA: () => numbergetA() + getB: () => numbergetB();
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: () => numbertotal = function add(getA: () => number, getB: () => number): () => numberadd(() => let a: numbera, () => let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 7`
```

State in Svelte is no different — when you reference something declared with the `$state` rune...
```
let let a: numbera = ```
function $state<1>(initial: 1): 1 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(1); let `let b: number`b = ````
function $state<2>(initial: 2): 2 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(2);`
```

...you’re accessing its _current value_.
Note that ‘functions’ is broad — it encompasses properties of proxies and `get`/`set` properties...
index
```
/**
 * @param {{ a: number, b: number }} input
 */
function ```
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`
@paraminput
add(````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input) { return { get `value: number`value() { return ````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input.`a: number`a + ````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input.`b: number`b; } }; } let ````
module input
let input: {
    a: number;
    b: number;
}
```
`input = ````
function $state<{
    a: number;
    b: number;
}>(initial: {
    a: number;
    b: number;
}): {
    a: number;
    b: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `a: number`a: 1, `b: number`b: 2 }); let ````
let total: {
    readonly value: number;
}
```
`total = ````
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`
@paraminput
add(````
module input
let input: {
    a: number;
    b: number;
}
```
`input); `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 3 ````
module input
let input: {
    a: number;
    b: number;
}
```
`input.`a: number`a = 3; ````
module input
let input: {
    a: number;
    b: number;
}
```
`input.`b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 7`
```
```
function ```
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`add(````
input: {
    a: number;
    b: number;
}
```
`input: { `a: number`a: number, `b: number`b: number }) { return { get `value: number`value() { return ````
input: {
    a: number;
    b: number;
}
```
`input.`a: number`a + ````
input: {
    a: number;
    b: number;
}
```
`input.`b: number`b; } }; } let ````
let input: {
    a: number;
    b: number;
}
```
`input = ````
function $state<{
    a: number;
    b: number;
}>(initial: {
    a: number;
    b: number;
}): {
    a: number;
    b: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `a: number`a: 1, `b: number`b: 2 }); let ````
let total: {
    readonly value: number;
}
```
`total = ````
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`add(````
let input: {
    a: number;
    b: number;
}
```
`input); `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 3 ````
let input: {
    a: number;
    b: number;
}
```
`input.`a: number`a = 3; ````
let input: {
    a: number;
    b: number;
}
```
`input.`b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 7`
```

...though if you find yourself writing code like that, consider using classes instead.
##  Passing state across modules
You can declare state in `.svelte.js` and `.svelte.ts` files, but you can only _export_ that state if it’s not directly reassigned. In other words you can’t do this:
state.svelte
```
export let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); export function `function increment(): void`increment() { `let count: number`count += 1; }`
```

That’s because every reference to `count` is transformed by the Svelte compiler — the code above is roughly equivalent to this:
state.svelte
```
export let let count: Signal<number>count = const $: Svelte$.Svelte.state<number>(value?: number | undefined): Signal<number>state(0);

export function function increment(): voidincrement() {
	const $: Svelte$.Svelte.set<number>(source: Signal<number>, value: number): voidset(let count: Signal<number>count, const $: Svelte$.Svelte.get<number>(source: Signal<number>): numberget(let count: Signal<number>count) + 1);
}
```

> You can see the code Svelte generates by clicking the ‘JS Output’ tab in the playground.
Since the compiler only operates on one file at a time, if another file imports `count` Svelte doesn’t know that it needs to wrap each reference in `$.get` and `$.set`:
```
import { let count: numbercount } from './state.svelte.js';

var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(typeof `let count: number`count); // 'object', not 'number'`
```

This leaves you with two options for sharing state between modules — either don’t reassign it...
```
// This is allowed — since we're updating
// `counter.count` rather than `counter`,
// Svelte doesn't wrap it in `$.state`
export const ```
const counter: {
    count: number;
}
```
`counter = ````
function $state<{
    count: number;
}>(initial: {
    count: number;
}): {
    count: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `count: number`count: 0 }); export function `function increment(): void`increment() { ````
const counter: {
    count: number;
}
```
`counter.`count: number`count += 1; }`
```

...or don’t directly export it:
```
let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); export function `function getCount(): number`getCount() { return `let count: number`count; } export function `function increment(): void`increment() { `let count: number`count += 1; }`
```

Edit this page on GitHub llms.txt
previous next
What are runes? $derived
The `$state` rune allows you to create _reactive state_ , which means that your UI _reacts_ when it changes.
```
<script>
	let count = $state(0);
</script>

<button onclick={() => count++}>
	clicks: {count}
</button>
```

Unlike other frameworks you may have encountered, there is no API for interacting with state — `count` is just a number, rather than an object or a function, and you can update it like you would update any other variable.
###  Deep state
If `$state` is used with an array or a simple object, the result is a deeply reactive _state proxy_. Proxies allow Svelte to run code when you read or write properties, including via methods like `array.push(...)`, triggering granular updates.
> Classes like `Set` and `Map` will not be proxied, but Svelte provides reactive implementations for various built-ins like these that can be imported from `svelte/reactivity`.
State is proxified recursively until Svelte finds something other than an array or simple object. In a case like this...
```
let ```
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos = ````
function $state<{
    done: boolean;
    text: string;
}[]>(initial: {
    done: boolean;
    text: string;
}[]): {
    done: boolean;
    text: string;
}[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([ { `done: boolean`done: false, `text: string`text: 'add more todos' } ]);`
```

...modifying an individual todo’s property will trigger updates to anything in your UI that depends on that specific property:
```
```
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done = !````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done;`
```

If you push a new object to the array, it will also be proxified:
```
```
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos.````
Array<{ done: boolean; text: string; }>.push(...items: {
    done: boolean;
    text: string;
}[]): number
```
`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push({ `done: boolean`done: false, `text: string`text: 'eat lunch' });`
```

> When you update properties of proxies, the original object is _not_ mutated.
Note that if you destructure a reactive value, the references are not reactive — as in normal JavaScript, they are evaluated at the point of destructuring:
```
let { let done: booleandone, let text: stringtext } = ```
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0]; // this will not affect the value of `done` ````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done = !````
module todos
let todos: {
    done: boolean;
    text: string;
}[]
```
`todos[0].`done: boolean`done;`
```

###  Classes
You can also use `$state` in class fields (whether public or private):
```
class class TodoTodo {
	Todo.done: booleandone = ```
function $state<false>(initial: false): false (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(false); `Todo.text: any`text = ````
function $state<any>(): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(); constructor(text) { this.`Todo.text: any`text = `text: any`text; } `Todo.reset(): void`reset() { this.`Todo.text: any`text = ''; this.`Todo.done: boolean`done = false; } }`
```

> The compiler transforms `done` and `text` into `get` / `set` methods on the class prototype referencing private fields. This means the properties are not enumerable.
When calling methods in JavaScript, the value of `this` matters. This won’t work, because `this` inside the `reset` method will be the `<button>` rather than the `Todo`:
```
<button onclick={todo.reset}>
	reset
</button>
```

You can either use an inline function...
```
<button onclick={() => todo.reset()}>
	reset
</button>
```

...or use an arrow function in the class definition:
```
class class TodoTodo {
	Todo.done: booleandone = ```
function $state<false>(initial: false): false (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(false); `Todo.text: any`text = ````
function $state<any>(): any (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(); constructor(text) { this.`Todo.text: any`text = `text: any`text; } `Todo.reset: () => void`reset = () => { this.`Todo.text: any`text = ''; this.`Todo.done: boolean`done = false; } }`
```

##  $state.raw
In cases where you don’t want objects and arrays to be deeply reactive you can use `$state.raw`.
State declared with `$state.raw` cannot be mutated; it can only be _reassigned_. In other words, rather than assigning to a property of an object, or using an array method like `push`, replace the object or array altogether if you’d like to update it:
```
let ```
let person: {
    name: string;
    age: number;
}
```
`person = ````
namespace $state
function $state<T>(initial: T): T (+1 overload)
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state.````
function $state.raw<{
    name: string;
    age: number;
}>(initial: {
    name: string;
    age: number;
}): {
    name: string;
    age: number;
} (+1 overload)
```
`
Declares state that is _not_ made deeply reactive — instead of mutating it, you must reassign it.
Example:
```
&#x3C;script>
  let items = $state.raw([0]);

  const addItem = () => {
	items = [...items, items.length];
  };
&#x3C;/script>

&#x3C;button on:click={addItem}>
  {items.join(', ')}
&#x3C;/button>
```

https://svelte.dev/docs/svelte/$state#$state.raw
@paraminitial The initial value
raw({ `name: string`name: 'Heraclitus', `age: number`age: 49 }); // this will have no effect ````
let person: {
    name: string;
    age: number;
}
```
`person.`age: number`age += 1; // this will work, because we're creating a new person ````
let person: {
    name: string;
    age: number;
}
```
`person = { `name: string`name: 'Heraclitus', `age: number`age: 50 };`
```

This can improve performance with large arrays and objects that you weren’t planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can _contain_ reactive state (for example, a raw array of reactive objects).
##  $state.snapshot
To take a static snapshot of a deeply reactive `$state` proxy, use `$state.snapshot`:
```
<script>
	let counter = $state({ count: 0 });

	function onclick() {
		// Will log `{ count: ... }` rather than `Proxy { ... }`
		console.log($state.snapshot(counter));
	}
</script>
```

This is handy when you want to pass some state to an external library or API that doesn’t expect a proxy, such as `structuredClone`.
##  Passing state into functions
JavaScript is a _pass-by-value_ language — when you call a function, the arguments are the _values_ rather than the _variables_. In other words:
index
```
/**
 * @param {number} a
 * @param {number} b
 */
function function add(a: number, b: number): number



@parama 



@paramb 


add(a: number

@parama 
a, b: number

@paramb 
b) {
	return a: number

@parama 
a + b: number

@paramb 
b;
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: numbertotal = function add(a: number, b: number): number



@parama 



@paramb 


add(let a: numbera, let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // still 3!`
```
```
function function add(a: number, b: number): numberadd(a: numbera: number, b: numberb: number) {
	return a: numbera + b: numberb;
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: numbertotal = function add(a: number, b: number): numberadd(let a: numbera, let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: number`total); // still 3!`
```

If `add` wanted to have access to the _current_ values of `a` and `b`, and to return the current `total` value, you would need to use functions instead:
index
```
/**
 * @param {() => number} getA
 * @param {() => number} getB
 */
function function add(getA: () => number, getB: () => number): () => number



@paramgetA 



@paramgetB 


add(getA: () => number

@paramgetA 
getA, getB: () => number

@paramgetB 
getB) {
	return () => getA: () => number

@paramgetA 
getA() + getB: () => number

@paramgetB 
getB();
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: () => numbertotal = function add(getA: () => number, getB: () => number): () => number



@paramgetA 



@paramgetB 


add(() => let a: numbera, () => let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 7`
```
```
function function add(getA: () => number, getB: () => number): () => numberadd(getA: () => numbergetA: () => number, getB: () => numbergetB: () => number) {
	return () => getA: () => numbergetA() + getB: () => numbergetB();
}

let let a: numbera = 1;
let let b: numberb = 2;
let let total: () => numbertotal = function add(getA: () => number, getB: () => number): () => numberadd(() => let a: numbera, () => let b: numberb);
var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 3 `let a: number`a = 3; `let b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(`let total: () => number`total()); // 7`
```

State in Svelte is no different — when you reference something declared with the `$state` rune...
```
let let a: numbera = ```
function $state<1>(initial: 1): 1 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(1); let `let b: number`b = ````
function $state<2>(initial: 2): 2 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(2);`
```

...you’re accessing its _current value_.
Note that ‘functions’ is broad — it encompasses properties of proxies and `get`/`set` properties...
index
```
/**
 * @param {{ a: number, b: number }} input
 */
function ```
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`
@paraminput
add(````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input) { return { get `value: number`value() { return ````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input.`a: number`a + ````
input: {
    a: number;
    b: number;
}
```
`
@paraminput
input.`b: number`b; } }; } let ````
module input
let input: {
    a: number;
    b: number;
}
```
`input = ````
function $state<{
    a: number;
    b: number;
}>(initial: {
    a: number;
    b: number;
}): {
    a: number;
    b: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `a: number`a: 1, `b: number`b: 2 }); let ````
let total: {
    readonly value: number;
}
```
`total = ````
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`
@paraminput
add(````
module input
let input: {
    a: number;
    b: number;
}
```
`input); `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 3 ````
module input
let input: {
    a: number;
    b: number;
}
```
`input.`a: number`a = 3; ````
module input
let input: {
    a: number;
    b: number;
}
```
`input.`b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 7`
```
```
function ```
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`add(````
input: {
    a: number;
    b: number;
}
```
`input: { `a: number`a: number, `b: number`b: number }) { return { get `value: number`value() { return ````
input: {
    a: number;
    b: number;
}
```
`input.`a: number`a + ````
input: {
    a: number;
    b: number;
}
```
`input.`b: number`b; } }; } let ````
let input: {
    a: number;
    b: number;
}
```
`input = ````
function $state<{
    a: number;
    b: number;
}>(initial: {
    a: number;
    b: number;
}): {
    a: number;
    b: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `a: number`a: 1, `b: number`b: 2 }); let ````
let total: {
    readonly value: number;
}
```
`total = ````
function add(input: {
    a: number;
    b: number;
}): {
    readonly value: number;
}
```
`add(````
let input: {
    a: number;
    b: number;
}
```
`input); `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 3 ````
let input: {
    a: number;
    b: number;
}
```
`input.`a: number`a = 3; ````
let input: {
    a: number;
    b: number;
}
```
`input.`b: number`b = 4; `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
let total: {
    readonly value: number;
}
```
`total.`value: number`value); // 7`
```

...though if you find yourself writing code like that, consider using classes instead.
##  Passing state across modules
You can declare state in `.svelte.js` and `.svelte.ts` files, but you can only _export_ that state if it’s not directly reassigned. In other words you can’t do this:
state.svelte
```
export let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); export function `function increment(): void`increment() { `let count: number`count += 1; }`
```

That’s because every reference to `count` is transformed by the Svelte compiler — the code above is roughly equivalent to this:
state.svelte
```
export let let count: Signal<number>count = const $: Svelte$.Svelte.state<number>(value?: number | undefined): Signal<number>state(0);

export function function increment(): voidincrement() {
	const $: Svelte$.Svelte.set<number>(source: Signal<number>, value: number): voidset(let count: Signal<number>count, const $: Svelte$.Svelte.get<number>(source: Signal<number>): numberget(let count: Signal<number>count) + 1);
}
```

> You can see the code Svelte generates by clicking the ‘JS Output’ tab in the playground.
Since the compiler only operates on one file at a time, if another file imports `count` Svelte doesn’t know that it needs to wrap each reference in `$.get` and `$.set`:
```
import { let count: numbercount } from './state.svelte.js';

var console: Console


The console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.


The module exports two specific components:




  * A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.


  * A global console instance configured to write to process.stdout and
process.stderr. The global console can be used without calling require('console').




_**Warning**_: The global console object’s methods are neither consistently
synchronous like the browser APIs they resemble, nor are they consistently
asynchronous like all other Node.js streams. See the note on process I/O for
more information.


Example using the global console:





```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(typeof `let count: number`count); // 'object', not 'number'`
```

This leaves you with two options for sharing state between modules — either don’t reassign it...
```
// This is allowed — since we're updating
// `counter.count` rather than `counter`,
// Svelte doesn't wrap it in `$.state`
export const ```
const counter: {
    count: number;
}
```
`counter = ````
function $state<{
    count: number;
}>(initial: {
    count: number;
}): {
    count: number;
} (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state({ `count: number`count: 0 }); export function `function increment(): void`increment() { ````
const counter: {
    count: number;
}
```
`counter.`count: number`count += 1; }`
```

...or don’t directly export it:
```
let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); export function `function getCount(): number`getCount() { return `let count: number`count; } export function `function increment(): void`increment() { `let count: number`count += 1; }`
```



---




---




---




---

Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript...
App
```
<script>
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```
```
<script lang="ts">
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```

...into lean, tightly optimized JavaScript.
You can use it to build anything on the web, from standalone components to ambitious full stack apps (using Svelte’s companion application framework, SvelteKit) and everything in between.
These pages serve as reference documentation. If you’re new to Svelte, we recommend starting with the interactive tutorial and coming back here when you have questions.
You can also try Svelte online in the playground or, if you need a more fully-featured environment, on StackBlitz.
Edit this page on GitHub llms.txt
previous next
Getting started
Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript...
App
```
<script>
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```
```
<script lang="ts">
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```

...into lean, tightly optimized JavaScript.
You can use it to build anything on the web, from standalone components to ambitious full stack apps (using Svelte’s companion application framework, SvelteKit) and everything in between.
These pages serve as reference documentation. If you’re new to Svelte, we recommend starting with the interactive tutorial and coming back here when you have questions.
You can also try Svelte online in the playground or, if you need a more fully-featured environment, on StackBlitz.
Edit this page on GitHub llms.txt
previous next
Getting started
Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript...
App
```
<script>
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```
```
<script lang="ts">
	function greet() {
		alert('Welcome to Svelte!');
	}
</script>

<button onclick={greet}>click me</button>

<style>
	button {
		font-size: 2em;
	}
</style>
```

...into lean, tightly optimized JavaScript.
You can use it to build anything on the web, from standalone components to ambitious full stack apps (using Svelte’s companion application framework, SvelteKit) and everything in between.
These pages serve as reference documentation. If you’re new to Svelte, we recommend starting with the interactive tutorial and coming back here when you have questions.
You can also try Svelte online in the playground or, if you need a more fully-featured environment, on StackBlitz.


---

We recommend using SvelteKit, which lets you build almost anything. It’s the official application framework from the Svelte team and powered by Vite. Create a new project with:
```
npx sv create myapp
cd myapp
npm install
npm run dev
```

Don’t worry if you don’t know Svelte yet! You can ignore all the nice features SvelteKit brings on top for now and dive into it later.
##  Alternatives to SvelteKit
You can also use Svelte directly with Vite by running `npm create vite@latest` and selecting the `svelte` option. With this, `npm run build` will generate HTML, JS, and CSS files inside the `dist` directory using vite-plugin-svelte. In most cases, you will probably need to choose a routing library as well.
> Vite is often used in standalone mode to build single page apps (SPAs), which you can also build with SvelteKit.
There are also plugins for Rollup, Webpack and a few others, but we recommend Vite.
##  Editor tooling
The Svelte team maintains a VS Code extension, and there are integrations with various other editors and tools as well.
You can also check your code from the command line using sv check.
##  Getting help
Don’t be shy about asking for help in the Discord chatroom! You can also find answers on Stack Overflow.
Edit this page on GitHub llms.txt
previous next
Overview .svelte files
We recommend using SvelteKit, which lets you build almost anything. It’s the official application framework from the Svelte team and powered by Vite. Create a new project with:
```
npx sv create myapp
cd myapp
npm install
npm run dev
```

Don’t worry if you don’t know Svelte yet! You can ignore all the nice features SvelteKit brings on top for now and dive into it later.
##  Alternatives to SvelteKit
You can also use Svelte directly with Vite by running `npm create vite@latest` and selecting the `svelte` option. With this, `npm run build` will generate HTML, JS, and CSS files inside the `dist` directory using vite-plugin-svelte. In most cases, you will probably need to choose a routing library as well.
> Vite is often used in standalone mode to build single page apps (SPAs), which you can also build with SvelteKit.
There are also plugins for Rollup, Webpack and a few others, but we recommend Vite.
##  Editor tooling
The Svelte team maintains a VS Code extension, and there are integrations with various other editors and tools as well.
You can also check your code from the command line using sv check.
##  Getting help
Don’t be shy about asking for help in the Discord chatroom! You can also find answers on Stack Overflow.
Edit this page on GitHub llms.txt
previous next
Overview .svelte files
We recommend using SvelteKit, which lets you build almost anything. It’s the official application framework from the Svelte team and powered by Vite. Create a new project with:
```
npx sv create myapp
cd myapp
npm install
npm run dev
```

Don’t worry if you don’t know Svelte yet! You can ignore all the nice features SvelteKit brings on top for now and dive into it later.
##  Alternatives to SvelteKit
You can also use Svelte directly with Vite by running `npm create vite@latest` and selecting the `svelte` option. With this, `npm run build` will generate HTML, JS, and CSS files inside the `dist` directory using vite-plugin-svelte. In most cases, you will probably need to choose a routing library as well.
> Vite is often used in standalone mode to build single page apps (SPAs), which you can also build with SvelteKit.
There are also plugins for Rollup, Webpack and a few others, but we recommend Vite.
##  Editor tooling
The Svelte team maintains a VS Code extension, and there are integrations with various other editors and tools as well.
You can also check your code from the command line using sv check.
##  Getting help
Don’t be shy about asking for help in the Discord chatroom! You can also find answers on Stack Overflow.


---

To render a snippet, use a `{@render ...}` tag.
```
{#snippet sum(a, b)}
	<p>{a} + {b} = {a + b}</p>
{/snippet}

{@render sum(1, 2)}
{@render sum(3, 4)}
{@render sum(5, 6)}
```

The expression can be an identifier like `sum`, or an arbitrary JavaScript expression:
```
{@render (cool ? coolSnippet : lameSnippet)()}
```

##  Optional snippets
If the snippet is potentially undefined — for example, because it’s an incoming prop — then you can use optional chaining to only render it when it _is_ defined:
```
{@render children?.()}
```

Alternatively, use an `{#if ...}` block with an `:else` clause to render fallback content:
```
{#if children}
	{@render children()}
{:else}
	<p>fallback content</p>
{/if}
```

Edit this page on GitHub llms.txt
previous next
{#snippet ...} {@html ...}
To render a snippet, use a `{@render ...}` tag.
```
{#snippet sum(a, b)}
	<p>{a} + {b} = {a + b}</p>
{/snippet}

{@render sum(1, 2)}
{@render sum(3, 4)}
{@render sum(5, 6)}
```

The expression can be an identifier like `sum`, or an arbitrary JavaScript expression:
```
{@render (cool ? coolSnippet : lameSnippet)()}
```

##  Optional snippets
If the snippet is potentially undefined — for example, because it’s an incoming prop — then you can use optional chaining to only render it when it _is_ defined:
```
{@render children?.()}
```

Alternatively, use an `{#if ...}` block with an `:else` clause to render fallback content:
```
{#if children}
	{@render children()}
{:else}
	<p>fallback content</p>
{/if}
```

Edit this page on GitHub llms.txt
previous next
{#snippet ...} {@html ...}
To render a snippet, use a `{@render ...}` tag.
```
{#snippet sum(a, b)}
	<p>{a} + {b} = {a + b}</p>
{/snippet}

{@render sum(1, 2)}
{@render sum(3, 4)}
{@render sum(5, 6)}
```

The expression can be an identifier like `sum`, or an arbitrary JavaScript expression:
```
{@render (cool ? coolSnippet : lameSnippet)()}
```

##  Optional snippets
If the snippet is potentially undefined — for example, because it’s an incoming prop — then you can use optional chaining to only render it when it _is_ defined:
```
{@render children?.()}
```

Alternatively, use an `{#if ...}` block with an `:else` clause to render fallback content:
```
{#if children}
	{@render children()}
{:else}
	<p>fallback content</p>
{/if}
```



---

##  I’m new to Svelte. Where should I start?
We think the best way to get started is playing through the interactive tutorial. Each step there is mainly focused on one specific aspect and is easy to follow. You’ll be editing and running real Svelte components right in your browser.
Five to ten minutes should be enough to get you up and running. An hour and a half should get you through the entire tutorial.
##  Where can I get support?
If your question is about certain syntax, the reference docs are a good place to start.
Stack Overflow is a popular forum to ask code-level questions or if you’re stuck with a specific error. Read through the existing questions tagged with Svelte or ask your own!
There are online forums and chats which are a great place for discussion about best practices, application architecture or just to get to know fellow Svelte users. Our Discord or the Reddit channel are examples of that. If you have an answerable code-level question, Stack Overflow is usually a better fit.
##  Are there any third-party resources?
Svelte Society maintains a list of books and videos.
##  How can I get VS Code to syntax-highlight my .svelte files?
There is an official VS Code extension for Svelte.
##  Is there a tool to automatically format my .svelte files?
You can use prettier with the prettier-plugin-svelte plugin.
##  How do I document my components?
In editors which use the Svelte Language Server you can document Components, functions and exports using specially formatted comments.
```
<script>
	/** What should we call the user? */
	export let name = 'world';
</script>

<!--
@component
Here's some documentation for this component.
It will show up on hover.

- You can use markdown here.
- You can also use code blocks here.
- Usage:
  ```svelte
  <main name="Arethra">
  ```
-->
<main>
	<h1>
		Hello, {name}
	</h1>
</main>
```

Note: The `@component` is necessary in the HTML comment which describes your component.
##  Does Svelte scale?
There will be a blog post about this eventually, but in the meantime, check out this issue.
##  Is there a UI component library?
There are several UI component libraries as well as standalone components. Find them under the design systems section of the components page on the Svelte Society website.
##  How do I test Svelte apps?
How your application is structured and where logic is defined will determine the best way to ensure it is properly tested. It is important to note that not all logic belongs within a component - this includes concerns such as data transformation, cross-component state management, and logging, among others. Remember that the Svelte library has its own test suite, so you do not need to write tests to validate implementation details provided by Svelte.
A Svelte application will typically have three different types of tests: Unit, Component, and End-to-End (E2E).
_Unit Tests_ : Focus on testing business logic in isolation. Often this is validating individual functions and edge cases. By minimizing the surface area of these tests they can be kept lean and fast, and by extracting as much logic as possible from your Svelte components more of your application can be covered using them. When creating a new SvelteKit project, you will be asked whether you would like to setup Vitest for unit testing. There are a number of other test runners that could be used as well.
_Component Tests_ : Validating that a Svelte component mounts and interacts as expected throughout its lifecycle requires a tool that provides a Document Object Model (DOM). Components can be compiled (since Svelte is a compiler and not a normal library) and mounted to allow asserting against element structure, listeners, state, and all the other capabilities provided by a Svelte component. Tools for component testing range from an in-memory implementation like jsdom paired with a test runner like Vitest to solutions that leverage an actual browser to provide a visual testing capability such as Playwright or Cypress.
_End-to-End Tests_ : To ensure your users are able to interact with your application it is necessary to test it as a whole in a manner as close to production as possible. This is done by writing end-to-end (E2E) tests which load and interact with a deployed version of your application in order to simulate how the user will interact with your application. When creating a new SvelteKit project, you will be asked whether you would like to setup Playwright for end-to-end testing. There are many other E2E test libraries available for use as well.
Some resources for getting started with testing:
  * Svelte docs on testing
  * Setup Vitest using the Svelte CLI
  * Svelte Testing Library
  * Svelte Component Testing in Cypress
  * Example using uvu test runner with JSDOM
  * Test Svelte components using Vitest & Playwright
  * Component testing with WebdriverIO


##  Is there a router?
The official routing library is SvelteKit. SvelteKit provides a filesystem router, server-side rendering (SSR), and hot module reloading (HMR) in one easy-to-use package. It shares similarities with Next.js for React.
However, you can use any router library. A lot of people use page.js. There’s also navaid, which is very similar. And universal-router, which is isomorphic with child routes, but without built-in history support.
If you prefer a declarative HTML approach, there’s the isomorphic svelte-routing library and a fork of it called svelte-navigator containing some additional functionality.
If you need hash-based routing on the client side, check out the hash option in SvelteKit, svelte-spa-router, or abstract-state-router.
Routify is another filesystem-based router, similar to SvelteKit’s router. Version 3 supports Svelte’s native SSR.
You can see a community-maintained list of routers on sveltesociety.dev.
##  How do I write a mobile app with Svelte?
While most mobile apps are written without using JavaScript, if you’d like to leverage your existing Svelte components and knowledge of Svelte when building mobile apps, you can turn a SvelteKit SPA into a mobile app with Tauri or Capacitor. Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms.
Svelte Native was an option available for Svelte 4, but note that Svelte 5 does not currently support it. Svelte Native lets you write NativeScript apps using Svelte components that contain NativeScript UI components rather than DOM elements, which may be familiar for users coming from React Native.
##  Can I tell Svelte not to remove my unused styles?
No. Svelte removes the styles from the component and warns you about them in order to prevent issues that would otherwise arise.
Svelte’s component style scoping works by generating a class unique to the given component, adding it to the relevant elements in the component that are under Svelte’s control, and then adding it to each of the selectors in that component’s styles. When the compiler can’t see what elements a style selector applies to, there would be two bad options for keeping it:
  * If it keeps the selector and adds the scoping class to it, the selector will likely not match the expected elements in the component, and they definitely won’t if they were created by a child component or `{@html ...}`.
  * If it keeps the selector without adding the scoping class to it, the given style will become a global style, affecting your entire page.


If you need to style something that Svelte can’t identify at compile time, you will need to explicitly opt into global styles by using `:global(...)`. But also keep in mind that you can wrap `:global(...)` around only part of a selector. `.foo :global(.bar) { ... }` will style any `.bar` elements that appear within the component’s `.foo` elements. As long as there’s some parent element in the current component to start from, partially global selectors like this will almost always be able to get you what you want.
##  Is Svelte v2 still available?
New features aren’t being added to it, and bugs will probably only be fixed if they are extremely nasty or present some sort of security vulnerability.
The documentation is still available here.
##  How do I do hot module reloading?
We recommend using SvelteKit, which supports HMR out of the box and is built on top of Vite and svelte-hmr. There are also community plugins for rollup and webpack.
Edit this page on GitHub llms.txt
previous next
Svelte 5 migration guide svelte
##  I’m new to Svelte. Where should I start?
We think the best way to get started is playing through the interactive tutorial. Each step there is mainly focused on one specific aspect and is easy to follow. You’ll be editing and running real Svelte components right in your browser.
Five to ten minutes should be enough to get you up and running. An hour and a half should get you through the entire tutorial.
##  Where can I get support?
If your question is about certain syntax, the reference docs are a good place to start.
Stack Overflow is a popular forum to ask code-level questions or if you’re stuck with a specific error. Read through the existing questions tagged with Svelte or ask your own!
There are online forums and chats which are a great place for discussion about best practices, application architecture or just to get to know fellow Svelte users. Our Discord or the Reddit channel are examples of that. If you have an answerable code-level question, Stack Overflow is usually a better fit.
##  Are there any third-party resources?
Svelte Society maintains a list of books and videos.
##  How can I get VS Code to syntax-highlight my .svelte files?
There is an official VS Code extension for Svelte.
##  Is there a tool to automatically format my .svelte files?
You can use prettier with the prettier-plugin-svelte plugin.
##  How do I document my components?
In editors which use the Svelte Language Server you can document Components, functions and exports using specially formatted comments.
```
<script>
	/** What should we call the user? */
	export let name = 'world';
</script>

<!--
@component
Here's some documentation for this component.
It will show up on hover.

- You can use markdown here.
- You can also use code blocks here.
- Usage:
  ```svelte
  <main name="Arethra">
  ```
-->
<main>
	<h1>
		Hello, {name}
	</h1>
</main>
```

Note: The `@component` is necessary in the HTML comment which describes your component.
##  Does Svelte scale?
There will be a blog post about this eventually, but in the meantime, check out this issue.
##  Is there a UI component library?
There are several UI component libraries as well as standalone components. Find them under the design systems section of the components page on the Svelte Society website.
##  How do I test Svelte apps?
How your application is structured and where logic is defined will determine the best way to ensure it is properly tested. It is important to note that not all logic belongs within a component - this includes concerns such as data transformation, cross-component state management, and logging, among others. Remember that the Svelte library has its own test suite, so you do not need to write tests to validate implementation details provided by Svelte.
A Svelte application will typically have three different types of tests: Unit, Component, and End-to-End (E2E).
_Unit Tests_ : Focus on testing business logic in isolation. Often this is validating individual functions and edge cases. By minimizing the surface area of these tests they can be kept lean and fast, and by extracting as much logic as possible from your Svelte components more of your application can be covered using them. When creating a new SvelteKit project, you will be asked whether you would like to setup Vitest for unit testing. There are a number of other test runners that could be used as well.
_Component Tests_ : Validating that a Svelte component mounts and interacts as expected throughout its lifecycle requires a tool that provides a Document Object Model (DOM). Components can be compiled (since Svelte is a compiler and not a normal library) and mounted to allow asserting against element structure, listeners, state, and all the other capabilities provided by a Svelte component. Tools for component testing range from an in-memory implementation like jsdom paired with a test runner like Vitest to solutions that leverage an actual browser to provide a visual testing capability such as Playwright or Cypress.
_End-to-End Tests_ : To ensure your users are able to interact with your application it is necessary to test it as a whole in a manner as close to production as possible. This is done by writing end-to-end (E2E) tests which load and interact with a deployed version of your application in order to simulate how the user will interact with your application. When creating a new SvelteKit project, you will be asked whether you would like to setup Playwright for end-to-end testing. There are many other E2E test libraries available for use as well.
Some resources for getting started with testing:
  * Svelte docs on testing
  * Setup Vitest using the Svelte CLI
  * Svelte Testing Library
  * Svelte Component Testing in Cypress
  * Example using uvu test runner with JSDOM
  * Test Svelte components using Vitest & Playwright
  * Component testing with WebdriverIO


##  Is there a router?
The official routing library is SvelteKit. SvelteKit provides a filesystem router, server-side rendering (SSR), and hot module reloading (HMR) in one easy-to-use package. It shares similarities with Next.js for React.
However, you can use any router library. A lot of people use page.js. There’s also navaid, which is very similar. And universal-router, which is isomorphic with child routes, but without built-in history support.
If you prefer a declarative HTML approach, there’s the isomorphic svelte-routing library and a fork of it called svelte-navigator containing some additional functionality.
If you need hash-based routing on the client side, check out the hash option in SvelteKit, svelte-spa-router, or abstract-state-router.
Routify is another filesystem-based router, similar to SvelteKit’s router. Version 3 supports Svelte’s native SSR.
You can see a community-maintained list of routers on sveltesociety.dev.
##  How do I write a mobile app with Svelte?
While most mobile apps are written without using JavaScript, if you’d like to leverage your existing Svelte components and knowledge of Svelte when building mobile apps, you can turn a SvelteKit SPA into a mobile app with Tauri or Capacitor. Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms.
Svelte Native was an option available for Svelte 4, but note that Svelte 5 does not currently support it. Svelte Native lets you write NativeScript apps using Svelte components that contain NativeScript UI components rather than DOM elements, which may be familiar for users coming from React Native.
##  Can I tell Svelte not to remove my unused styles?
No. Svelte removes the styles from the component and warns you about them in order to prevent issues that would otherwise arise.
Svelte’s component style scoping works by generating a class unique to the given component, adding it to the relevant elements in the component that are under Svelte’s control, and then adding it to each of the selectors in that component’s styles. When the compiler can’t see what elements a style selector applies to, there would be two bad options for keeping it:
  * If it keeps the selector and adds the scoping class to it, the selector will likely not match the expected elements in the component, and they definitely won’t if they were created by a child component or `{@html ...}`.
  * If it keeps the selector without adding the scoping class to it, the given style will become a global style, affecting your entire page.


If you need to style something that Svelte can’t identify at compile time, you will need to explicitly opt into global styles by using `:global(...)`. But also keep in mind that you can wrap `:global(...)` around only part of a selector. `.foo :global(.bar) { ... }` will style any `.bar` elements that appear within the component’s `.foo` elements. As long as there’s some parent element in the current component to start from, partially global selectors like this will almost always be able to get you what you want.
##  Is Svelte v2 still available?
New features aren’t being added to it, and bugs will probably only be fixed if they are extremely nasty or present some sort of security vulnerability.
The documentation is still available here.
##  How do I do hot module reloading?
We recommend using SvelteKit, which supports HMR out of the box and is built on top of Vite and svelte-hmr. There are also community plugins for rollup and webpack.
Edit this page on GitHub llms.txt
previous next
Svelte 5 migration guide svelte
##  I’m new to Svelte. Where should I start?
We think the best way to get started is playing through the interactive tutorial. Each step there is mainly focused on one specific aspect and is easy to follow. You’ll be editing and running real Svelte components right in your browser.
Five to ten minutes should be enough to get you up and running. An hour and a half should get you through the entire tutorial.
##  Where can I get support?
If your question is about certain syntax, the reference docs are a good place to start.
Stack Overflow is a popular forum to ask code-level questions or if you’re stuck with a specific error. Read through the existing questions tagged with Svelte or ask your own!
There are online forums and chats which are a great place for discussion about best practices, application architecture or just to get to know fellow Svelte users. Our Discord or the Reddit channel are examples of that. If you have an answerable code-level question, Stack Overflow is usually a better fit.
##  Are there any third-party resources?
Svelte Society maintains a list of books and videos.
##  How can I get VS Code to syntax-highlight my .svelte files?
There is an official VS Code extension for Svelte.
##  Is there a tool to automatically format my .svelte files?
You can use prettier with the prettier-plugin-svelte plugin.
##  How do I document my components?
In editors which use the Svelte Language Server you can document Components, functions and exports using specially formatted comments.
```
<script>
	/** What should we call the user? */
	export let name = 'world';
</script>

<!--
@component
Here's some documentation for this component.
It will show up on hover.

- You can use markdown here.
- You can also use code blocks here.
- Usage:
  ```svelte
  <main name="Arethra">
  ```
-->
<main>
	<h1>
		Hello, {name}
	</h1>
</main>
```

Note: The `@component` is necessary in the HTML comment which describes your component.
##  Does Svelte scale?
There will be a blog post about this eventually, but in the meantime, check out this issue.
##  Is there a UI component library?
There are several UI component libraries as well as standalone components. Find them under the design systems section of the components page on the Svelte Society website.
##  How do I test Svelte apps?
How your application is structured and where logic is defined will determine the best way to ensure it is properly tested. It is important to note that not all logic belongs within a component - this includes concerns such as data transformation, cross-component state management, and logging, among others. Remember that the Svelte library has its own test suite, so you do not need to write tests to validate implementation details provided by Svelte.
A Svelte application will typically have three different types of tests: Unit, Component, and End-to-End (E2E).
_Unit Tests_ : Focus on testing business logic in isolation. Often this is validating individual functions and edge cases. By minimizing the surface area of these tests they can be kept lean and fast, and by extracting as much logic as possible from your Svelte components more of your application can be covered using them. When creating a new SvelteKit project, you will be asked whether you would like to setup Vitest for unit testing. There are a number of other test runners that could be used as well.
_Component Tests_ : Validating that a Svelte component mounts and interacts as expected throughout its lifecycle requires a tool that provides a Document Object Model (DOM). Components can be compiled (since Svelte is a compiler and not a normal library) and mounted to allow asserting against element structure, listeners, state, and all the other capabilities provided by a Svelte component. Tools for component testing range from an in-memory implementation like jsdom paired with a test runner like Vitest to solutions that leverage an actual browser to provide a visual testing capability such as Playwright or Cypress.
_End-to-End Tests_ : To ensure your users are able to interact with your application it is necessary to test it as a whole in a manner as close to production as possible. This is done by writing end-to-end (E2E) tests which load and interact with a deployed version of your application in order to simulate how the user will interact with your application. When creating a new SvelteKit project, you will be asked whether you would like to setup Playwright for end-to-end testing. There are many other E2E test libraries available for use as well.
Some resources for getting started with testing:
  * Svelte docs on testing
  * Setup Vitest using the Svelte CLI
  * Svelte Testing Library
  * Svelte Component Testing in Cypress
  * Example using uvu test runner with JSDOM
  * Test Svelte components using Vitest & Playwright
  * Component testing with WebdriverIO


##  Is there a router?
The official routing library is SvelteKit. SvelteKit provides a filesystem router, server-side rendering (SSR), and hot module reloading (HMR) in one easy-to-use package. It shares similarities with Next.js for React.
However, you can use any router library. A lot of people use page.js. There’s also navaid, which is very similar. And universal-router, which is isomorphic with child routes, but without built-in history support.
If you prefer a declarative HTML approach, there’s the isomorphic svelte-routing library and a fork of it called svelte-navigator containing some additional functionality.
If you need hash-based routing on the client side, check out the hash option in SvelteKit, svelte-spa-router, or abstract-state-router.
Routify is another filesystem-based router, similar to SvelteKit’s router. Version 3 supports Svelte’s native SSR.
You can see a community-maintained list of routers on sveltesociety.dev.
##  How do I write a mobile app with Svelte?
While most mobile apps are written without using JavaScript, if you’d like to leverage your existing Svelte components and knowledge of Svelte when building mobile apps, you can turn a SvelteKit SPA into a mobile app with Tauri or Capacitor. Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms.
Svelte Native was an option available for Svelte 4, but note that Svelte 5 does not currently support it. Svelte Native lets you write NativeScript apps using Svelte components that contain NativeScript UI components rather than DOM elements, which may be familiar for users coming from React Native.
##  Can I tell Svelte not to remove my unused styles?
No. Svelte removes the styles from the component and warns you about them in order to prevent issues that would otherwise arise.
Svelte’s component style scoping works by generating a class unique to the given component, adding it to the relevant elements in the component that are under Svelte’s control, and then adding it to each of the selectors in that component’s styles. When the compiler can’t see what elements a style selector applies to, there would be two bad options for keeping it:
  * If it keeps the selector and adds the scoping class to it, the selector will likely not match the expected elements in the component, and they definitely won’t if they were created by a child component or `{@html ...}`.
  * If it keeps the selector without adding the scoping class to it, the given style will become a global style, affecting your entire page.


If you need to style something that Svelte can’t identify at compile time, you will need to explicitly opt into global styles by using `:global(...)`. But also keep in mind that you can wrap `:global(...)` around only part of a selector. `.foo :global(.bar) { ... }` will style any `.bar` elements that appear within the component’s `.foo` elements. As long as there’s some parent element in the current component to start from, partially global selectors like this will almost always be able to get you what you want.
##  Is Svelte v2 still available?
New features aren’t being added to it, and bugs will probably only be fixed if they are extremely nasty or present some sort of security vulnerability.
The documentation is still available here.
##  How do I do hot module reloading?
We recommend using SvelteKit, which supports HMR out of the box and is built on top of Vite and svelte-hmr. There are also community plugins for rollup and webpack.


---

```
import { function on<Type extends keyof WindowEventMap>(window: Window, type: Type, handler: (this: Window, event: WindowEventMap[Type]) => any, options?: AddEventListenerOptions | undefined): () => void (+4 overloads)


Attaches an event handler to the window and returns a function that removes the handler. Using this
rather than addEventListener will preserve the correct order relative to handlers added declaratively
(with attributes like onclick), which use event delegation for performance reasons


on } from 'svelte/events';
```

##  on
Attaches an event handler to the window and returns a function that removes the handler. Using this rather than `addEventListener` will preserve the correct order relative to handlers added declaratively (with attributes like `onclick`), which use event delegation for performance reasons
```
function on<Type extends keyof WindowEventMap>(
	window: Window,
	type: Type,
	handler: (
		this: Window,
		event: WindowEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<Type extends keyof DocumentEventMap>(
	document: Document,
	type: Type,
	handler: (
		this: Document,
		event: DocumentEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<
	Element extends HTMLElement,
	Type extends keyof HTMLElementEventMap
>(
	element: Element,
	type: Type,
	handler: (
		this: Element,
		event: HTMLElementEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<
	Element extends MediaQueryList,
	Type extends keyof MediaQueryListEventMap
>(
	element: Element,
	type: Type,
	handler: (
		this: Element,
		event: MediaQueryListEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on(
	element: EventTarget,
	type: string,
	handler: EventListener,
	options?: AddEventListenerOptions | undefined
): () => void;
```

Edit this page on GitHub llms.txt
previous next
svelte/easing svelte/legacy
```
import { function on<Type extends keyof WindowEventMap>(window: Window, type: Type, handler: (this: Window, event: WindowEventMap[Type]) => any, options?: AddEventListenerOptions | undefined): () => void (+4 overloads)


Attaches an event handler to the window and returns a function that removes the handler. Using this
rather than addEventListener will preserve the correct order relative to handlers added declaratively
(with attributes like onclick), which use event delegation for performance reasons


on } from 'svelte/events';
```

##  on
Attaches an event handler to the window and returns a function that removes the handler. Using this rather than `addEventListener` will preserve the correct order relative to handlers added declaratively (with attributes like `onclick`), which use event delegation for performance reasons
```
function on<Type extends keyof WindowEventMap>(
	window: Window,
	type: Type,
	handler: (
		this: Window,
		event: WindowEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<Type extends keyof DocumentEventMap>(
	document: Document,
	type: Type,
	handler: (
		this: Document,
		event: DocumentEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<
	Element extends HTMLElement,
	Type extends keyof HTMLElementEventMap
>(
	element: Element,
	type: Type,
	handler: (
		this: Element,
		event: HTMLElementEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<
	Element extends MediaQueryList,
	Type extends keyof MediaQueryListEventMap
>(
	element: Element,
	type: Type,
	handler: (
		this: Element,
		event: MediaQueryListEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on(
	element: EventTarget,
	type: string,
	handler: EventListener,
	options?: AddEventListenerOptions | undefined
): () => void;
```

Edit this page on GitHub llms.txt
previous next
svelte/easing svelte/legacy
```
import { function on<Type extends keyof WindowEventMap>(window: Window, type: Type, handler: (this: Window, event: WindowEventMap[Type]) => any, options?: AddEventListenerOptions | undefined): () => void (+4 overloads)


Attaches an event handler to the window and returns a function that removes the handler. Using this
rather than addEventListener will preserve the correct order relative to handlers added declaratively
(with attributes like onclick), which use event delegation for performance reasons


on } from 'svelte/events';
```

##  on
Attaches an event handler to the window and returns a function that removes the handler. Using this rather than `addEventListener` will preserve the correct order relative to handlers added declaratively (with attributes like `onclick`), which use event delegation for performance reasons
```
function on<Type extends keyof WindowEventMap>(
	window: Window,
	type: Type,
	handler: (
		this: Window,
		event: WindowEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<Type extends keyof DocumentEventMap>(
	document: Document,
	type: Type,
	handler: (
		this: Document,
		event: DocumentEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<
	Element extends HTMLElement,
	Type extends keyof HTMLElementEventMap
>(
	element: Element,
	type: Type,
	handler: (
		this: Element,
		event: HTMLElementEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on<
	Element extends MediaQueryList,
	Type extends keyof MediaQueryListEventMap
>(
	element: Element,
	type: Type,
	handler: (
		this: Element,
		event: MediaQueryListEventMap[Type]
	) => any,
	options?: AddEventListenerOptions | undefined
): () => void;
```

```
function on(
	element: EventTarget,
	type: string,
	handler: EventListener,
	options?: AddEventListenerOptions | undefined
): () => void;
```



---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

Vitest is a Vite-native testing framework.
##  Usage
```
npx sv add vitest
```

##  What you get
  * the relevant packages installed and scripts added to your `package.json`
  * client/server-aware testing setup for Svelte in your Vite config file
  * demo tests


Edit this page on GitHub llms.txt
previous next
tailwindcss
Vitest is a Vite-native testing framework.
##  Usage
```
npx sv add vitest
```

##  What you get
  * the relevant packages installed and scripts added to your `package.json`
  * client/server-aware testing setup for Svelte in your Vite config file
  * demo tests


Edit this page on GitHub llms.txt
previous next
tailwindcss
Vitest is a Vite-native testing framework.
##  Usage
```
npx sv add vitest
```

##  What you get
  * the relevant packages installed and scripts added to your `package.json`
  * client/server-aware testing setup for Svelte in your Vite config file
  * demo tests




---




---




---

A _transition_ is triggered by an element entering or leaving the DOM as a result of a state change.
When a block (such as an `{#if ...}` block) is transitioning out, all elements inside it, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.
The `transition:` directive indicates a _bidirectional_ transition, which means it can be smoothly reversed while the transition is in progress.
```
<script>
	import { fade } from 'svelte/transition';

	let visible = $state(false);
</script>

<button onclick={() => visible = !visible}>toggle</button>

{#if visible}
	<div transition:fade>fades in and out</div>
{/if}
```

##  Local vs global
Transitions are local by default. Local transitions only play when the block they belong to is created or destroyed, _not_ when parent blocks are created or destroyed.
```
{#if x}
	{#if y}
		<p transition:fade>fades in and out only when y changes</p>

		<p transition:fade|global>fades in and out when x or y change</p>
	{/if}
{/if}
```

##  Built-in transitions
A selection of built-in transitions can be imported from the `svelte/transition` module.
##  Transition parameters
Transitions can have parameters.
(The double `{{curlies}}` aren’t a special syntax; this is an object literal inside an expression tag.)
```
{#if visible}
	<div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>
{/if}
```

##  Custom transition functions
```
transition = (node: HTMLElementnode: HTMLElement, params: anyparams: any, ```
options: {
    direction: "in" | "out" | "both";
}
```
`options: { `direction: "in" | "out" | "both"`direction: 'in' | 'out' | 'both' }) => { delay?: number, duration?: number, easing?: (`t: number`t: number) => number, css?: (`t: number`t: number, `u: number`u: number) => string, tick?: (`t: number`t: number, `u: number`u: number) => void }`
```

Transitions can use custom functions. If the returned object has a `css` function, Svelte will generate keyframes for a web animation.
The `t` argument passed to `css` is a value between `0` and `1` after the `easing` function has been applied. _In_ transitions run from `0` to `1`, _out_ transitions run from `1` to `0` — in other words, `1` is the element’s natural state, as though no transition had been applied. The `u` argument is equal to `1 - t`.
The function is called repeatedly _before_ the transition begins, with different `t` and `u` arguments.
App
```
<script>
	import { elasticOut } from 'svelte/easing';

	/** @type {boolean} */
	export let visible;

	/**
	 * @param {HTMLElement} node
	 * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params
	 */
	function whoosh(node, params) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) => `transform: ${existingTransform} scale(${t})`
		};
	}
</script>

{#if visible}
	<div in:whoosh>whooshes in</div>
{/if}
```
```
<script lang="ts">
	import { elasticOut } from 'svelte/easing';
	export let visible: boolean;

	function whoosh(node: HTMLElement, params: { delay?: number, duration?: number, easing?: (t: number) => number }) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) => `transform: ${existingTransform} scale(${t})`
		};
	}
</script>

{#if visible}
	<div in:whoosh>whooshes in</div>
{/if}
```

A custom transition function can also return a `tick` function, which is called _during_ the transition with the same `t` and `u` arguments.
> If it’s possible to use `css` instead of `tick`, do so — web animations can run off the main thread, preventing jank on slower devices.
App
```
<script>
	export let visible = false;

	/**
	 * @param {HTMLElement} node
	 * @param {{ speed?: number }} params
	 */
	function typewriter(node, { speed = 1 }) {
		const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: (t) => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
</script>

{#if visible}
	<p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>
{/if}
```
```
<script lang="ts">
	export let visible = false;

	function typewriter(node: HTMLElement, { speed = 1 }: { speed?: number }) {
		const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: (t) => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
</script>

{#if visible}
	<p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>
{/if}
```

If a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making crossfade effects possible.
Transition functions also receive a third argument, `options`, which contains information about the transition.
Available values in the `options` object are:
  * `direction` - one of `in`, `out`, or `both` depending on the type of transition


##  Transition events
An element with transitions will dispatch the following events in addition to any standard DOM events:
  * `introstart`
  * `introend`
  * `outrostart`
  * `outroend`


```
{#if visible}
	<p
		transition:fly={{ y: 200, duration: 2000 }}
		onintrostart={() => (status = 'intro started')}
		onoutrostart={() => (status = 'outro started')}
		onintroend={() => (status = 'intro ended')}
		onoutroend={() => (status = 'outro ended')}
	>
		Flies in and out
	</p>
{/if}
```

Edit this page on GitHub llms.txt
previous next
use: in: and out:
A _transition_ is triggered by an element entering or leaving the DOM as a result of a state change.
When a block (such as an `{#if ...}` block) is transitioning out, all elements inside it, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.
The `transition:` directive indicates a _bidirectional_ transition, which means it can be smoothly reversed while the transition is in progress.
```
<script>
	import { fade } from 'svelte/transition';

	let visible = $state(false);
</script>

<button onclick={() => visible = !visible}>toggle</button>

{#if visible}
	<div transition:fade>fades in and out</div>
{/if}
```

##  Local vs global
Transitions are local by default. Local transitions only play when the block they belong to is created or destroyed, _not_ when parent blocks are created or destroyed.
```
{#if x}
	{#if y}
		<p transition:fade>fades in and out only when y changes</p>

		<p transition:fade|global>fades in and out when x or y change</p>
	{/if}
{/if}
```

##  Built-in transitions
A selection of built-in transitions can be imported from the `svelte/transition` module.
##  Transition parameters
Transitions can have parameters.
(The double `{{curlies}}` aren’t a special syntax; this is an object literal inside an expression tag.)
```
{#if visible}
	<div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>
{/if}
```

##  Custom transition functions
```
transition = (node: HTMLElementnode: HTMLElement, params: anyparams: any, ```
options: {
    direction: "in" | "out" | "both";
}
```
`options: { `direction: "in" | "out" | "both"`direction: 'in' | 'out' | 'both' }) => { delay?: number, duration?: number, easing?: (`t: number`t: number) => number, css?: (`t: number`t: number, `u: number`u: number) => string, tick?: (`t: number`t: number, `u: number`u: number) => void }`
```

Transitions can use custom functions. If the returned object has a `css` function, Svelte will generate keyframes for a web animation.
The `t` argument passed to `css` is a value between `0` and `1` after the `easing` function has been applied. _In_ transitions run from `0` to `1`, _out_ transitions run from `1` to `0` — in other words, `1` is the element’s natural state, as though no transition had been applied. The `u` argument is equal to `1 - t`.
The function is called repeatedly _before_ the transition begins, with different `t` and `u` arguments.
App
```
<script>
	import { elasticOut } from 'svelte/easing';

	/** @type {boolean} */
	export let visible;

	/**
	 * @param {HTMLElement} node
	 * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params
	 */
	function whoosh(node, params) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) => `transform: ${existingTransform} scale(${t})`
		};
	}
</script>

{#if visible}
	<div in:whoosh>whooshes in</div>
{/if}
```
```
<script lang="ts">
	import { elasticOut } from 'svelte/easing';
	export let visible: boolean;

	function whoosh(node: HTMLElement, params: { delay?: number, duration?: number, easing?: (t: number) => number }) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) => `transform: ${existingTransform} scale(${t})`
		};
	}
</script>

{#if visible}
	<div in:whoosh>whooshes in</div>
{/if}
```

A custom transition function can also return a `tick` function, which is called _during_ the transition with the same `t` and `u` arguments.
> If it’s possible to use `css` instead of `tick`, do so — web animations can run off the main thread, preventing jank on slower devices.
App
```
<script>
	export let visible = false;

	/**
	 * @param {HTMLElement} node
	 * @param {{ speed?: number }} params
	 */
	function typewriter(node, { speed = 1 }) {
		const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: (t) => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
</script>

{#if visible}
	<p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>
{/if}
```
```
<script lang="ts">
	export let visible = false;

	function typewriter(node: HTMLElement, { speed = 1 }: { speed?: number }) {
		const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: (t) => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
</script>

{#if visible}
	<p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>
{/if}
```

If a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making crossfade effects possible.
Transition functions also receive a third argument, `options`, which contains information about the transition.
Available values in the `options` object are:
  * `direction` - one of `in`, `out`, or `both` depending on the type of transition


##  Transition events
An element with transitions will dispatch the following events in addition to any standard DOM events:
  * `introstart`
  * `introend`
  * `outrostart`
  * `outroend`


```
{#if visible}
	<p
		transition:fly={{ y: 200, duration: 2000 }}
		onintrostart={() => (status = 'intro started')}
		onoutrostart={() => (status = 'outro started')}
		onintroend={() => (status = 'intro ended')}
		onoutroend={() => (status = 'outro ended')}
	>
		Flies in and out
	</p>
{/if}
```

Edit this page on GitHub llms.txt
previous next
use: in: and out:
A _transition_ is triggered by an element entering or leaving the DOM as a result of a state change.
When a block (such as an `{#if ...}` block) is transitioning out, all elements inside it, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.
The `transition:` directive indicates a _bidirectional_ transition, which means it can be smoothly reversed while the transition is in progress.
```
<script>
	import { fade } from 'svelte/transition';

	let visible = $state(false);
</script>

<button onclick={() => visible = !visible}>toggle</button>

{#if visible}
	<div transition:fade>fades in and out</div>
{/if}
```

##  Local vs global
Transitions are local by default. Local transitions only play when the block they belong to is created or destroyed, _not_ when parent blocks are created or destroyed.
```
{#if x}
	{#if y}
		<p transition:fade>fades in and out only when y changes</p>

		<p transition:fade|global>fades in and out when x or y change</p>
	{/if}
{/if}
```

##  Built-in transitions
A selection of built-in transitions can be imported from the `svelte/transition` module.
##  Transition parameters
Transitions can have parameters.
(The double `{{curlies}}` aren’t a special syntax; this is an object literal inside an expression tag.)
```
{#if visible}
	<div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>
{/if}
```

##  Custom transition functions
```
transition = (node: HTMLElementnode: HTMLElement, params: anyparams: any, ```
options: {
    direction: "in" | "out" | "both";
}
```
`options: { `direction: "in" | "out" | "both"`direction: 'in' | 'out' | 'both' }) => { delay?: number, duration?: number, easing?: (`t: number`t: number) => number, css?: (`t: number`t: number, `u: number`u: number) => string, tick?: (`t: number`t: number, `u: number`u: number) => void }`
```

Transitions can use custom functions. If the returned object has a `css` function, Svelte will generate keyframes for a web animation.
The `t` argument passed to `css` is a value between `0` and `1` after the `easing` function has been applied. _In_ transitions run from `0` to `1`, _out_ transitions run from `1` to `0` — in other words, `1` is the element’s natural state, as though no transition had been applied. The `u` argument is equal to `1 - t`.
The function is called repeatedly _before_ the transition begins, with different `t` and `u` arguments.
App
```
<script>
	import { elasticOut } from 'svelte/easing';

	/** @type {boolean} */
	export let visible;

	/**
	 * @param {HTMLElement} node
	 * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params
	 */
	function whoosh(node, params) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) => `transform: ${existingTransform} scale(${t})`
		};
	}
</script>

{#if visible}
	<div in:whoosh>whooshes in</div>
{/if}
```
```
<script lang="ts">
	import { elasticOut } from 'svelte/easing';
	export let visible: boolean;

	function whoosh(node: HTMLElement, params: { delay?: number, duration?: number, easing?: (t: number) => number }) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) => `transform: ${existingTransform} scale(${t})`
		};
	}
</script>

{#if visible}
	<div in:whoosh>whooshes in</div>
{/if}
```

A custom transition function can also return a `tick` function, which is called _during_ the transition with the same `t` and `u` arguments.
> If it’s possible to use `css` instead of `tick`, do so — web animations can run off the main thread, preventing jank on slower devices.
App
```
<script>
	export let visible = false;

	/**
	 * @param {HTMLElement} node
	 * @param {{ speed?: number }} params
	 */
	function typewriter(node, { speed = 1 }) {
		const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: (t) => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
</script>

{#if visible}
	<p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>
{/if}
```
```
<script lang="ts">
	export let visible = false;

	function typewriter(node: HTMLElement, { speed = 1 }: { speed?: number }) {
		const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: (t) => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
</script>

{#if visible}
	<p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>
{/if}
```

If a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making crossfade effects possible.
Transition functions also receive a third argument, `options`, which contains information about the transition.
Available values in the `options` object are:
  * `direction` - one of `in`, `out`, or `both` depending on the type of transition


##  Transition events
An element with transitions will dispatch the following events in addition to any standard DOM events:
  * `introstart`
  * `introend`
  * `outrostart`
  * `outroend`


```
{#if visible}
	<p
		transition:fly={{ y: 200, duration: 2000 }}
		onintrostart={() => (status = 'intro started')}
		onoutrostart={() => (status = 'outro started')}
		onintroend={() => (status = 'intro ended')}
		onoutroend={() => (status = 'outro ended')}
	>
		Flies in and out
	</p>
{/if}
```



---

Your project’s configuration lives in a `svelte.config.js` file at the root of your project. As well as SvelteKit, this config object is used by other tooling that integrates with Svelte such as editor extensions.
svelte.config
```
import const adapter: () => import("@sveltejs/kit").Adapteradapter from '@sveltejs/adapter-auto';

/** @type {import('@sveltejs/kit').Config} */
const const config: Config

@type{import('@sveltejs/kit').Config}

config = {
	Config.kit?: KitConfig | undefined


SvelteKit options


kit: {
		KitConfig.adapter?: Adapter | undefined


Your adapter is run when executing vite build. It determines how the output is converted for different platforms.





@defaultundefined

adapter: function adapter(): import("@sveltejs/kit").Adapteradapter()
	}
};

export default const config: Config

@type{import('@sveltejs/kit').Config}

config;
```

##  Config
```
interface Config {…}
```

```
compilerOptions?: CompileOptions;
```

  * default `{}`


Options passed to `svelte.compile`.
```
extensions?: string[];
```

  * default `[".svelte"]`


List of file extensions that should be treated as Svelte files.
```
kit?: KitConfig;
```

SvelteKit options
```
preprocess?: any;
```

Preprocessor options, if any. Preprocessing can alternatively also be done through Vite’s preprocessor capabilities.
```
vitePlugin?: PluginOptions;
```

`vite-plugin-svelte` plugin options.
```
[key: string]: any;
```

Any additional options required by tooling that integrates with Svelte.
##  KitConfig
The `kit` property configures SvelteKit, and can have the following properties:
##  adapter
  * default `undefined`


Your adapter is run when executing `vite build`. It determines how the output is converted for different platforms.
##  alias
  * default `{}`


An object containing zero or more aliases used to replace values in `import` statements. These aliases are automatically passed to Vite and TypeScript.
svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        alias: {
 'my-file': string;
 'my-directory': string;
            'my-directory/*': string;
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    alias: {
        'my-file': string;
        'my-directory': string;
        'my-directory/*': string;
    };
}
```
`kit: { ````
alias: {
    'my-file': string;
    'my-directory': string;
    'my-directory/*': string;
}
```
`alias: { // this will match a file 'my-file': 'path/to/my-file.js', // this will match a directory and its contents // (`my-directory/x` resolves to `path/to/my-directory/x`) 'my-directory': 'path/to/my-directory', // an alias ending /* will only match // the contents of a directory, not the directory itself 'my-directory/*': 'path/to/my-directory/*' } } };`
```

> The built-in `$lib` alias is controlled by `config.kit.files.lib` as it is used for packaging.
> You will need to run `npm run dev` to have SvelteKit automatically generate the required alias configuration in `jsconfig.json` or `tsconfig.json`.
##  appDir
  * default `"_app"`


The directory where SvelteKit keeps its stuff, including static assets (such as JS and CSS) and internally-used routes.
If `paths.assets` is specified, there will be two app directories — `${paths.assets}/${appDir}` and `${paths.base}/${appDir}`.
##  csp
Content Security Policy configuration. CSP helps to protect your users against cross-site scripting (XSS) attacks, by limiting the places resources can be loaded from. For example, a configuration like this...
svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        csp: {
 directives: {
   'script-src': string[];
 };
 reportOnly: {
   'script-src': string[];
   'report-uri': string[];
 };
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    csp: {
        directives: {
 'script-src': string[];
        };
        reportOnly: {
 'script-src': string[];
 'report-uri': string[];
        };
    };
}
```
`kit: { ````
csp: {
    directives: {
        'script-src': string[];
    };
    reportOnly: {
        'script-src': string[];
        'report-uri': string[];
    };
}
```
`csp: { ````
directives: {
    'script-src': string[];
}
```
`directives: { 'script-src': ['self'] }, // must be specified with either the `report-uri` or `report-to` directives, or both ````
reportOnly: {
    'script-src': string[];
    'report-uri': string[];
}
```
`reportOnly: { 'script-src': ['self'], 'report-uri': ['/'] } } } }; export default ````
const config: {
    kit: {
        csp: {
 directives: {
   'script-src': string[];
 };
 reportOnly: {
   'script-src': string[];
   'report-uri': string[];
            };
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config;`
```

...would prevent scripts loading from external sites. SvelteKit will augment the specified directives with nonces or hashes (depending on `mode`) for any inline styles and scripts it generates.
To add a nonce for scripts and links manually included in `src/app.html`, you may use the placeholder `%sveltekit.nonce%` (for example `<script nonce="%sveltekit.nonce%">`).
When pages are prerendered, the CSP header is added via a `<meta http-equiv>` tag (note that in this case, `frame-ancestors`, `report-uri` and `sandbox` directives will be ignored).
> When `mode` is `'auto'`, SvelteKit will use nonces for dynamically rendered pages and hashes for prerendered pages. Using nonces with prerendered pages is insecure and therefore forbidden.
> Note that most Svelte transitions work by creating an inline `<style>` element. If you use these in your app, you must either leave the `style-src` directive unspecified or add `unsafe-inline`.
If this level of configuration is insufficient and you have more dynamic requirements, you can use the `handle` hook to roll your own CSP.
```
mode?: 'hash' | 'nonce' | 'auto';
```

Whether to use hashes or nonces to restrict `<script>` and `<style>` elements. `'auto'` will use hashes for prerendered pages, and nonces for dynamically rendered pages.
```
directives?: CspDirectives;
```

Directives that will be added to `Content-Security-Policy` headers.
```
reportOnly?: CspDirectives;
```

Directives that will be added to `Content-Security-Policy-Report-Only` headers.
##  csrf
Protection against cross-site request forgery (CSRF) attacks.
```
checkOrigin?: boolean;
```

  * default `true`


Whether to check the incoming `origin` header for `POST`, `PUT`, `PATCH`, or `DELETE` form submissions and verify that it matches the server’s origin.
To allow people to make `POST`, `PUT`, `PATCH`, or `DELETE` requests with a `Content-Type` of `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain` to your app from other origins, you will need to disable this option. Be careful!
##  embedded
  * default `false`


Whether or not the app is embedded inside a larger app. If `true`, SvelteKit will add its event listeners related to navigation etc on the parent of `%sveltekit.body%` instead of `window`, and will pass `params` from the server rather than inferring them from `location.pathname`. Note that it is generally not supported to embed multiple SvelteKit apps on the same page and use client-side SvelteKit features within them (things such as pushing to the history state assume a single instance).
##  env
Environment variable configuration
```
dir?: string;
```

  * default `"."`


The directory to search for `.env` files.
```
publicPrefix?: string;
```

  * default `"PUBLIC_"`


A prefix that signals that an environment variable is safe to expose to client-side code. See `$env/static/public` and `$env/dynamic/public`. Note that Vite’s `envPrefix` must be set separately if you are using Vite’s environment variable handling - though use of that feature should generally be unnecessary.
```
privatePrefix?: string;
```

  * default `""`
  * available since v1.21.0


A prefix that signals that an environment variable is unsafe to expose to client-side code. Environment variables matching neither the public nor the private prefix will be discarded completely. See `$env/static/private` and `$env/dynamic/private`.
##  files
Where to find various files within your project.
```
assets?: string;
```

  * default `"static"`


a place to put static files that should have stable URLs and undergo no processing, such as `favicon.ico` or `manifest.json`
```
hooks?: {…}
```

```
client?: string;
```

  * default `"src/hooks.client"`


The location of your client hooks.
```
server?: string;
```

  * default `"src/hooks.server"`


The location of your server hooks.
```
universal?: string;
```

  * default `"src/hooks"`
  * available since v2.3.0


The location of your universal hooks.
```
lib?: string;
```

  * default `"src/lib"`


your app’s internal library, accessible throughout the codebase as `$lib`
```
params?: string;
```

  * default `"src/params"`


a directory containing parameter matchers
```
routes?: string;
```

  * default `"src/routes"`


the files that define the structure of your app (see Routing)
```
serviceWorker?: string;
```

  * default `"src/service-worker"`


the location of your service worker’s entry point (see Service workers)
```
appTemplate?: string;
```

  * default `"src/app.html"`


the location of the template for HTML responses
```
errorTemplate?: string;
```

  * default `"src/error.html"`


the location of the template for fallback error responses
##  inlineStyleThreshold
  * default `0`


Inline CSS inside a `<style>` block at the head of the HTML. This option is a number that specifies the maximum length of a CSS file in UTF-16 code units, as specified by the String.length property, to be inlined. All CSS files needed for the page and smaller than this value are merged and inlined in a `<style>` block.
> This results in fewer initial requests and can improve your First Contentful Paint score. However, it generates larger HTML output and reduces the effectiveness of browser caches. Use it advisedly.
##  moduleExtensions
  * default `[".js", ".ts"]`


An array of file extensions that SvelteKit will treat as modules. Files with extensions that match neither `config.extensions` nor `config.kit.moduleExtensions` will be ignored by the router.
##  outDir
  * default `".svelte-kit"`


The directory that SvelteKit writes files to during `dev` and `build`. You should exclude this directory from version control.
##  output
Options related to the build output format
```
preloadStrategy?: 'modulepreload' | 'preload-js' | 'preload-mjs';
```

  * default `"modulepreload"`
  * available since v1.8.4


SvelteKit will preload the JavaScript modules needed for the initial page to avoid import ‘waterfalls’, resulting in faster application startup. There are three strategies with different trade-offs:
  * `modulepreload` - uses `<link rel="modulepreload">`. This delivers the best results in Chromium-based browsers, in Firefox 115+, and Safari 17+. It is ignored in older browsers.
  * `preload-js` - uses `<link rel="preload">`. Prevents waterfalls in Chromium and Safari, but Chromium will parse each module twice (once as a script, once as a module). Causes modules to be requested twice in Firefox. This is a good setting if you want to maximise performance for users on iOS devices at the cost of a very slight degradation for Chromium users.
  * `preload-mjs` - uses `<link rel="preload">` but with the `.mjs` extension which prevents double-parsing in Chromium. Some static webservers will fail to serve .mjs files with a `Content-Type: application/javascript` header, which will cause your application to break. If that doesn’t apply to you, this is the option that will deliver the best performance for the largest number of users, until `modulepreload` is more widely supported.


```
bundleStrategy?: 'split' | 'single' | 'inline';
```

  * default `'split'`
  * available since v2.13.0


The bundle strategy option affects how your app’s JavaScript and CSS files are loaded.
  * If `'split'`, splits the app up into multiple .js/.css files so that they are loaded lazily as the user navigates around the app. This is the default, and is recommended for most scenarios.
  * If `'single'`, creates just one .js bundle and one .css file containing code for the entire app.
  * If `'inline'`, inlines all JavaScript and CSS of the entire app into the HTML. The result is usable without a server (i.e. you can just open the file in your browser).


When using `'split'`, you can also adjust the bundling behaviour by setting `output.experimentalMinChunkSize` and `output.manualChunks` inside your Vite config’s `build.rollupOptions`.
If you want to inline your assets, you’ll need to set Vite’s `build.assetsInlineLimit` option to an appropriate size then import your assets through Vite.
vite.config
```
import { function sveltekit(): Promise<Plugin<any>[]>


Returns the SvelteKit Vite plugins.


sveltekit } from '@sveltejs/kit/vite';
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)


Type helper to make it easier to use vite.config.ts
accepts a direct 
{@link 
UserConfig
}
 object, or a function that returns it.
The function receives a 
{@link 
ConfigEnv
}
 object.


defineConfig } from 'vite';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)


Type helper to make it easier to use vite.config.ts
accepts a direct 
{@link 
UserConfig
}
 object, or a function that returns it.
The function receives a 
{@link 
ConfigEnv
}
 object.


defineConfig({
	UserConfig.plugins?: PluginOption[] | undefined


Array of vite plugins to use.


plugins: [function sveltekit(): Promise<Plugin<any>[]>


Returns the SvelteKit Vite plugins.


sveltekit()],
	UserConfig.build?: BuildOptions | undefined


Build specific options


build: {
		// inline all imported assets
		BuildOptions.assetsInlineLimit?: number | ((filePath: string, content: Buffer) => boolean | undefined) | undefined


Static asset files smaller than this number (in bytes) will be inlined as
base64 strings. Default limit is 4096 (4 KiB). Set to 0 to disable.





@default4096

assetsInlineLimit: var Infinity: numberInfinity
	}
});
```

src/routes/+layout
```
<script>
	// import the asset through Vite
	import favicon from './favicon.png';
</script>

<svelte:head>
	<!-- this asset will be inlined as a base64 URL -->
	<link rel="icon" href={favicon} />
</svelte:head>
```
```
<script lang="ts">
	// import the asset through Vite
	import favicon from './favicon.png';
</script>

<svelte:head>
	<!-- this asset will be inlined as a base64 URL -->
	<link rel="icon" href={favicon} />
</svelte:head>
```

##  paths
```
assets?: '' | `http://${string}` | `https://${string}`;
```

  * default `""`


An absolute path that your app’s files are served from. This is useful if your files are served from a storage bucket of some kind.
```
base?: '' | `/${string}`;
```

  * default `""`


A root-relative path that must start, but not end with `/` (e.g. `/base-path`), unless it is the empty string. This specifies where your app is served from and allows the app to live on a non-root path. Note that you need to prepend all your root-relative links with the base value or they will point to the root of your domain, not your `base` (this is how the browser works). You can use `base` from `$app/paths` for that: `<a href="{base}/your-page">Link</a>`. If you find yourself writing this often, it may make sense to extract this into a reusable component.
```
relative?: boolean;
```

  * default `true`
  * available since v1.9.0


Whether to use relative asset paths.
If `true`, `base` and `assets` imported from `$app/paths` will be replaced with relative asset paths during server-side rendering, resulting in more portable HTML. If `false`, `%sveltekit.assets%` and references to build artifacts will always be root-relative paths, unless `paths.assets` is an external URL
Single-page app fallback pages will always use absolute paths, regardless of this setting.
If your app uses a `<base>` element, you should set this to `false`, otherwise asset URLs will incorrectly be resolved against the `<base>` URL rather than the current page.
In 1.0, `undefined` was a valid value, which was set by default. In that case, if `paths.assets` was not external, SvelteKit would replace `%sveltekit.assets%` with a relative path and use relative paths to reference build artifacts, but `base` and `assets` imported from `$app/paths` would be as specified in your config.
##  prerender
See Prerendering.
```
concurrency?: number;
```

  * default `1`


How many pages can be prerendered simultaneously. JS is single-threaded, but in cases where prerendering performance is network-bound (for example loading content from a remote CMS) this can speed things up by processing other tasks while waiting on the network response.
```
crawl?: boolean;
```

  * default `true`


Whether SvelteKit should find pages to prerender by following links from `entries`.
```
entries?: var Array: ArrayConstructorArray<'*' | `/${string}`>;
```

  * default `["*"]`


An array of pages to prerender, or start crawling from (if `crawl: true`). The `*` string includes all routes containing no required `[parameters]` with optional parameters included as being empty (since SvelteKit doesn’t know what value any parameters should have).
```
handleHttpError?: PrerenderHttpErrorHandlerValue;
```

  * default `"fail"`
  * available since v1.15.7


How to respond to HTTP errors encountered while prerendering the app.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `status`, `path`, `referrer`, `referenceType` and `message` properties. If you `throw` from this function, the build will fail


svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        prerender: {
 handleHttpError: ({ path, referrer, message }: {
   path: any;
   referrer: any;
     message: any;
 }) => void;
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    prerender: {
        handleHttpError: ({ path, referrer, message }: {
 path: any;
 referrer: any;
 message: any;
        }) => void;
    };
}
```
`kit: { ````
prerender: {
    handleHttpError: ({ path, referrer, message }: {
        path: any;
        referrer: any;
        message: any;
    }) => void;
}
```
`prerender: { ````
handleHttpError: ({ path, referrer, message }: {
    path: any;
    referrer: any;
    message: any;
}) => void
```
`handleHttpError: ({ `path: any`path, `referrer: any`referrer, `message: any`message }) => { // ignore deliberate link to shiny 404 page if (`path: any`path === '/not-found' && `referrer: any`referrer === '/blog/how-we-built-our-404-page') { return; } // otherwise fail the build throw new ````
var Error: ErrorConstructor
new (message?: string, options?: ErrorOptions) => Error (+1 overload)
```
`Error(`message: any`message); } } } };`
```

```
handleMissingId?: PrerenderMissingIdHandlerValue;
```

  * default `"fail"`
  * available since v1.15.7


How to respond when hash links from one prerendered page to another don’t correspond to an `id` on the destination page.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `path`, `id`, `referrers` and `message` properties. If you `throw` from this function, the build will fail


```
handleEntryGeneratorMismatch?: PrerenderEntryGeneratorMismatchHandlerValue;
```

  * default `"fail"`
  * available since v1.16.0


How to respond when an entry generated by the `entries` export doesn’t match the route it was generated from.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `generatedFromId`, `entry`, `matchedId` and `message` properties. If you `throw` from this function, the build will fail


```
var origin: string


MDN Reference


origin?: string;
```

  * default `"http://sveltekit-prerender"`


The value of `url.origin` during prerendering; useful if it is included in rendered content.
##  router
```
type?: 'pathname' | 'hash';
```

  * default `"pathname"`
  * available since v2.14.0


What type of client-side router to use.
  * `'pathname'` is the default and means the current URL pathname determines the route
  * `'hash'` means the route is determined by `location.hash`. In this case, SSR and prerendering are disabled. This is only recommended if `pathname` is not an option, for example because you don’t control the webserver where your app is deployed. It comes with some caveats: you can’t use server-side rendering (or indeed any server logic), and you have to make sure that the links in your app all start with #/, or they won’t work. Beyond that, everything works exactly like a normal SvelteKit app.


```
resolution?: 'client' | 'server';
```

  * default `"client"`
  * available since v2.17.0


How to determine which route to load when navigating to a new page.
By default, SvelteKit will serve a route manifest to the browser. When navigating, this manifest is used (along with the `reroute` hook, if it exists) to determine which components to load and which `load` functions to run. Because everything happens on the client, this decision can be made immediately. The drawback is that the manifest needs to be loaded and parsed before the first navigation can happen, which may have an impact if your app contains many routes.
Alternatively, SvelteKit can determine the route on the server. This means that for every navigation to a path that has not yet been visited, the server will be asked to determine the route. This has several advantages:
  * The client does not need to load the routing manifest upfront, which can lead to faster initial page loads
  * The list of routes is hidden from public view
  * The server has an opportunity to intercept each navigation (for example through a middleware), enabling (for example) A/B testing opaque to SvelteKit


The drawback is that for unvisited paths, resolution will take slightly longer (though this is mitigated by preloading).
> When using server-side route resolution and prerendering, the resolution is prerendered along with the route itself.
##  serviceWorker
```
register?: boolean;
```

  * default `true`


Whether to automatically register the service worker, if it exists.
```
files?(filepath: stringfilepath: string): boolean;
```

  * default `(filename) => !/\.DS_Store/.test(filename)`


Determine which files in your `static` directory will be available in `$service-worker.files`.
##  typescript
```
config?: (config: Record<string, any>config: type Record<K extends keyof any, T> = { [P in K]: T; }


Construct a type with a set of properties K of type T


Record<string, any>) => Record<string, any> | void;
```

  * default `(config) => config`
  * available since v1.3.0


A function that allows you to edit the generated `tsconfig.json`. You can mutate the config (recommended) or return a new one. This is useful for extending a shared `tsconfig.json` in a monorepo root, for example.
##  version
Client-side navigation can be buggy if you deploy a new version of your app while people are using it. If the code for the new page is already loaded, it may have stale content; if it isn’t, the app’s route manifest may point to a JavaScript file that no longer exists. SvelteKit helps you solve this problem through version management. If SvelteKit encounters an error while loading the page and detects that a new version has been deployed (using the `name` specified here, which defaults to a timestamp of the build) it will fall back to traditional full-page navigation. Not all navigations will result in an error though, for example if the JavaScript for the next page is already loaded. If you still want to force a full-page navigation in these cases, use techniques such as setting the `pollInterval` and then using `beforeNavigate`:
+layout
```
<script>
	import { beforeNavigate } from '$app/navigation';
	import { updated } from '$app/state';

	beforeNavigate(({ willUnload, to }) => {
		if (updated.current && !willUnload && to?.url) {
			location.href = to.url.href;
		}
	});
</script>
```

If you set `pollInterval` to a non-zero value, SvelteKit will poll for new versions in the background and set the value of `updated.current` `true` when it detects one.
```
const name: void
@deprecated
name?: string;
```

The current app version string. If specified, this must be deterministic (e.g. a commit ref rather than `Math.random()` or `Date.now().toString()`), otherwise defaults to a timestamp of the build.
For example, to use the current commit hash, you could do use `git rev-parse HEAD`:
svelte.config
```
import * as module "node:child_process"child_process from 'node:child_process';

export default {
	```
kit: {
    version: {
        name: string;
    };
}
```
`kit: { ````
version: {
    name: string;
}
```
`version: { `name: string`name: `module "node:child_process"`child_process.`function execSync(command: string): Buffer (+3 overloads)`
The `child_process.execSync()` method is generally identical to {@link exec } with the exception that the method will not return until the child process has fully closed. When a timeout has been encountered and `killSignal` is sent, the method won’t return until the process has completely exited. If the child process intercepts and handles the `SIGTERM` signal and doesn’t exit, the parent process will wait until the child process has exited.
If the process times out or has a non-zero exit code, this method will throw. The `Error` object will contain the entire result from {@link spawnSync } .
**Never pass unsanitized user input to this function. Any input containing shell** **metacharacters may be used to trigger arbitrary command execution.**
@sincev0.11.12
@paramcommand The command to run.
@returnThe stdout from the command.
execSync('git rev-parse HEAD').`Buffer.toString(encoding?: BufferEncoding, start?: number, end?: number): string`
Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.
If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8, then each invalid byte is replaced with the replacement character `U+FFFD`.
The maximum length of a string instance (in UTF-16 code units) is available as {@link constants.MAX_STRING_LENGTH } .
```
import { Buffer } from 'node:buffer';

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &#x3C; 26; i++) {
  // 97 is the decimal ASCII value for 'a'.
  buf1[i] = i + 97;
}

console.log(buf1.toString('utf8'));
// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString('utf8', 0, 5));
// Prints: abcde

const buf2 = Buffer.from('tést');

console.log(buf2.toString('hex'));
// Prints: 74c3a97374
console.log(buf2.toString('utf8', 0, 3));
// Prints: té
console.log(buf2.toString(undefined, 0, 3));
// Prints: té
```

@sincev0.1.90
@paramencoding The character encoding to use.
@paramstart The byte offset to start decoding at.
@paramend The byte offset to stop decoding at (not inclusive).
toString().`String.trim(): string`
Removes the leading and trailing white space and line terminator characters from a string.
trim() } } };`
```

```
pollInterval?: number;
```

  * default `0`


The interval in milliseconds to poll for version changes. If this is `0`, no polling occurs.
Edit this page on GitHub llms.txt
previous next
$service-worker Command Line Interface
Your project’s configuration lives in a `svelte.config.js` file at the root of your project. As well as SvelteKit, this config object is used by other tooling that integrates with Svelte such as editor extensions.
svelte.config
```
import const adapter: () => import("@sveltejs/kit").Adapteradapter from '@sveltejs/adapter-auto';

/** @type {import('@sveltejs/kit').Config} */
const const config: Config

@type{import('@sveltejs/kit').Config}

config = {
	Config.kit?: KitConfig | undefined


SvelteKit options


kit: {
		KitConfig.adapter?: Adapter | undefined


Your adapter is run when executing vite build. It determines how the output is converted for different platforms.





@defaultundefined

adapter: function adapter(): import("@sveltejs/kit").Adapteradapter()
	}
};

export default const config: Config

@type{import('@sveltejs/kit').Config}

config;
```

##  Config
```
interface Config {…}
```

```
compilerOptions?: CompileOptions;
```

  * default `{}`


Options passed to `svelte.compile`.
```
extensions?: string[];
```

  * default `[".svelte"]`


List of file extensions that should be treated as Svelte files.
```
kit?: KitConfig;
```

SvelteKit options
```
preprocess?: any;
```

Preprocessor options, if any. Preprocessing can alternatively also be done through Vite’s preprocessor capabilities.
```
vitePlugin?: PluginOptions;
```

`vite-plugin-svelte` plugin options.
```
[key: string]: any;
```

Any additional options required by tooling that integrates with Svelte.
##  KitConfig
The `kit` property configures SvelteKit, and can have the following properties:
##  adapter
  * default `undefined`


Your adapter is run when executing `vite build`. It determines how the output is converted for different platforms.
##  alias
  * default `{}`


An object containing zero or more aliases used to replace values in `import` statements. These aliases are automatically passed to Vite and TypeScript.
svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        alias: {
 'my-file': string;
 'my-directory': string;
            'my-directory/*': string;
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    alias: {
        'my-file': string;
        'my-directory': string;
        'my-directory/*': string;
    };
}
```
`kit: { ````
alias: {
    'my-file': string;
    'my-directory': string;
    'my-directory/*': string;
}
```
`alias: { // this will match a file 'my-file': 'path/to/my-file.js', // this will match a directory and its contents // (`my-directory/x` resolves to `path/to/my-directory/x`) 'my-directory': 'path/to/my-directory', // an alias ending /* will only match // the contents of a directory, not the directory itself 'my-directory/*': 'path/to/my-directory/*' } } };`
```

> The built-in `$lib` alias is controlled by `config.kit.files.lib` as it is used for packaging.
> You will need to run `npm run dev` to have SvelteKit automatically generate the required alias configuration in `jsconfig.json` or `tsconfig.json`.
##  appDir
  * default `"_app"`


The directory where SvelteKit keeps its stuff, including static assets (such as JS and CSS) and internally-used routes.
If `paths.assets` is specified, there will be two app directories — `${paths.assets}/${appDir}` and `${paths.base}/${appDir}`.
##  csp
Content Security Policy configuration. CSP helps to protect your users against cross-site scripting (XSS) attacks, by limiting the places resources can be loaded from. For example, a configuration like this...
svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        csp: {
 directives: {
   'script-src': string[];
 };
 reportOnly: {
   'script-src': string[];
   'report-uri': string[];
 };
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    csp: {
        directives: {
 'script-src': string[];
        };
        reportOnly: {
 'script-src': string[];
 'report-uri': string[];
        };
    };
}
```
`kit: { ````
csp: {
    directives: {
        'script-src': string[];
    };
    reportOnly: {
        'script-src': string[];
        'report-uri': string[];
    };
}
```
`csp: { ````
directives: {
    'script-src': string[];
}
```
`directives: { 'script-src': ['self'] }, // must be specified with either the `report-uri` or `report-to` directives, or both ````
reportOnly: {
    'script-src': string[];
    'report-uri': string[];
}
```
`reportOnly: { 'script-src': ['self'], 'report-uri': ['/'] } } } }; export default ````
const config: {
    kit: {
        csp: {
 directives: {
   'script-src': string[];
 };
 reportOnly: {
   'script-src': string[];
   'report-uri': string[];
            };
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config;`
```

...would prevent scripts loading from external sites. SvelteKit will augment the specified directives with nonces or hashes (depending on `mode`) for any inline styles and scripts it generates.
To add a nonce for scripts and links manually included in `src/app.html`, you may use the placeholder `%sveltekit.nonce%` (for example `<script nonce="%sveltekit.nonce%">`).
When pages are prerendered, the CSP header is added via a `<meta http-equiv>` tag (note that in this case, `frame-ancestors`, `report-uri` and `sandbox` directives will be ignored).
> When `mode` is `'auto'`, SvelteKit will use nonces for dynamically rendered pages and hashes for prerendered pages. Using nonces with prerendered pages is insecure and therefore forbidden.
> Note that most Svelte transitions work by creating an inline `<style>` element. If you use these in your app, you must either leave the `style-src` directive unspecified or add `unsafe-inline`.
If this level of configuration is insufficient and you have more dynamic requirements, you can use the `handle` hook to roll your own CSP.
```
mode?: 'hash' | 'nonce' | 'auto';
```

Whether to use hashes or nonces to restrict `<script>` and `<style>` elements. `'auto'` will use hashes for prerendered pages, and nonces for dynamically rendered pages.
```
directives?: CspDirectives;
```

Directives that will be added to `Content-Security-Policy` headers.
```
reportOnly?: CspDirectives;
```

Directives that will be added to `Content-Security-Policy-Report-Only` headers.
##  csrf
Protection against cross-site request forgery (CSRF) attacks.
```
checkOrigin?: boolean;
```

  * default `true`


Whether to check the incoming `origin` header for `POST`, `PUT`, `PATCH`, or `DELETE` form submissions and verify that it matches the server’s origin.
To allow people to make `POST`, `PUT`, `PATCH`, or `DELETE` requests with a `Content-Type` of `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain` to your app from other origins, you will need to disable this option. Be careful!
##  embedded
  * default `false`


Whether or not the app is embedded inside a larger app. If `true`, SvelteKit will add its event listeners related to navigation etc on the parent of `%sveltekit.body%` instead of `window`, and will pass `params` from the server rather than inferring them from `location.pathname`. Note that it is generally not supported to embed multiple SvelteKit apps on the same page and use client-side SvelteKit features within them (things such as pushing to the history state assume a single instance).
##  env
Environment variable configuration
```
dir?: string;
```

  * default `"."`


The directory to search for `.env` files.
```
publicPrefix?: string;
```

  * default `"PUBLIC_"`


A prefix that signals that an environment variable is safe to expose to client-side code. See `$env/static/public` and `$env/dynamic/public`. Note that Vite’s `envPrefix` must be set separately if you are using Vite’s environment variable handling - though use of that feature should generally be unnecessary.
```
privatePrefix?: string;
```

  * default `""`
  * available since v1.21.0


A prefix that signals that an environment variable is unsafe to expose to client-side code. Environment variables matching neither the public nor the private prefix will be discarded completely. See `$env/static/private` and `$env/dynamic/private`.
##  files
Where to find various files within your project.
```
assets?: string;
```

  * default `"static"`


a place to put static files that should have stable URLs and undergo no processing, such as `favicon.ico` or `manifest.json`
```
hooks?: {…}
```

```
client?: string;
```

  * default `"src/hooks.client"`


The location of your client hooks.
```
server?: string;
```

  * default `"src/hooks.server"`


The location of your server hooks.
```
universal?: string;
```

  * default `"src/hooks"`
  * available since v2.3.0


The location of your universal hooks.
```
lib?: string;
```

  * default `"src/lib"`


your app’s internal library, accessible throughout the codebase as `$lib`
```
params?: string;
```

  * default `"src/params"`


a directory containing parameter matchers
```
routes?: string;
```

  * default `"src/routes"`


the files that define the structure of your app (see Routing)
```
serviceWorker?: string;
```

  * default `"src/service-worker"`


the location of your service worker’s entry point (see Service workers)
```
appTemplate?: string;
```

  * default `"src/app.html"`


the location of the template for HTML responses
```
errorTemplate?: string;
```

  * default `"src/error.html"`


the location of the template for fallback error responses
##  inlineStyleThreshold
  * default `0`


Inline CSS inside a `<style>` block at the head of the HTML. This option is a number that specifies the maximum length of a CSS file in UTF-16 code units, as specified by the String.length property, to be inlined. All CSS files needed for the page and smaller than this value are merged and inlined in a `<style>` block.
> This results in fewer initial requests and can improve your First Contentful Paint score. However, it generates larger HTML output and reduces the effectiveness of browser caches. Use it advisedly.
##  moduleExtensions
  * default `[".js", ".ts"]`


An array of file extensions that SvelteKit will treat as modules. Files with extensions that match neither `config.extensions` nor `config.kit.moduleExtensions` will be ignored by the router.
##  outDir
  * default `".svelte-kit"`


The directory that SvelteKit writes files to during `dev` and `build`. You should exclude this directory from version control.
##  output
Options related to the build output format
```
preloadStrategy?: 'modulepreload' | 'preload-js' | 'preload-mjs';
```

  * default `"modulepreload"`
  * available since v1.8.4


SvelteKit will preload the JavaScript modules needed for the initial page to avoid import ‘waterfalls’, resulting in faster application startup. There are three strategies with different trade-offs:
  * `modulepreload` - uses `<link rel="modulepreload">`. This delivers the best results in Chromium-based browsers, in Firefox 115+, and Safari 17+. It is ignored in older browsers.
  * `preload-js` - uses `<link rel="preload">`. Prevents waterfalls in Chromium and Safari, but Chromium will parse each module twice (once as a script, once as a module). Causes modules to be requested twice in Firefox. This is a good setting if you want to maximise performance for users on iOS devices at the cost of a very slight degradation for Chromium users.
  * `preload-mjs` - uses `<link rel="preload">` but with the `.mjs` extension which prevents double-parsing in Chromium. Some static webservers will fail to serve .mjs files with a `Content-Type: application/javascript` header, which will cause your application to break. If that doesn’t apply to you, this is the option that will deliver the best performance for the largest number of users, until `modulepreload` is more widely supported.


```
bundleStrategy?: 'split' | 'single' | 'inline';
```

  * default `'split'`
  * available since v2.13.0


The bundle strategy option affects how your app’s JavaScript and CSS files are loaded.
  * If `'split'`, splits the app up into multiple .js/.css files so that they are loaded lazily as the user navigates around the app. This is the default, and is recommended for most scenarios.
  * If `'single'`, creates just one .js bundle and one .css file containing code for the entire app.
  * If `'inline'`, inlines all JavaScript and CSS of the entire app into the HTML. The result is usable without a server (i.e. you can just open the file in your browser).


When using `'split'`, you can also adjust the bundling behaviour by setting `output.experimentalMinChunkSize` and `output.manualChunks` inside your Vite config’s `build.rollupOptions`.
If you want to inline your assets, you’ll need to set Vite’s `build.assetsInlineLimit` option to an appropriate size then import your assets through Vite.
vite.config
```
import { function sveltekit(): Promise<Plugin<any>[]>


Returns the SvelteKit Vite plugins.


sveltekit } from '@sveltejs/kit/vite';
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)


Type helper to make it easier to use vite.config.ts
accepts a direct 
{@link 
UserConfig
}
 object, or a function that returns it.
The function receives a 
{@link 
ConfigEnv
}
 object.


defineConfig } from 'vite';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)


Type helper to make it easier to use vite.config.ts
accepts a direct 
{@link 
UserConfig
}
 object, or a function that returns it.
The function receives a 
{@link 
ConfigEnv
}
 object.


defineConfig({
	UserConfig.plugins?: PluginOption[] | undefined


Array of vite plugins to use.


plugins: [function sveltekit(): Promise<Plugin<any>[]>


Returns the SvelteKit Vite plugins.


sveltekit()],
	UserConfig.build?: BuildOptions | undefined


Build specific options


build: {
		// inline all imported assets
		BuildOptions.assetsInlineLimit?: number | ((filePath: string, content: Buffer) => boolean | undefined) | undefined


Static asset files smaller than this number (in bytes) will be inlined as
base64 strings. Default limit is 4096 (4 KiB). Set to 0 to disable.





@default4096

assetsInlineLimit: var Infinity: numberInfinity
	}
});
```

src/routes/+layout
```
<script>
	// import the asset through Vite
	import favicon from './favicon.png';
</script>

<svelte:head>
	<!-- this asset will be inlined as a base64 URL -->
	<link rel="icon" href={favicon} />
</svelte:head>
```
```
<script lang="ts">
	// import the asset through Vite
	import favicon from './favicon.png';
</script>

<svelte:head>
	<!-- this asset will be inlined as a base64 URL -->
	<link rel="icon" href={favicon} />
</svelte:head>
```

##  paths
```
assets?: '' | `http://${string}` | `https://${string}`;
```

  * default `""`


An absolute path that your app’s files are served from. This is useful if your files are served from a storage bucket of some kind.
```
base?: '' | `/${string}`;
```

  * default `""`


A root-relative path that must start, but not end with `/` (e.g. `/base-path`), unless it is the empty string. This specifies where your app is served from and allows the app to live on a non-root path. Note that you need to prepend all your root-relative links with the base value or they will point to the root of your domain, not your `base` (this is how the browser works). You can use `base` from `$app/paths` for that: `<a href="{base}/your-page">Link</a>`. If you find yourself writing this often, it may make sense to extract this into a reusable component.
```
relative?: boolean;
```

  * default `true`
  * available since v1.9.0


Whether to use relative asset paths.
If `true`, `base` and `assets` imported from `$app/paths` will be replaced with relative asset paths during server-side rendering, resulting in more portable HTML. If `false`, `%sveltekit.assets%` and references to build artifacts will always be root-relative paths, unless `paths.assets` is an external URL
Single-page app fallback pages will always use absolute paths, regardless of this setting.
If your app uses a `<base>` element, you should set this to `false`, otherwise asset URLs will incorrectly be resolved against the `<base>` URL rather than the current page.
In 1.0, `undefined` was a valid value, which was set by default. In that case, if `paths.assets` was not external, SvelteKit would replace `%sveltekit.assets%` with a relative path and use relative paths to reference build artifacts, but `base` and `assets` imported from `$app/paths` would be as specified in your config.
##  prerender
See Prerendering.
```
concurrency?: number;
```

  * default `1`


How many pages can be prerendered simultaneously. JS is single-threaded, but in cases where prerendering performance is network-bound (for example loading content from a remote CMS) this can speed things up by processing other tasks while waiting on the network response.
```
crawl?: boolean;
```

  * default `true`


Whether SvelteKit should find pages to prerender by following links from `entries`.
```
entries?: var Array: ArrayConstructorArray<'*' | `/${string}`>;
```

  * default `["*"]`


An array of pages to prerender, or start crawling from (if `crawl: true`). The `*` string includes all routes containing no required `[parameters]` with optional parameters included as being empty (since SvelteKit doesn’t know what value any parameters should have).
```
handleHttpError?: PrerenderHttpErrorHandlerValue;
```

  * default `"fail"`
  * available since v1.15.7


How to respond to HTTP errors encountered while prerendering the app.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `status`, `path`, `referrer`, `referenceType` and `message` properties. If you `throw` from this function, the build will fail


svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        prerender: {
 handleHttpError: ({ path, referrer, message }: {
   path: any;
   referrer: any;
     message: any;
 }) => void;
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    prerender: {
        handleHttpError: ({ path, referrer, message }: {
 path: any;
 referrer: any;
 message: any;
        }) => void;
    };
}
```
`kit: { ````
prerender: {
    handleHttpError: ({ path, referrer, message }: {
        path: any;
        referrer: any;
        message: any;
    }) => void;
}
```
`prerender: { ````
handleHttpError: ({ path, referrer, message }: {
    path: any;
    referrer: any;
    message: any;
}) => void
```
`handleHttpError: ({ `path: any`path, `referrer: any`referrer, `message: any`message }) => { // ignore deliberate link to shiny 404 page if (`path: any`path === '/not-found' && `referrer: any`referrer === '/blog/how-we-built-our-404-page') { return; } // otherwise fail the build throw new ````
var Error: ErrorConstructor
new (message?: string, options?: ErrorOptions) => Error (+1 overload)
```
`Error(`message: any`message); } } } };`
```

```
handleMissingId?: PrerenderMissingIdHandlerValue;
```

  * default `"fail"`
  * available since v1.15.7


How to respond when hash links from one prerendered page to another don’t correspond to an `id` on the destination page.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `path`, `id`, `referrers` and `message` properties. If you `throw` from this function, the build will fail


```
handleEntryGeneratorMismatch?: PrerenderEntryGeneratorMismatchHandlerValue;
```

  * default `"fail"`
  * available since v1.16.0


How to respond when an entry generated by the `entries` export doesn’t match the route it was generated from.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `generatedFromId`, `entry`, `matchedId` and `message` properties. If you `throw` from this function, the build will fail


```
var origin: string


MDN Reference


origin?: string;
```

  * default `"http://sveltekit-prerender"`


The value of `url.origin` during prerendering; useful if it is included in rendered content.
##  router
```
type?: 'pathname' | 'hash';
```

  * default `"pathname"`
  * available since v2.14.0


What type of client-side router to use.
  * `'pathname'` is the default and means the current URL pathname determines the route
  * `'hash'` means the route is determined by `location.hash`. In this case, SSR and prerendering are disabled. This is only recommended if `pathname` is not an option, for example because you don’t control the webserver where your app is deployed. It comes with some caveats: you can’t use server-side rendering (or indeed any server logic), and you have to make sure that the links in your app all start with #/, or they won’t work. Beyond that, everything works exactly like a normal SvelteKit app.


```
resolution?: 'client' | 'server';
```

  * default `"client"`
  * available since v2.17.0


How to determine which route to load when navigating to a new page.
By default, SvelteKit will serve a route manifest to the browser. When navigating, this manifest is used (along with the `reroute` hook, if it exists) to determine which components to load and which `load` functions to run. Because everything happens on the client, this decision can be made immediately. The drawback is that the manifest needs to be loaded and parsed before the first navigation can happen, which may have an impact if your app contains many routes.
Alternatively, SvelteKit can determine the route on the server. This means that for every navigation to a path that has not yet been visited, the server will be asked to determine the route. This has several advantages:
  * The client does not need to load the routing manifest upfront, which can lead to faster initial page loads
  * The list of routes is hidden from public view
  * The server has an opportunity to intercept each navigation (for example through a middleware), enabling (for example) A/B testing opaque to SvelteKit


The drawback is that for unvisited paths, resolution will take slightly longer (though this is mitigated by preloading).
> When using server-side route resolution and prerendering, the resolution is prerendered along with the route itself.
##  serviceWorker
```
register?: boolean;
```

  * default `true`


Whether to automatically register the service worker, if it exists.
```
files?(filepath: stringfilepath: string): boolean;
```

  * default `(filename) => !/\.DS_Store/.test(filename)`


Determine which files in your `static` directory will be available in `$service-worker.files`.
##  typescript
```
config?: (config: Record<string, any>config: type Record<K extends keyof any, T> = { [P in K]: T; }


Construct a type with a set of properties K of type T


Record<string, any>) => Record<string, any> | void;
```

  * default `(config) => config`
  * available since v1.3.0


A function that allows you to edit the generated `tsconfig.json`. You can mutate the config (recommended) or return a new one. This is useful for extending a shared `tsconfig.json` in a monorepo root, for example.
##  version
Client-side navigation can be buggy if you deploy a new version of your app while people are using it. If the code for the new page is already loaded, it may have stale content; if it isn’t, the app’s route manifest may point to a JavaScript file that no longer exists. SvelteKit helps you solve this problem through version management. If SvelteKit encounters an error while loading the page and detects that a new version has been deployed (using the `name` specified here, which defaults to a timestamp of the build) it will fall back to traditional full-page navigation. Not all navigations will result in an error though, for example if the JavaScript for the next page is already loaded. If you still want to force a full-page navigation in these cases, use techniques such as setting the `pollInterval` and then using `beforeNavigate`:
+layout
```
<script>
	import { beforeNavigate } from '$app/navigation';
	import { updated } from '$app/state';

	beforeNavigate(({ willUnload, to }) => {
		if (updated.current && !willUnload && to?.url) {
			location.href = to.url.href;
		}
	});
</script>
```

If you set `pollInterval` to a non-zero value, SvelteKit will poll for new versions in the background and set the value of `updated.current` `true` when it detects one.
```
const name: void
@deprecated
name?: string;
```

The current app version string. If specified, this must be deterministic (e.g. a commit ref rather than `Math.random()` or `Date.now().toString()`), otherwise defaults to a timestamp of the build.
For example, to use the current commit hash, you could do use `git rev-parse HEAD`:
svelte.config
```
import * as module "node:child_process"child_process from 'node:child_process';

export default {
	```
kit: {
    version: {
        name: string;
    };
}
```
`kit: { ````
version: {
    name: string;
}
```
`version: { `name: string`name: `module "node:child_process"`child_process.`function execSync(command: string): Buffer (+3 overloads)`
The `child_process.execSync()` method is generally identical to {@link exec } with the exception that the method will not return until the child process has fully closed. When a timeout has been encountered and `killSignal` is sent, the method won’t return until the process has completely exited. If the child process intercepts and handles the `SIGTERM` signal and doesn’t exit, the parent process will wait until the child process has exited.
If the process times out or has a non-zero exit code, this method will throw. The `Error` object will contain the entire result from {@link spawnSync } .
**Never pass unsanitized user input to this function. Any input containing shell** **metacharacters may be used to trigger arbitrary command execution.**
@sincev0.11.12
@paramcommand The command to run.
@returnThe stdout from the command.
execSync('git rev-parse HEAD').`Buffer.toString(encoding?: BufferEncoding, start?: number, end?: number): string`
Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.
If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8, then each invalid byte is replaced with the replacement character `U+FFFD`.
The maximum length of a string instance (in UTF-16 code units) is available as {@link constants.MAX_STRING_LENGTH } .
```
import { Buffer } from 'node:buffer';

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &#x3C; 26; i++) {
  // 97 is the decimal ASCII value for 'a'.
  buf1[i] = i + 97;
}

console.log(buf1.toString('utf8'));
// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString('utf8', 0, 5));
// Prints: abcde

const buf2 = Buffer.from('tést');

console.log(buf2.toString('hex'));
// Prints: 74c3a97374
console.log(buf2.toString('utf8', 0, 3));
// Prints: té
console.log(buf2.toString(undefined, 0, 3));
// Prints: té
```

@sincev0.1.90
@paramencoding The character encoding to use.
@paramstart The byte offset to start decoding at.
@paramend The byte offset to stop decoding at (not inclusive).
toString().`String.trim(): string`
Removes the leading and trailing white space and line terminator characters from a string.
trim() } } };`
```

```
pollInterval?: number;
```

  * default `0`


The interval in milliseconds to poll for version changes. If this is `0`, no polling occurs.
Edit this page on GitHub llms.txt
previous next
$service-worker Command Line Interface
Your project’s configuration lives in a `svelte.config.js` file at the root of your project. As well as SvelteKit, this config object is used by other tooling that integrates with Svelte such as editor extensions.
svelte.config
```
import const adapter: () => import("@sveltejs/kit").Adapteradapter from '@sveltejs/adapter-auto';

/** @type {import('@sveltejs/kit').Config} */
const const config: Config

@type{import('@sveltejs/kit').Config}

config = {
	Config.kit?: KitConfig | undefined


SvelteKit options


kit: {
		KitConfig.adapter?: Adapter | undefined


Your adapter is run when executing vite build. It determines how the output is converted for different platforms.





@defaultundefined

adapter: function adapter(): import("@sveltejs/kit").Adapteradapter()
	}
};

export default const config: Config

@type{import('@sveltejs/kit').Config}

config;
```

##  Config
```
interface Config {…}
```

```
compilerOptions?: CompileOptions;
```

  * default `{}`


Options passed to `svelte.compile`.
```
extensions?: string[];
```

  * default `[".svelte"]`


List of file extensions that should be treated as Svelte files.
```
kit?: KitConfig;
```

SvelteKit options
```
preprocess?: any;
```

Preprocessor options, if any. Preprocessing can alternatively also be done through Vite’s preprocessor capabilities.
```
vitePlugin?: PluginOptions;
```

`vite-plugin-svelte` plugin options.
```
[key: string]: any;
```

Any additional options required by tooling that integrates with Svelte.
##  KitConfig
The `kit` property configures SvelteKit, and can have the following properties:
##  adapter
  * default `undefined`


Your adapter is run when executing `vite build`. It determines how the output is converted for different platforms.
##  alias
  * default `{}`


An object containing zero or more aliases used to replace values in `import` statements. These aliases are automatically passed to Vite and TypeScript.
svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        alias: {
 'my-file': string;
 'my-directory': string;
            'my-directory/*': string;
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    alias: {
        'my-file': string;
        'my-directory': string;
        'my-directory/*': string;
    };
}
```
`kit: { ````
alias: {
    'my-file': string;
    'my-directory': string;
    'my-directory/*': string;
}
```
`alias: { // this will match a file 'my-file': 'path/to/my-file.js', // this will match a directory and its contents // (`my-directory/x` resolves to `path/to/my-directory/x`) 'my-directory': 'path/to/my-directory', // an alias ending /* will only match // the contents of a directory, not the directory itself 'my-directory/*': 'path/to/my-directory/*' } } };`
```

> The built-in `$lib` alias is controlled by `config.kit.files.lib` as it is used for packaging.
> You will need to run `npm run dev` to have SvelteKit automatically generate the required alias configuration in `jsconfig.json` or `tsconfig.json`.
##  appDir
  * default `"_app"`


The directory where SvelteKit keeps its stuff, including static assets (such as JS and CSS) and internally-used routes.
If `paths.assets` is specified, there will be two app directories — `${paths.assets}/${appDir}` and `${paths.base}/${appDir}`.
##  csp
Content Security Policy configuration. CSP helps to protect your users against cross-site scripting (XSS) attacks, by limiting the places resources can be loaded from. For example, a configuration like this...
svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        csp: {
 directives: {
   'script-src': string[];
 };
 reportOnly: {
   'script-src': string[];
   'report-uri': string[];
 };
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    csp: {
        directives: {
 'script-src': string[];
        };
        reportOnly: {
 'script-src': string[];
 'report-uri': string[];
        };
    };
}
```
`kit: { ````
csp: {
    directives: {
        'script-src': string[];
    };
    reportOnly: {
        'script-src': string[];
        'report-uri': string[];
    };
}
```
`csp: { ````
directives: {
    'script-src': string[];
}
```
`directives: { 'script-src': ['self'] }, // must be specified with either the `report-uri` or `report-to` directives, or both ````
reportOnly: {
    'script-src': string[];
    'report-uri': string[];
}
```
`reportOnly: { 'script-src': ['self'], 'report-uri': ['/'] } } } }; export default ````
const config: {
    kit: {
        csp: {
 directives: {
   'script-src': string[];
 };
 reportOnly: {
   'script-src': string[];
   'report-uri': string[];
            };
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config;`
```

...would prevent scripts loading from external sites. SvelteKit will augment the specified directives with nonces or hashes (depending on `mode`) for any inline styles and scripts it generates.
To add a nonce for scripts and links manually included in `src/app.html`, you may use the placeholder `%sveltekit.nonce%` (for example `<script nonce="%sveltekit.nonce%">`).
When pages are prerendered, the CSP header is added via a `<meta http-equiv>` tag (note that in this case, `frame-ancestors`, `report-uri` and `sandbox` directives will be ignored).
> When `mode` is `'auto'`, SvelteKit will use nonces for dynamically rendered pages and hashes for prerendered pages. Using nonces with prerendered pages is insecure and therefore forbidden.
> Note that most Svelte transitions work by creating an inline `<style>` element. If you use these in your app, you must either leave the `style-src` directive unspecified or add `unsafe-inline`.
If this level of configuration is insufficient and you have more dynamic requirements, you can use the `handle` hook to roll your own CSP.
```
mode?: 'hash' | 'nonce' | 'auto';
```

Whether to use hashes or nonces to restrict `<script>` and `<style>` elements. `'auto'` will use hashes for prerendered pages, and nonces for dynamically rendered pages.
```
directives?: CspDirectives;
```

Directives that will be added to `Content-Security-Policy` headers.
```
reportOnly?: CspDirectives;
```

Directives that will be added to `Content-Security-Policy-Report-Only` headers.
##  csrf
Protection against cross-site request forgery (CSRF) attacks.
```
checkOrigin?: boolean;
```

  * default `true`


Whether to check the incoming `origin` header for `POST`, `PUT`, `PATCH`, or `DELETE` form submissions and verify that it matches the server’s origin.
To allow people to make `POST`, `PUT`, `PATCH`, or `DELETE` requests with a `Content-Type` of `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain` to your app from other origins, you will need to disable this option. Be careful!
##  embedded
  * default `false`


Whether or not the app is embedded inside a larger app. If `true`, SvelteKit will add its event listeners related to navigation etc on the parent of `%sveltekit.body%` instead of `window`, and will pass `params` from the server rather than inferring them from `location.pathname`. Note that it is generally not supported to embed multiple SvelteKit apps on the same page and use client-side SvelteKit features within them (things such as pushing to the history state assume a single instance).
##  env
Environment variable configuration
```
dir?: string;
```

  * default `"."`


The directory to search for `.env` files.
```
publicPrefix?: string;
```

  * default `"PUBLIC_"`


A prefix that signals that an environment variable is safe to expose to client-side code. See `$env/static/public` and `$env/dynamic/public`. Note that Vite’s `envPrefix` must be set separately if you are using Vite’s environment variable handling - though use of that feature should generally be unnecessary.
```
privatePrefix?: string;
```

  * default `""`
  * available since v1.21.0


A prefix that signals that an environment variable is unsafe to expose to client-side code. Environment variables matching neither the public nor the private prefix will be discarded completely. See `$env/static/private` and `$env/dynamic/private`.
##  files
Where to find various files within your project.
```
assets?: string;
```

  * default `"static"`


a place to put static files that should have stable URLs and undergo no processing, such as `favicon.ico` or `manifest.json`
```
hooks?: {…}
```

```
client?: string;
```

  * default `"src/hooks.client"`


The location of your client hooks.
```
server?: string;
```

  * default `"src/hooks.server"`


The location of your server hooks.
```
universal?: string;
```

  * default `"src/hooks"`
  * available since v2.3.0


The location of your universal hooks.
```
lib?: string;
```

  * default `"src/lib"`


your app’s internal library, accessible throughout the codebase as `$lib`
```
params?: string;
```

  * default `"src/params"`


a directory containing parameter matchers
```
routes?: string;
```

  * default `"src/routes"`


the files that define the structure of your app (see Routing)
```
serviceWorker?: string;
```

  * default `"src/service-worker"`


the location of your service worker’s entry point (see Service workers)
```
appTemplate?: string;
```

  * default `"src/app.html"`


the location of the template for HTML responses
```
errorTemplate?: string;
```

  * default `"src/error.html"`


the location of the template for fallback error responses
##  inlineStyleThreshold
  * default `0`


Inline CSS inside a `<style>` block at the head of the HTML. This option is a number that specifies the maximum length of a CSS file in UTF-16 code units, as specified by the String.length property, to be inlined. All CSS files needed for the page and smaller than this value are merged and inlined in a `<style>` block.
> This results in fewer initial requests and can improve your First Contentful Paint score. However, it generates larger HTML output and reduces the effectiveness of browser caches. Use it advisedly.
##  moduleExtensions
  * default `[".js", ".ts"]`


An array of file extensions that SvelteKit will treat as modules. Files with extensions that match neither `config.extensions` nor `config.kit.moduleExtensions` will be ignored by the router.
##  outDir
  * default `".svelte-kit"`


The directory that SvelteKit writes files to during `dev` and `build`. You should exclude this directory from version control.
##  output
Options related to the build output format
```
preloadStrategy?: 'modulepreload' | 'preload-js' | 'preload-mjs';
```

  * default `"modulepreload"`
  * available since v1.8.4


SvelteKit will preload the JavaScript modules needed for the initial page to avoid import ‘waterfalls’, resulting in faster application startup. There are three strategies with different trade-offs:
  * `modulepreload` - uses `<link rel="modulepreload">`. This delivers the best results in Chromium-based browsers, in Firefox 115+, and Safari 17+. It is ignored in older browsers.
  * `preload-js` - uses `<link rel="preload">`. Prevents waterfalls in Chromium and Safari, but Chromium will parse each module twice (once as a script, once as a module). Causes modules to be requested twice in Firefox. This is a good setting if you want to maximise performance for users on iOS devices at the cost of a very slight degradation for Chromium users.
  * `preload-mjs` - uses `<link rel="preload">` but with the `.mjs` extension which prevents double-parsing in Chromium. Some static webservers will fail to serve .mjs files with a `Content-Type: application/javascript` header, which will cause your application to break. If that doesn’t apply to you, this is the option that will deliver the best performance for the largest number of users, until `modulepreload` is more widely supported.


```
bundleStrategy?: 'split' | 'single' | 'inline';
```

  * default `'split'`
  * available since v2.13.0


The bundle strategy option affects how your app’s JavaScript and CSS files are loaded.
  * If `'split'`, splits the app up into multiple .js/.css files so that they are loaded lazily as the user navigates around the app. This is the default, and is recommended for most scenarios.
  * If `'single'`, creates just one .js bundle and one .css file containing code for the entire app.
  * If `'inline'`, inlines all JavaScript and CSS of the entire app into the HTML. The result is usable without a server (i.e. you can just open the file in your browser).


When using `'split'`, you can also adjust the bundling behaviour by setting `output.experimentalMinChunkSize` and `output.manualChunks` inside your Vite config’s `build.rollupOptions`.
If you want to inline your assets, you’ll need to set Vite’s `build.assetsInlineLimit` option to an appropriate size then import your assets through Vite.
vite.config
```
import { function sveltekit(): Promise<Plugin<any>[]>


Returns the SvelteKit Vite plugins.


sveltekit } from '@sveltejs/kit/vite';
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)


Type helper to make it easier to use vite.config.ts
accepts a direct 
{@link 
UserConfig
}
 object, or a function that returns it.
The function receives a 
{@link 
ConfigEnv
}
 object.


defineConfig } from 'vite';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)


Type helper to make it easier to use vite.config.ts
accepts a direct 
{@link 
UserConfig
}
 object, or a function that returns it.
The function receives a 
{@link 
ConfigEnv
}
 object.


defineConfig({
	UserConfig.plugins?: PluginOption[] | undefined


Array of vite plugins to use.


plugins: [function sveltekit(): Promise<Plugin<any>[]>


Returns the SvelteKit Vite plugins.


sveltekit()],
	UserConfig.build?: BuildOptions | undefined


Build specific options


build: {
		// inline all imported assets
		BuildOptions.assetsInlineLimit?: number | ((filePath: string, content: Buffer) => boolean | undefined) | undefined


Static asset files smaller than this number (in bytes) will be inlined as
base64 strings. Default limit is 4096 (4 KiB). Set to 0 to disable.





@default4096

assetsInlineLimit: var Infinity: numberInfinity
	}
});
```

src/routes/+layout
```
<script>
	// import the asset through Vite
	import favicon from './favicon.png';
</script>

<svelte:head>
	<!-- this asset will be inlined as a base64 URL -->
	<link rel="icon" href={favicon} />
</svelte:head>
```
```
<script lang="ts">
	// import the asset through Vite
	import favicon from './favicon.png';
</script>

<svelte:head>
	<!-- this asset will be inlined as a base64 URL -->
	<link rel="icon" href={favicon} />
</svelte:head>
```

##  paths
```
assets?: '' | `http://${string}` | `https://${string}`;
```

  * default `""`


An absolute path that your app’s files are served from. This is useful if your files are served from a storage bucket of some kind.
```
base?: '' | `/${string}`;
```

  * default `""`


A root-relative path that must start, but not end with `/` (e.g. `/base-path`), unless it is the empty string. This specifies where your app is served from and allows the app to live on a non-root path. Note that you need to prepend all your root-relative links with the base value or they will point to the root of your domain, not your `base` (this is how the browser works). You can use `base` from `$app/paths` for that: `<a href="{base}/your-page">Link</a>`. If you find yourself writing this often, it may make sense to extract this into a reusable component.
```
relative?: boolean;
```

  * default `true`
  * available since v1.9.0


Whether to use relative asset paths.
If `true`, `base` and `assets` imported from `$app/paths` will be replaced with relative asset paths during server-side rendering, resulting in more portable HTML. If `false`, `%sveltekit.assets%` and references to build artifacts will always be root-relative paths, unless `paths.assets` is an external URL
Single-page app fallback pages will always use absolute paths, regardless of this setting.
If your app uses a `<base>` element, you should set this to `false`, otherwise asset URLs will incorrectly be resolved against the `<base>` URL rather than the current page.
In 1.0, `undefined` was a valid value, which was set by default. In that case, if `paths.assets` was not external, SvelteKit would replace `%sveltekit.assets%` with a relative path and use relative paths to reference build artifacts, but `base` and `assets` imported from `$app/paths` would be as specified in your config.
##  prerender
See Prerendering.
```
concurrency?: number;
```

  * default `1`


How many pages can be prerendered simultaneously. JS is single-threaded, but in cases where prerendering performance is network-bound (for example loading content from a remote CMS) this can speed things up by processing other tasks while waiting on the network response.
```
crawl?: boolean;
```

  * default `true`


Whether SvelteKit should find pages to prerender by following links from `entries`.
```
entries?: var Array: ArrayConstructorArray<'*' | `/${string}`>;
```

  * default `["*"]`


An array of pages to prerender, or start crawling from (if `crawl: true`). The `*` string includes all routes containing no required `[parameters]` with optional parameters included as being empty (since SvelteKit doesn’t know what value any parameters should have).
```
handleHttpError?: PrerenderHttpErrorHandlerValue;
```

  * default `"fail"`
  * available since v1.15.7


How to respond to HTTP errors encountered while prerendering the app.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `status`, `path`, `referrer`, `referenceType` and `message` properties. If you `throw` from this function, the build will fail


svelte.config
```
/** @type {import('@sveltejs/kit').Config} */
const ```
const config: {
    kit: {
        prerender: {
 handleHttpError: ({ path, referrer, message }: {
   path: any;
   referrer: any;
     message: any;
 }) => void;
        };
    };
}
```
`
@type{import('@sveltejs/kit').Config}
config = { ````
kit: {
    prerender: {
        handleHttpError: ({ path, referrer, message }: {
 path: any;
 referrer: any;
 message: any;
        }) => void;
    };
}
```
`kit: { ````
prerender: {
    handleHttpError: ({ path, referrer, message }: {
        path: any;
        referrer: any;
        message: any;
    }) => void;
}
```
`prerender: { ````
handleHttpError: ({ path, referrer, message }: {
    path: any;
    referrer: any;
    message: any;
}) => void
```
`handleHttpError: ({ `path: any`path, `referrer: any`referrer, `message: any`message }) => { // ignore deliberate link to shiny 404 page if (`path: any`path === '/not-found' && `referrer: any`referrer === '/blog/how-we-built-our-404-page') { return; } // otherwise fail the build throw new ````
var Error: ErrorConstructor
new (message?: string, options?: ErrorOptions) => Error (+1 overload)
```
`Error(`message: any`message); } } } };`
```

```
handleMissingId?: PrerenderMissingIdHandlerValue;
```

  * default `"fail"`
  * available since v1.15.7


How to respond when hash links from one prerendered page to another don’t correspond to an `id` on the destination page.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `path`, `id`, `referrers` and `message` properties. If you `throw` from this function, the build will fail


```
handleEntryGeneratorMismatch?: PrerenderEntryGeneratorMismatchHandlerValue;
```

  * default `"fail"`
  * available since v1.16.0


How to respond when an entry generated by the `entries` export doesn’t match the route it was generated from.
  * `'fail'` — fail the build
  * `'ignore'` - silently ignore the failure and continue
  * `'warn'` — continue, but print a warning
  * `(details) => void` — a custom error handler that takes a `details` object with `generatedFromId`, `entry`, `matchedId` and `message` properties. If you `throw` from this function, the build will fail


```
var origin: string


MDN Reference


origin?: string;
```

  * default `"http://sveltekit-prerender"`


The value of `url.origin` during prerendering; useful if it is included in rendered content.
##  router
```
type?: 'pathname' | 'hash';
```

  * default `"pathname"`
  * available since v2.14.0


What type of client-side router to use.
  * `'pathname'` is the default and means the current URL pathname determines the route
  * `'hash'` means the route is determined by `location.hash`. In this case, SSR and prerendering are disabled. This is only recommended if `pathname` is not an option, for example because you don’t control the webserver where your app is deployed. It comes with some caveats: you can’t use server-side rendering (or indeed any server logic), and you have to make sure that the links in your app all start with #/, or they won’t work. Beyond that, everything works exactly like a normal SvelteKit app.


```
resolution?: 'client' | 'server';
```

  * default `"client"`
  * available since v2.17.0


How to determine which route to load when navigating to a new page.
By default, SvelteKit will serve a route manifest to the browser. When navigating, this manifest is used (along with the `reroute` hook, if it exists) to determine which components to load and which `load` functions to run. Because everything happens on the client, this decision can be made immediately. The drawback is that the manifest needs to be loaded and parsed before the first navigation can happen, which may have an impact if your app contains many routes.
Alternatively, SvelteKit can determine the route on the server. This means that for every navigation to a path that has not yet been visited, the server will be asked to determine the route. This has several advantages:
  * The client does not need to load the routing manifest upfront, which can lead to faster initial page loads
  * The list of routes is hidden from public view
  * The server has an opportunity to intercept each navigation (for example through a middleware), enabling (for example) A/B testing opaque to SvelteKit


The drawback is that for unvisited paths, resolution will take slightly longer (though this is mitigated by preloading).
> When using server-side route resolution and prerendering, the resolution is prerendered along with the route itself.
##  serviceWorker
```
register?: boolean;
```

  * default `true`


Whether to automatically register the service worker, if it exists.
```
files?(filepath: stringfilepath: string): boolean;
```

  * default `(filename) => !/\.DS_Store/.test(filename)`


Determine which files in your `static` directory will be available in `$service-worker.files`.
##  typescript
```
config?: (config: Record<string, any>config: type Record<K extends keyof any, T> = { [P in K]: T; }


Construct a type with a set of properties K of type T


Record<string, any>) => Record<string, any> | void;
```

  * default `(config) => config`
  * available since v1.3.0


A function that allows you to edit the generated `tsconfig.json`. You can mutate the config (recommended) or return a new one. This is useful for extending a shared `tsconfig.json` in a monorepo root, for example.
##  version
Client-side navigation can be buggy if you deploy a new version of your app while people are using it. If the code for the new page is already loaded, it may have stale content; if it isn’t, the app’s route manifest may point to a JavaScript file that no longer exists. SvelteKit helps you solve this problem through version management. If SvelteKit encounters an error while loading the page and detects that a new version has been deployed (using the `name` specified here, which defaults to a timestamp of the build) it will fall back to traditional full-page navigation. Not all navigations will result in an error though, for example if the JavaScript for the next page is already loaded. If you still want to force a full-page navigation in these cases, use techniques such as setting the `pollInterval` and then using `beforeNavigate`:
+layout
```
<script>
	import { beforeNavigate } from '$app/navigation';
	import { updated } from '$app/state';

	beforeNavigate(({ willUnload, to }) => {
		if (updated.current && !willUnload && to?.url) {
			location.href = to.url.href;
		}
	});
</script>
```

If you set `pollInterval` to a non-zero value, SvelteKit will poll for new versions in the background and set the value of `updated.current` `true` when it detects one.
```
const name: void
@deprecated
name?: string;
```

The current app version string. If specified, this must be deterministic (e.g. a commit ref rather than `Math.random()` or `Date.now().toString()`), otherwise defaults to a timestamp of the build.
For example, to use the current commit hash, you could do use `git rev-parse HEAD`:
svelte.config
```
import * as module "node:child_process"child_process from 'node:child_process';

export default {
	```
kit: {
    version: {
        name: string;
    };
}
```
`kit: { ````
version: {
    name: string;
}
```
`version: { `name: string`name: `module "node:child_process"`child_process.`function execSync(command: string): Buffer (+3 overloads)`
The `child_process.execSync()` method is generally identical to {@link exec } with the exception that the method will not return until the child process has fully closed. When a timeout has been encountered and `killSignal` is sent, the method won’t return until the process has completely exited. If the child process intercepts and handles the `SIGTERM` signal and doesn’t exit, the parent process will wait until the child process has exited.
If the process times out or has a non-zero exit code, this method will throw. The `Error` object will contain the entire result from {@link spawnSync } .
**Never pass unsanitized user input to this function. Any input containing shell** **metacharacters may be used to trigger arbitrary command execution.**
@sincev0.11.12
@paramcommand The command to run.
@returnThe stdout from the command.
execSync('git rev-parse HEAD').`Buffer.toString(encoding?: BufferEncoding, start?: number, end?: number): string`
Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.
If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8, then each invalid byte is replaced with the replacement character `U+FFFD`.
The maximum length of a string instance (in UTF-16 code units) is available as {@link constants.MAX_STRING_LENGTH } .
```
import { Buffer } from 'node:buffer';

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &#x3C; 26; i++) {
  // 97 is the decimal ASCII value for 'a'.
  buf1[i] = i + 97;
}

console.log(buf1.toString('utf8'));
// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString('utf8', 0, 5));
// Prints: abcde

const buf2 = Buffer.from('tést');

console.log(buf2.toString('hex'));
// Prints: 74c3a97374
console.log(buf2.toString('utf8', 0, 3));
// Prints: té
console.log(buf2.toString(undefined, 0, 3));
// Prints: té
```

@sincev0.1.90
@paramencoding The character encoding to use.
@paramstart The byte offset to start decoding at.
@paramend The byte offset to stop decoding at (not inclusive).
toString().`String.trim(): string`
Removes the leading and trailing white space and line terminator characters from a string.
trim() } } };`
```

```
pollInterval?: number;
```

  * default `0`


The interval in milliseconds to poll for version changes. If this is `0`, no polling occurs.


---

This migration guide provides an overview of how to migrate from Svelte version 3 to 4. See the linked PRs for more details about each change. Use the migration script to migrate some of these automatically: `npx svelte-migrate@latest svelte-4`
If you’re a library author, consider whether to only support Svelte 4 or if it’s possible to support Svelte 3 too. Since most of the breaking changes don’t affect many people, this may be easily possible. Also remember to update the version range in your `peerDependencies`.
##  Minimum version requirements
  * Upgrade to Node 16 or higher. Earlier versions are no longer supported. (#8566)
  * If you are using SvelteKit, upgrade to 1.20.4 or newer (sveltejs/kit#10172)
  * If you are using Vite without SvelteKit, upgrade to `vite-plugin-svelte` 2.4.1 or newer (#8516)
  * If you are using webpack, upgrade to webpack 5 or higher and `svelte-loader` 3.1.8 or higher. Earlier versions are no longer supported. (#8515, 198dbcf)
  * If you are using Rollup, upgrade to `rollup-plugin-svelte` 7.1.5 or higher (198dbcf)
  * If you are using TypeScript, upgrade to TypeScript 5 or higher. Lower versions might still work, but no guarantees are made about that. (#8488)


##  Browser conditions for bundlers
Bundlers must now specify the `browser` condition when building a frontend bundle for the browser. SvelteKit and Vite will handle this automatically for you. If you’re using any others, you may observe lifecycle callbacks such as `onMount` not get called and you’ll need to update the module resolution configuration.
  * For Rollup this is done within the `@rollup/plugin-node-resolve` plugin by setting `browser: true` in its options. See the `rollup-plugin-svelte` documentation for more details
  * For webpack this is done by adding `"browser"` to the `conditionNames` array. You may also have to update your `alias` config, if you have set it. See the `svelte-loader` documentation for more details


(#8516)
##  Removal of CJS related output
Svelte no longer supports the CommonJS (CJS) format for compiler output and has also removed the `svelte/register` hook and the CJS runtime version. If you need to stay on the CJS output format, consider using a bundler to convert Svelte’s ESM output to CJS in a post-build step. (#8613)
##  Stricter types for Svelte functions
There are now stricter types for `createEventDispatcher`, `Action`, `ActionReturn`, and `onMount`:
  * `createEventDispatcher` now supports specifying that a payload is optional, required, or non-existent, and the call sites are checked accordingly (#7224)


```
import { function createEventDispatcher<EventMap extends Record<string, any> = any>(): EventDispatcher<EventMap>


Creates an event dispatcher that can be used to dispatch component events.
Event dispatchers are functions that can take two arguments: name and detail.


Component events created with createEventDispatcher create a
CustomEvent.
These events do not bubble.
The detail argument corresponds to the CustomEvent.detail
property and can contain any type of data.


The event dispatcher can be typed to narrow the allowed event names and the type of the detail argument:





```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher } from 'svelte'; const ````
const dispatch: EventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>
```
`dispatch = ````
createEventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>(): EventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>
```
`
Creates an event dispatcher that can be used to dispatch component events. Event dispatchers are functions that can take two arguments: `name` and `detail`.
Component events created with `createEventDispatcher` create a CustomEvent. These events do not bubble. The `detail` argument corresponds to the CustomEvent.detail property and can contain any type of data.
The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher<{ `optional: number | null`optional: number | null; `required: string`required: string; `noArgument: null`noArgument: null; }>(); // Svelte version 3: ````
const dispatch: EventDispatcher
<"optional">(type: "optional", parameter?: number | null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('optional'); ````
const dispatch: EventDispatcher
<"required">(type: "required", parameter: string, options?: DispatchOptions | undefined) => boolean
```
`dispatch('required'); // I can still omit the detail argument ````
const dispatch: EventDispatcher
<"noArgument">(type: "noArgument", parameter?: null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('noArgument', 'surprise'); // I can still add a detail argument // Svelte version 4 using TypeScript strict mode: ````
const dispatch: EventDispatcher
<"optional">(type: "optional", parameter?: number | null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('optional'); ````
const dispatch: EventDispatcher
<"required">(type: "required", parameter: string, options?: DispatchOptions | undefined) => boolean
```
`dispatch('required'); // error, missing argument ````
const dispatch: EventDispatcher
<"noArgument">(type: "noArgument", parameter?: null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('noArgument', 'surprise'); // error, cannot pass an argument`
```

  * `Action` and `ActionReturn` have a default parameter type of `undefined` now, which means you need to type the generic if you want to specify that this action receives a parameter. The migration script will migrate this automatically (#7442)


```
const action: Action = (node, params) => { ... } // this is now an error if you use params in any way
const const action: Action<HTMLElement, string>action: type Action = /*unresolved*/ anyAction<HTMLElement, string> = (node: anynode, params: anyparams) => { ... } // params is of type string
```

  * `onMount` now shows a type error if you return a function asynchronously from it, because this is likely a bug in your code where you expect the callback to be called on destroy, which it will only do for synchronously returned functions (#8136)


```
// Example where this change reveals an actual bug
onMount(
	// someCleanup() not called because function handed to onMount is async
	async () => {
		const something = await foo();
           	// someCleanup() is called because function handed to onMount is sync
	() => {
		foo().then(something: anysomething => {...});
		// ...
		return () => someCleanup();
	}
);
```

##  Custom Elements with Svelte
The creation of custom elements with Svelte has been overhauled and significantly improved. The `tag` option is deprecated in favor of the new `customElement` option:
```
<svelte:options tag="my-component" />
<svelte:options customElement="my-component" />
```

This change was made to allow more configurability for advanced use cases. The migration script will adjust your code automatically. The update timing of properties has changed slightly as well. (#8457)
##  SvelteComponentTyped is deprecated
`SvelteComponentTyped` is deprecated, as `SvelteComponent` now has all its typing capabilities. Replace all instances of `SvelteComponentTyped` with `SvelteComponent`.
```
import { SvelteComponentTyped } from 'svelte';
import { class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.



SvelteComponent } from 'svelte';

export class Foo extends SvelteComponentTyped<{ aProp: string }> {}
export class class FooFoo extends class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.



SvelteComponent<{ aProp: stringaProp: string }> {}
```

If you have used `SvelteComponent` as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing `: typeof SvelteComponent` to `: typeof SvelteComponent<any>`.
```
<script>
	import ComponentA from './ComponentA.svelte';
	import ComponentB from './ComponentB.svelte';
	import { SvelteComponent } from 'svelte';

	let component: typeof SvelteComponent<any>;

	function choseRandomly() {
		component = Math.random() > 0.5 ? ComponentA : ComponentB;
	}
</script>

<button on:click={choseRandomly}>random</button>
<svelte:element this={component} />
```

The migration script will do both automatically for you. (#8512)
##  Transitions are local by default
Transitions are now local by default to prevent confusion around page navigations. “local” means that a transition will not play if it’s within a nested control flow block (`each/if/await/key`) and not the direct parent block but a block above it is created/destroyed. In the following example, the `slide` intro animation will only play when `success` goes from `false` to `true`, but it will _not_ play when `show` goes from `false` to `true`:
```
{#if show}
	...
	{#if success}
		<p in:slide>Success</p>
	{/each}
{/if}
```

To make transitions global, add the `|global` modifier - then they will play when _any_ control flow block above is created/destroyed. The migration script will do this automatically for you. (#6686)
##  Default slot bindings
Default slot bindings are no longer exposed to named slots and vice versa:
```
<script>
	import Nested from './Nested.svelte';
</script>

<Nested let:count>
	<p>
		count in default slot - is available: {count}
	</p>
	<p slot="bar">
		count in bar slot - is not available: {count}
	</p>
</Nested>
```

This makes slot bindings more consistent as the behavior is undefined when for example the default slot is from a list and the named slot is not. (#6049)
##  Preprocessors
The order in which preprocessors are applied has changed. Now, preprocessors are executed in order, and within one group, the order is markup, script, style.
```
import { ```
function preprocess(source: string, preprocessor: PreprocessorGroup | PreprocessorGroup[], options?: {
    filename?: string;
} | undefined): Promise<Processed>
```
`
The preprocess function provides convenient hooks for arbitrarily transforming component source code. For example, it can be used to convert a `&#x3C;style lang="sass">` block into vanilla CSS.
preprocess } from 'svelte/compiler'; const { `const code: string`
The new code
code } = await ````
function preprocess(source: string, preprocessor: PreprocessorGroup | PreprocessorGroup[], options?: {
    filename?: string;
} | undefined): Promise<Processed>
```
`
The preprocess function provides convenient hooks for arbitrarily transforming component source code. For example, it can be used to convert a `&#x3C;style lang="sass">` block into vanilla CSS.
preprocess( source, [ { `PreprocessorGroup.markup?: MarkupPreprocessor | undefined`markup: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('markup-1'); }, `PreprocessorGroup.script?: Preprocessor | undefined`script: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('script-1'); }, `PreprocessorGroup.style?: Preprocessor | undefined`style: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('style-1'); } }, { `PreprocessorGroup.markup?: MarkupPreprocessor | undefined`markup: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('markup-2'); }, `PreprocessorGroup.script?: Preprocessor | undefined`script: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('script-2'); }, `PreprocessorGroup.style?: Preprocessor | undefined`style: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('style-2'); } } ], { `filename?: string | undefined`filename: 'App.svelte' } ); // Svelte 3 logs: // markup-1 // markup-2 // script-1 // script-2 // style-1 // style-2 // Svelte 4 logs: // markup-1 // script-1 // style-1 // markup-2 // script-2 // style-2`
```

This could affect you for example if you are using `MDsveX` - in which case you should make sure it comes before any script or style preprocessor.
```
preprocess: [
	vitePreprocess(),
	mdsvex(mdsvexConfig)
	mdsvex(mdsvexConfig),
	vitePreprocess()
]
```

Each preprocessor must also have a name. (#8618)
##  New eslint package
`eslint-plugin-svelte3` is deprecated. It may still work with Svelte 4 but we make no guarantees about that. We recommend switching to our new package eslint-plugin-svelte. See this Github post for an instruction how to migrate. Alternatively, you can create a new project using `npm create svelte@latest`, select the eslint (and possibly TypeScript) option and then copy over the related files into your existing project.
##  Other breaking changes
  * the `inert` attribute is now applied to outroing elements to make them invisible to assistive technology and prevent interaction. (#8628)
  * the runtime now uses `classList.toggle(name, boolean)` which may not work in very old browsers. Consider using a polyfill if you need to support these browsers. (#8629)
  * the runtime now uses the `CustomEvent` constructor which may not work in very old browsers. Consider using a polyfill if you need to support these browsers. (#8775)
  * people implementing their own stores from scratch using the `StartStopNotifier` interface (which is passed to the create function of `writable` etc) from `svelte/store` now need to pass an update function in addition to the set function. This has no effect on people using stores or creating stores using the existing Svelte stores. (#6750)
  * `derived` will now throw an error on falsy values instead of stores passed to it. (#7947)
  * type definitions for `svelte/internal` were removed to further discourage usage of those internal methods which are not public API. Most of these will likely change for Svelte 5
  * Removal of DOM nodes is now batched which slightly changes its order, which might affect the order of events fired if you’re using a `MutationObserver` on these elements (#8763)
  * if you enhanced the global typings through the `svelte.JSX` namespace before, you need to migrate this to use the `svelteHTML` namespace. Similarly if you used the `svelte.JSX` namespace to use type definitions from it, you need to migrate those to use the types from `svelte/elements` instead. You can find more information about what to do here


Edit this page on GitHub llms.txt
previous next
Custom elements Svelte 5 migration guide
This migration guide provides an overview of how to migrate from Svelte version 3 to 4. See the linked PRs for more details about each change. Use the migration script to migrate some of these automatically: `npx svelte-migrate@latest svelte-4`
If you’re a library author, consider whether to only support Svelte 4 or if it’s possible to support Svelte 3 too. Since most of the breaking changes don’t affect many people, this may be easily possible. Also remember to update the version range in your `peerDependencies`.
##  Minimum version requirements
  * Upgrade to Node 16 or higher. Earlier versions are no longer supported. (#8566)
  * If you are using SvelteKit, upgrade to 1.20.4 or newer (sveltejs/kit#10172)
  * If you are using Vite without SvelteKit, upgrade to `vite-plugin-svelte` 2.4.1 or newer (#8516)
  * If you are using webpack, upgrade to webpack 5 or higher and `svelte-loader` 3.1.8 or higher. Earlier versions are no longer supported. (#8515, 198dbcf)
  * If you are using Rollup, upgrade to `rollup-plugin-svelte` 7.1.5 or higher (198dbcf)
  * If you are using TypeScript, upgrade to TypeScript 5 or higher. Lower versions might still work, but no guarantees are made about that. (#8488)


##  Browser conditions for bundlers
Bundlers must now specify the `browser` condition when building a frontend bundle for the browser. SvelteKit and Vite will handle this automatically for you. If you’re using any others, you may observe lifecycle callbacks such as `onMount` not get called and you’ll need to update the module resolution configuration.
  * For Rollup this is done within the `@rollup/plugin-node-resolve` plugin by setting `browser: true` in its options. See the `rollup-plugin-svelte` documentation for more details
  * For webpack this is done by adding `"browser"` to the `conditionNames` array. You may also have to update your `alias` config, if you have set it. See the `svelte-loader` documentation for more details


(#8516)
##  Removal of CJS related output
Svelte no longer supports the CommonJS (CJS) format for compiler output and has also removed the `svelte/register` hook and the CJS runtime version. If you need to stay on the CJS output format, consider using a bundler to convert Svelte’s ESM output to CJS in a post-build step. (#8613)
##  Stricter types for Svelte functions
There are now stricter types for `createEventDispatcher`, `Action`, `ActionReturn`, and `onMount`:
  * `createEventDispatcher` now supports specifying that a payload is optional, required, or non-existent, and the call sites are checked accordingly (#7224)


```
import { function createEventDispatcher<EventMap extends Record<string, any> = any>(): EventDispatcher<EventMap>


Creates an event dispatcher that can be used to dispatch component events.
Event dispatchers are functions that can take two arguments: name and detail.


Component events created with createEventDispatcher create a
CustomEvent.
These events do not bubble.
The detail argument corresponds to the CustomEvent.detail
property and can contain any type of data.


The event dispatcher can be typed to narrow the allowed event names and the type of the detail argument:





```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher } from 'svelte'; const ````
const dispatch: EventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>
```
`dispatch = ````
createEventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>(): EventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>
```
`
Creates an event dispatcher that can be used to dispatch component events. Event dispatchers are functions that can take two arguments: `name` and `detail`.
Component events created with `createEventDispatcher` create a CustomEvent. These events do not bubble. The `detail` argument corresponds to the CustomEvent.detail property and can contain any type of data.
The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher<{ `optional: number | null`optional: number | null; `required: string`required: string; `noArgument: null`noArgument: null; }>(); // Svelte version 3: ````
const dispatch: EventDispatcher
<"optional">(type: "optional", parameter?: number | null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('optional'); ````
const dispatch: EventDispatcher
<"required">(type: "required", parameter: string, options?: DispatchOptions | undefined) => boolean
```
`dispatch('required'); // I can still omit the detail argument ````
const dispatch: EventDispatcher
<"noArgument">(type: "noArgument", parameter?: null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('noArgument', 'surprise'); // I can still add a detail argument // Svelte version 4 using TypeScript strict mode: ````
const dispatch: EventDispatcher
<"optional">(type: "optional", parameter?: number | null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('optional'); ````
const dispatch: EventDispatcher
<"required">(type: "required", parameter: string, options?: DispatchOptions | undefined) => boolean
```
`dispatch('required'); // error, missing argument ````
const dispatch: EventDispatcher
<"noArgument">(type: "noArgument", parameter?: null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('noArgument', 'surprise'); // error, cannot pass an argument`
```

  * `Action` and `ActionReturn` have a default parameter type of `undefined` now, which means you need to type the generic if you want to specify that this action receives a parameter. The migration script will migrate this automatically (#7442)


```
const action: Action = (node, params) => { ... } // this is now an error if you use params in any way
const const action: Action<HTMLElement, string>action: type Action = /*unresolved*/ anyAction<HTMLElement, string> = (node: anynode, params: anyparams) => { ... } // params is of type string
```

  * `onMount` now shows a type error if you return a function asynchronously from it, because this is likely a bug in your code where you expect the callback to be called on destroy, which it will only do for synchronously returned functions (#8136)


```
// Example where this change reveals an actual bug
onMount(
	// someCleanup() not called because function handed to onMount is async
	async () => {
		const something = await foo();
           	// someCleanup() is called because function handed to onMount is sync
	() => {
		foo().then(something: anysomething => {...});
		// ...
		return () => someCleanup();
	}
);
```

##  Custom Elements with Svelte
The creation of custom elements with Svelte has been overhauled and significantly improved. The `tag` option is deprecated in favor of the new `customElement` option:
```
<svelte:options tag="my-component" />
<svelte:options customElement="my-component" />
```

This change was made to allow more configurability for advanced use cases. The migration script will adjust your code automatically. The update timing of properties has changed slightly as well. (#8457)
##  SvelteComponentTyped is deprecated
`SvelteComponentTyped` is deprecated, as `SvelteComponent` now has all its typing capabilities. Replace all instances of `SvelteComponentTyped` with `SvelteComponent`.
```
import { SvelteComponentTyped } from 'svelte';
import { class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.



SvelteComponent } from 'svelte';

export class Foo extends SvelteComponentTyped<{ aProp: string }> {}
export class class FooFoo extends class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.



SvelteComponent<{ aProp: stringaProp: string }> {}
```

If you have used `SvelteComponent` as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing `: typeof SvelteComponent` to `: typeof SvelteComponent<any>`.
```
<script>
	import ComponentA from './ComponentA.svelte';
	import ComponentB from './ComponentB.svelte';
	import { SvelteComponent } from 'svelte';

	let component: typeof SvelteComponent<any>;

	function choseRandomly() {
		component = Math.random() > 0.5 ? ComponentA : ComponentB;
	}
</script>

<button on:click={choseRandomly}>random</button>
<svelte:element this={component} />
```

The migration script will do both automatically for you. (#8512)
##  Transitions are local by default
Transitions are now local by default to prevent confusion around page navigations. “local” means that a transition will not play if it’s within a nested control flow block (`each/if/await/key`) and not the direct parent block but a block above it is created/destroyed. In the following example, the `slide` intro animation will only play when `success` goes from `false` to `true`, but it will _not_ play when `show` goes from `false` to `true`:
```
{#if show}
	...
	{#if success}
		<p in:slide>Success</p>
	{/each}
{/if}
```

To make transitions global, add the `|global` modifier - then they will play when _any_ control flow block above is created/destroyed. The migration script will do this automatically for you. (#6686)
##  Default slot bindings
Default slot bindings are no longer exposed to named slots and vice versa:
```
<script>
	import Nested from './Nested.svelte';
</script>

<Nested let:count>
	<p>
		count in default slot - is available: {count}
	</p>
	<p slot="bar">
		count in bar slot - is not available: {count}
	</p>
</Nested>
```

This makes slot bindings more consistent as the behavior is undefined when for example the default slot is from a list and the named slot is not. (#6049)
##  Preprocessors
The order in which preprocessors are applied has changed. Now, preprocessors are executed in order, and within one group, the order is markup, script, style.
```
import { ```
function preprocess(source: string, preprocessor: PreprocessorGroup | PreprocessorGroup[], options?: {
    filename?: string;
} | undefined): Promise<Processed>
```
`
The preprocess function provides convenient hooks for arbitrarily transforming component source code. For example, it can be used to convert a `&#x3C;style lang="sass">` block into vanilla CSS.
preprocess } from 'svelte/compiler'; const { `const code: string`
The new code
code } = await ````
function preprocess(source: string, preprocessor: PreprocessorGroup | PreprocessorGroup[], options?: {
    filename?: string;
} | undefined): Promise<Processed>
```
`
The preprocess function provides convenient hooks for arbitrarily transforming component source code. For example, it can be used to convert a `&#x3C;style lang="sass">` block into vanilla CSS.
preprocess( source, [ { `PreprocessorGroup.markup?: MarkupPreprocessor | undefined`markup: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('markup-1'); }, `PreprocessorGroup.script?: Preprocessor | undefined`script: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('script-1'); }, `PreprocessorGroup.style?: Preprocessor | undefined`style: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('style-1'); } }, { `PreprocessorGroup.markup?: MarkupPreprocessor | undefined`markup: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('markup-2'); }, `PreprocessorGroup.script?: Preprocessor | undefined`script: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('script-2'); }, `PreprocessorGroup.style?: Preprocessor | undefined`style: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('style-2'); } } ], { `filename?: string | undefined`filename: 'App.svelte' } ); // Svelte 3 logs: // markup-1 // markup-2 // script-1 // script-2 // style-1 // style-2 // Svelte 4 logs: // markup-1 // script-1 // style-1 // markup-2 // script-2 // style-2`
```

This could affect you for example if you are using `MDsveX` - in which case you should make sure it comes before any script or style preprocessor.
```
preprocess: [
	vitePreprocess(),
	mdsvex(mdsvexConfig)
	mdsvex(mdsvexConfig),
	vitePreprocess()
]
```

Each preprocessor must also have a name. (#8618)
##  New eslint package
`eslint-plugin-svelte3` is deprecated. It may still work with Svelte 4 but we make no guarantees about that. We recommend switching to our new package eslint-plugin-svelte. See this Github post for an instruction how to migrate. Alternatively, you can create a new project using `npm create svelte@latest`, select the eslint (and possibly TypeScript) option and then copy over the related files into your existing project.
##  Other breaking changes
  * the `inert` attribute is now applied to outroing elements to make them invisible to assistive technology and prevent interaction. (#8628)
  * the runtime now uses `classList.toggle(name, boolean)` which may not work in very old browsers. Consider using a polyfill if you need to support these browsers. (#8629)
  * the runtime now uses the `CustomEvent` constructor which may not work in very old browsers. Consider using a polyfill if you need to support these browsers. (#8775)
  * people implementing their own stores from scratch using the `StartStopNotifier` interface (which is passed to the create function of `writable` etc) from `svelte/store` now need to pass an update function in addition to the set function. This has no effect on people using stores or creating stores using the existing Svelte stores. (#6750)
  * `derived` will now throw an error on falsy values instead of stores passed to it. (#7947)
  * type definitions for `svelte/internal` were removed to further discourage usage of those internal methods which are not public API. Most of these will likely change for Svelte 5
  * Removal of DOM nodes is now batched which slightly changes its order, which might affect the order of events fired if you’re using a `MutationObserver` on these elements (#8763)
  * if you enhanced the global typings through the `svelte.JSX` namespace before, you need to migrate this to use the `svelteHTML` namespace. Similarly if you used the `svelte.JSX` namespace to use type definitions from it, you need to migrate those to use the types from `svelte/elements` instead. You can find more information about what to do here


Edit this page on GitHub llms.txt
previous next
Custom elements Svelte 5 migration guide
This migration guide provides an overview of how to migrate from Svelte version 3 to 4. See the linked PRs for more details about each change. Use the migration script to migrate some of these automatically: `npx svelte-migrate@latest svelte-4`
If you’re a library author, consider whether to only support Svelte 4 or if it’s possible to support Svelte 3 too. Since most of the breaking changes don’t affect many people, this may be easily possible. Also remember to update the version range in your `peerDependencies`.
##  Minimum version requirements
  * Upgrade to Node 16 or higher. Earlier versions are no longer supported. (#8566)
  * If you are using SvelteKit, upgrade to 1.20.4 or newer (sveltejs/kit#10172)
  * If you are using Vite without SvelteKit, upgrade to `vite-plugin-svelte` 2.4.1 or newer (#8516)
  * If you are using webpack, upgrade to webpack 5 or higher and `svelte-loader` 3.1.8 or higher. Earlier versions are no longer supported. (#8515, 198dbcf)
  * If you are using Rollup, upgrade to `rollup-plugin-svelte` 7.1.5 or higher (198dbcf)
  * If you are using TypeScript, upgrade to TypeScript 5 or higher. Lower versions might still work, but no guarantees are made about that. (#8488)


##  Browser conditions for bundlers
Bundlers must now specify the `browser` condition when building a frontend bundle for the browser. SvelteKit and Vite will handle this automatically for you. If you’re using any others, you may observe lifecycle callbacks such as `onMount` not get called and you’ll need to update the module resolution configuration.
  * For Rollup this is done within the `@rollup/plugin-node-resolve` plugin by setting `browser: true` in its options. See the `rollup-plugin-svelte` documentation for more details
  * For webpack this is done by adding `"browser"` to the `conditionNames` array. You may also have to update your `alias` config, if you have set it. See the `svelte-loader` documentation for more details


(#8516)
##  Removal of CJS related output
Svelte no longer supports the CommonJS (CJS) format for compiler output and has also removed the `svelte/register` hook and the CJS runtime version. If you need to stay on the CJS output format, consider using a bundler to convert Svelte’s ESM output to CJS in a post-build step. (#8613)
##  Stricter types for Svelte functions
There are now stricter types for `createEventDispatcher`, `Action`, `ActionReturn`, and `onMount`:
  * `createEventDispatcher` now supports specifying that a payload is optional, required, or non-existent, and the call sites are checked accordingly (#7224)


```
import { function createEventDispatcher<EventMap extends Record<string, any> = any>(): EventDispatcher<EventMap>


Creates an event dispatcher that can be used to dispatch component events.
Event dispatchers are functions that can take two arguments: name and detail.


Component events created with createEventDispatcher create a
CustomEvent.
These events do not bubble.
The detail argument corresponds to the CustomEvent.detail
property and can contain any type of data.


The event dispatcher can be typed to narrow the allowed event names and the type of the detail argument:





```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher } from 'svelte'; const ````
const dispatch: EventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>
```
`dispatch = ````
createEventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>(): EventDispatcher<{
    optional: number | null;
    required: string;
    noArgument: null;
}>
```
`
Creates an event dispatcher that can be used to dispatch component events. Event dispatchers are functions that can take two arguments: `name` and `detail`.
Component events created with `createEventDispatcher` create a CustomEvent. These events do not bubble. The `detail` argument corresponds to the CustomEvent.detail property and can contain any type of data.
The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher<{ `optional: number | null`optional: number | null; `required: string`required: string; `noArgument: null`noArgument: null; }>(); // Svelte version 3: ````
const dispatch: EventDispatcher
<"optional">(type: "optional", parameter?: number | null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('optional'); ````
const dispatch: EventDispatcher
<"required">(type: "required", parameter: string, options?: DispatchOptions | undefined) => boolean
```
`dispatch('required'); // I can still omit the detail argument ````
const dispatch: EventDispatcher
<"noArgument">(type: "noArgument", parameter?: null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('noArgument', 'surprise'); // I can still add a detail argument // Svelte version 4 using TypeScript strict mode: ````
const dispatch: EventDispatcher
<"optional">(type: "optional", parameter?: number | null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('optional'); ````
const dispatch: EventDispatcher
<"required">(type: "required", parameter: string, options?: DispatchOptions | undefined) => boolean
```
`dispatch('required'); // error, missing argument ````
const dispatch: EventDispatcher
<"noArgument">(type: "noArgument", parameter?: null | undefined, options?: DispatchOptions | undefined) => boolean
```
`dispatch('noArgument', 'surprise'); // error, cannot pass an argument`
```

  * `Action` and `ActionReturn` have a default parameter type of `undefined` now, which means you need to type the generic if you want to specify that this action receives a parameter. The migration script will migrate this automatically (#7442)


```
const action: Action = (node, params) => { ... } // this is now an error if you use params in any way
const const action: Action<HTMLElement, string>action: type Action = /*unresolved*/ anyAction<HTMLElement, string> = (node: anynode, params: anyparams) => { ... } // params is of type string
```

  * `onMount` now shows a type error if you return a function asynchronously from it, because this is likely a bug in your code where you expect the callback to be called on destroy, which it will only do for synchronously returned functions (#8136)


```
// Example where this change reveals an actual bug
onMount(
	// someCleanup() not called because function handed to onMount is async
	async () => {
		const something = await foo();
           	// someCleanup() is called because function handed to onMount is sync
	() => {
		foo().then(something: anysomething => {...});
		// ...
		return () => someCleanup();
	}
);
```

##  Custom Elements with Svelte
The creation of custom elements with Svelte has been overhauled and significantly improved. The `tag` option is deprecated in favor of the new `customElement` option:
```
<svelte:options tag="my-component" />
<svelte:options customElement="my-component" />
```

This change was made to allow more configurability for advanced use cases. The migration script will adjust your code automatically. The update timing of properties has changed slightly as well. (#8457)
##  SvelteComponentTyped is deprecated
`SvelteComponentTyped` is deprecated, as `SvelteComponent` now has all its typing capabilities. Replace all instances of `SvelteComponentTyped` with `SvelteComponent`.
```
import { SvelteComponentTyped } from 'svelte';
import { class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.



SvelteComponent } from 'svelte';

export class Foo extends SvelteComponentTyped<{ aProp: string }> {}
export class class FooFoo extends class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.



SvelteComponent<{ aProp: stringaProp: string }> {}
```

If you have used `SvelteComponent` as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing `: typeof SvelteComponent` to `: typeof SvelteComponent<any>`.
```
<script>
	import ComponentA from './ComponentA.svelte';
	import ComponentB from './ComponentB.svelte';
	import { SvelteComponent } from 'svelte';

	let component: typeof SvelteComponent<any>;

	function choseRandomly() {
		component = Math.random() > 0.5 ? ComponentA : ComponentB;
	}
</script>

<button on:click={choseRandomly}>random</button>
<svelte:element this={component} />
```

The migration script will do both automatically for you. (#8512)
##  Transitions are local by default
Transitions are now local by default to prevent confusion around page navigations. “local” means that a transition will not play if it’s within a nested control flow block (`each/if/await/key`) and not the direct parent block but a block above it is created/destroyed. In the following example, the `slide` intro animation will only play when `success` goes from `false` to `true`, but it will _not_ play when `show` goes from `false` to `true`:
```
{#if show}
	...
	{#if success}
		<p in:slide>Success</p>
	{/each}
{/if}
```

To make transitions global, add the `|global` modifier - then they will play when _any_ control flow block above is created/destroyed. The migration script will do this automatically for you. (#6686)
##  Default slot bindings
Default slot bindings are no longer exposed to named slots and vice versa:
```
<script>
	import Nested from './Nested.svelte';
</script>

<Nested let:count>
	<p>
		count in default slot - is available: {count}
	</p>
	<p slot="bar">
		count in bar slot - is not available: {count}
	</p>
</Nested>
```

This makes slot bindings more consistent as the behavior is undefined when for example the default slot is from a list and the named slot is not. (#6049)
##  Preprocessors
The order in which preprocessors are applied has changed. Now, preprocessors are executed in order, and within one group, the order is markup, script, style.
```
import { ```
function preprocess(source: string, preprocessor: PreprocessorGroup | PreprocessorGroup[], options?: {
    filename?: string;
} | undefined): Promise<Processed>
```
`
The preprocess function provides convenient hooks for arbitrarily transforming component source code. For example, it can be used to convert a `&#x3C;style lang="sass">` block into vanilla CSS.
preprocess } from 'svelte/compiler'; const { `const code: string`
The new code
code } = await ````
function preprocess(source: string, preprocessor: PreprocessorGroup | PreprocessorGroup[], options?: {
    filename?: string;
} | undefined): Promise<Processed>
```
`
The preprocess function provides convenient hooks for arbitrarily transforming component source code. For example, it can be used to convert a `&#x3C;style lang="sass">` block into vanilla CSS.
preprocess( source, [ { `PreprocessorGroup.markup?: MarkupPreprocessor | undefined`markup: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('markup-1'); }, `PreprocessorGroup.script?: Preprocessor | undefined`script: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('script-1'); }, `PreprocessorGroup.style?: Preprocessor | undefined`style: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('style-1'); } }, { `PreprocessorGroup.markup?: MarkupPreprocessor | undefined`markup: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('markup-2'); }, `PreprocessorGroup.script?: Preprocessor | undefined`script: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('script-2'); }, `PreprocessorGroup.style?: Preprocessor | undefined`style: () => { `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log('style-2'); } } ], { `filename?: string | undefined`filename: 'App.svelte' } ); // Svelte 3 logs: // markup-1 // markup-2 // script-1 // script-2 // style-1 // style-2 // Svelte 4 logs: // markup-1 // script-1 // style-1 // markup-2 // script-2 // style-2`
```

This could affect you for example if you are using `MDsveX` - in which case you should make sure it comes before any script or style preprocessor.
```
preprocess: [
	vitePreprocess(),
	mdsvex(mdsvexConfig)
	mdsvex(mdsvexConfig),
	vitePreprocess()
]
```

Each preprocessor must also have a name. (#8618)
##  New eslint package
`eslint-plugin-svelte3` is deprecated. It may still work with Svelte 4 but we make no guarantees about that. We recommend switching to our new package eslint-plugin-svelte. See this Github post for an instruction how to migrate. Alternatively, you can create a new project using `npm create svelte@latest`, select the eslint (and possibly TypeScript) option and then copy over the related files into your existing project.
##  Other breaking changes
  * the `inert` attribute is now applied to outroing elements to make them invisible to assistive technology and prevent interaction. (#8628)
  * the runtime now uses `classList.toggle(name, boolean)` which may not work in very old browsers. Consider using a polyfill if you need to support these browsers. (#8629)
  * the runtime now uses the `CustomEvent` constructor which may not work in very old browsers. Consider using a polyfill if you need to support these browsers. (#8775)
  * people implementing their own stores from scratch using the `StartStopNotifier` interface (which is passed to the create function of `writable` etc) from `svelte/store` now need to pass an update function in addition to the set function. This has no effect on people using stores or creating stores using the existing Svelte stores. (#6750)
  * `derived` will now throw an error on falsy values instead of stores passed to it. (#7947)
  * type definitions for `svelte/internal` were removed to further discourage usage of those internal methods which are not public API. Most of these will likely change for Svelte 5
  * Removal of DOM nodes is now batched which slightly changes its order, which might affect the order of events fired if you’re using a `MutationObserver` on these elements (#8763)
  * if you enhanced the global typings through the `svelte.JSX` namespace before, you need to migrate this to use the `svelteHTML` namespace. Similarly if you used the `svelte.JSX` namespace to use type definitions from it, you need to migrate those to use the types from `svelte/elements` instead. You can find more information about what to do here




---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

SvelteKit offers configurable rendering, which allows you to build and deploy your project in several different ways. You can build all of the below types of applications and more with SvelteKit. Rendering settings are not mutually exclusive and you may choose the optimal manner with which to render different parts of your application.
If you don’t have a particular way you’d like to build your application in mind, don’t worry! The way your application is built, deployed, and rendered is controlled by which adapter you’ve chosen and a small amount of configuration and these can always be changed later. The project structure and routing will be the same regardless of the project type that you choose.
##  Default rendering
By default, when a user visits a site, SvelteKit will render the first page with server-side rendering (SSR) and subsequent pages with client-side rendering (CSR). Using SSR for the initial render improves SEO and perceived performance of the initial page load. Client-side rendering then takes over and updates the page without having to rerender common components, which is typically faster and eliminates a flash when navigating between pages. Apps built with this hybrid rendering approach have also been called transitional apps.
##  Static site generation
You can use SvelteKit as a static site generator (SSG) that fully prerenders your site with static rendering using `adapter-static`. You may also use the prerender option to prerender only some pages and then choose a different adapter with which to dynamically server-render other pages.
Tools built solely to do static site generation may scale the prerendering process more efficiently during build when rendering a very large number of pages. When working with very large statically generated sites, you can avoid long build times with Incremental Static Regeneration (ISR) if using `adapter-vercel`. And in contrast to purpose-built SSGs, SvelteKit allows for nicely mixing and matching different rendering types on different pages.
##  Single-page app
Single-page apps (SPAs) exclusively use client-side rendering (CSR). You can build single-page apps (SPAs) with SvelteKit. As with all types of SvelteKit applications, you can write your backend in SvelteKit or another language or framework. If you are building an application with no backend or a separate backend, you can simply skip over and ignore the parts of the docs talking about `server` files.
##  Multi-page app
SvelteKit isn’t typically used to build traditional multi-page apps. However, in SvelteKit you can remove all JavaScript on a page with `csr = false`, which will render subsequent links on the server, or you can use `data-sveltekit-reload` to render specific links on the server.
##  Separate backend
If your backend is written in another language such as Go, Java, PHP, Ruby, Rust, or C#, there are a couple of ways that you can deploy your application. The most recommended way would be to deploy your SvelteKit frontend separately from your backend utilizing `adapter-node` or a serverless adapter. Some users prefer not to have a separate process to manage and decide to deploy their application as a single-page app (SPA) served by their backend server, but note that single-page apps have worse SEO and performance characteristics.
If you are using an external backend, you can simply skip over and ignore the parts of the docs talking about `server` files. You may also want to reference the FAQ about how to make calls to a separate backend.
##  Serverless app
SvelteKit apps are simple to run on serverless platforms. The default zero config adapter will automatically run your app on a number of supported platforms or you can use `adapter-vercel`, `adapter-netlify`, or `adapter-cloudflare` to provide platform-specific configuration. And community adapters allow you to deploy your application to almost any serverless environment. Some of these adapters such as `adapter-vercel` and `adapter-netlify` offer an `edge` option, to support edge rendering for improved latency.
##  Your own server
You can deploy to your own server or VPS using `adapter-node`.
##  Container
You can use `adapter-node` to run a SvelteKit app within a container such as Docker or LXC.
##  Library
You can create a library to be used by other Svelte apps with the `@sveltejs/package` add-on to SvelteKit by choosing the library option when running `sv create`.
##  Offline app
SvelteKit has full suppport for service workers allowing you to build many types of applications such as offline apps and progressive web apps.
##  Mobile app
You can turn a SvelteKit SPA into a mobile app with Tauri or Capacitor. Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms.
These mobile development platforms work by starting a local web server and then serving your application like a static host on your phone. You may find `bundleStrategy: 'single'` to be a helpful option to limit the number of requests made. E.g. at the time of writing, the Capacitor local server uses HTTP/1, which limits the number of concurrent connections.
##  Desktop app
You can turn a SvelteKit SPA into a desktop app with Tauri, Wails, or Electron.
##  Browser extension
You can build browser extensions using either `adapter-static` or community adapters specifically tailored towards browser extensions.
##  Embedded device
Because of its efficient rendering, Svelte can be run on low power devices. Embedded devices like microcontrollers and TVs may limit the number of concurrent connections. In order to reduce the number of concurrent requests, you may find `bundleStrategy: 'single'` to be a helpful option in this deployment configuration.
Edit this page on GitHub llms.txt
previous next
Creating a project Project structure
SvelteKit offers configurable rendering, which allows you to build and deploy your project in several different ways. You can build all of the below types of applications and more with SvelteKit. Rendering settings are not mutually exclusive and you may choose the optimal manner with which to render different parts of your application.
If you don’t have a particular way you’d like to build your application in mind, don’t worry! The way your application is built, deployed, and rendered is controlled by which adapter you’ve chosen and a small amount of configuration and these can always be changed later. The project structure and routing will be the same regardless of the project type that you choose.
##  Default rendering
By default, when a user visits a site, SvelteKit will render the first page with server-side rendering (SSR) and subsequent pages with client-side rendering (CSR). Using SSR for the initial render improves SEO and perceived performance of the initial page load. Client-side rendering then takes over and updates the page without having to rerender common components, which is typically faster and eliminates a flash when navigating between pages. Apps built with this hybrid rendering approach have also been called transitional apps.
##  Static site generation
You can use SvelteKit as a static site generator (SSG) that fully prerenders your site with static rendering using `adapter-static`. You may also use the prerender option to prerender only some pages and then choose a different adapter with which to dynamically server-render other pages.
Tools built solely to do static site generation may scale the prerendering process more efficiently during build when rendering a very large number of pages. When working with very large statically generated sites, you can avoid long build times with Incremental Static Regeneration (ISR) if using `adapter-vercel`. And in contrast to purpose-built SSGs, SvelteKit allows for nicely mixing and matching different rendering types on different pages.
##  Single-page app
Single-page apps (SPAs) exclusively use client-side rendering (CSR). You can build single-page apps (SPAs) with SvelteKit. As with all types of SvelteKit applications, you can write your backend in SvelteKit or another language or framework. If you are building an application with no backend or a separate backend, you can simply skip over and ignore the parts of the docs talking about `server` files.
##  Multi-page app
SvelteKit isn’t typically used to build traditional multi-page apps. However, in SvelteKit you can remove all JavaScript on a page with `csr = false`, which will render subsequent links on the server, or you can use `data-sveltekit-reload` to render specific links on the server.
##  Separate backend
If your backend is written in another language such as Go, Java, PHP, Ruby, Rust, or C#, there are a couple of ways that you can deploy your application. The most recommended way would be to deploy your SvelteKit frontend separately from your backend utilizing `adapter-node` or a serverless adapter. Some users prefer not to have a separate process to manage and decide to deploy their application as a single-page app (SPA) served by their backend server, but note that single-page apps have worse SEO and performance characteristics.
If you are using an external backend, you can simply skip over and ignore the parts of the docs talking about `server` files. You may also want to reference the FAQ about how to make calls to a separate backend.
##  Serverless app
SvelteKit apps are simple to run on serverless platforms. The default zero config adapter will automatically run your app on a number of supported platforms or you can use `adapter-vercel`, `adapter-netlify`, or `adapter-cloudflare` to provide platform-specific configuration. And community adapters allow you to deploy your application to almost any serverless environment. Some of these adapters such as `adapter-vercel` and `adapter-netlify` offer an `edge` option, to support edge rendering for improved latency.
##  Your own server
You can deploy to your own server or VPS using `adapter-node`.
##  Container
You can use `adapter-node` to run a SvelteKit app within a container such as Docker or LXC.
##  Library
You can create a library to be used by other Svelte apps with the `@sveltejs/package` add-on to SvelteKit by choosing the library option when running `sv create`.
##  Offline app
SvelteKit has full suppport for service workers allowing you to build many types of applications such as offline apps and progressive web apps.
##  Mobile app
You can turn a SvelteKit SPA into a mobile app with Tauri or Capacitor. Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms.
These mobile development platforms work by starting a local web server and then serving your application like a static host on your phone. You may find `bundleStrategy: 'single'` to be a helpful option to limit the number of requests made. E.g. at the time of writing, the Capacitor local server uses HTTP/1, which limits the number of concurrent connections.
##  Desktop app
You can turn a SvelteKit SPA into a desktop app with Tauri, Wails, or Electron.
##  Browser extension
You can build browser extensions using either `adapter-static` or community adapters specifically tailored towards browser extensions.
##  Embedded device
Because of its efficient rendering, Svelte can be run on low power devices. Embedded devices like microcontrollers and TVs may limit the number of concurrent connections. In order to reduce the number of concurrent requests, you may find `bundleStrategy: 'single'` to be a helpful option in this deployment configuration.
Edit this page on GitHub llms.txt
previous next
Creating a project Project structure
SvelteKit offers configurable rendering, which allows you to build and deploy your project in several different ways. You can build all of the below types of applications and more with SvelteKit. Rendering settings are not mutually exclusive and you may choose the optimal manner with which to render different parts of your application.
If you don’t have a particular way you’d like to build your application in mind, don’t worry! The way your application is built, deployed, and rendered is controlled by which adapter you’ve chosen and a small amount of configuration and these can always be changed later. The project structure and routing will be the same regardless of the project type that you choose.
##  Default rendering
By default, when a user visits a site, SvelteKit will render the first page with server-side rendering (SSR) and subsequent pages with client-side rendering (CSR). Using SSR for the initial render improves SEO and perceived performance of the initial page load. Client-side rendering then takes over and updates the page without having to rerender common components, which is typically faster and eliminates a flash when navigating between pages. Apps built with this hybrid rendering approach have also been called transitional apps.
##  Static site generation
You can use SvelteKit as a static site generator (SSG) that fully prerenders your site with static rendering using `adapter-static`. You may also use the prerender option to prerender only some pages and then choose a different adapter with which to dynamically server-render other pages.
Tools built solely to do static site generation may scale the prerendering process more efficiently during build when rendering a very large number of pages. When working with very large statically generated sites, you can avoid long build times with Incremental Static Regeneration (ISR) if using `adapter-vercel`. And in contrast to purpose-built SSGs, SvelteKit allows for nicely mixing and matching different rendering types on different pages.
##  Single-page app
Single-page apps (SPAs) exclusively use client-side rendering (CSR). You can build single-page apps (SPAs) with SvelteKit. As with all types of SvelteKit applications, you can write your backend in SvelteKit or another language or framework. If you are building an application with no backend or a separate backend, you can simply skip over and ignore the parts of the docs talking about `server` files.
##  Multi-page app
SvelteKit isn’t typically used to build traditional multi-page apps. However, in SvelteKit you can remove all JavaScript on a page with `csr = false`, which will render subsequent links on the server, or you can use `data-sveltekit-reload` to render specific links on the server.
##  Separate backend
If your backend is written in another language such as Go, Java, PHP, Ruby, Rust, or C#, there are a couple of ways that you can deploy your application. The most recommended way would be to deploy your SvelteKit frontend separately from your backend utilizing `adapter-node` or a serverless adapter. Some users prefer not to have a separate process to manage and decide to deploy their application as a single-page app (SPA) served by their backend server, but note that single-page apps have worse SEO and performance characteristics.
If you are using an external backend, you can simply skip over and ignore the parts of the docs talking about `server` files. You may also want to reference the FAQ about how to make calls to a separate backend.
##  Serverless app
SvelteKit apps are simple to run on serverless platforms. The default zero config adapter will automatically run your app on a number of supported platforms or you can use `adapter-vercel`, `adapter-netlify`, or `adapter-cloudflare` to provide platform-specific configuration. And community adapters allow you to deploy your application to almost any serverless environment. Some of these adapters such as `adapter-vercel` and `adapter-netlify` offer an `edge` option, to support edge rendering for improved latency.
##  Your own server
You can deploy to your own server or VPS using `adapter-node`.
##  Container
You can use `adapter-node` to run a SvelteKit app within a container such as Docker or LXC.
##  Library
You can create a library to be used by other Svelte apps with the `@sveltejs/package` add-on to SvelteKit by choosing the library option when running `sv create`.
##  Offline app
SvelteKit has full suppport for service workers allowing you to build many types of applications such as offline apps and progressive web apps.
##  Mobile app
You can turn a SvelteKit SPA into a mobile app with Tauri or Capacitor. Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms.
These mobile development platforms work by starting a local web server and then serving your application like a static host on your phone. You may find `bundleStrategy: 'single'` to be a helpful option to limit the number of requests made. E.g. at the time of writing, the Capacitor local server uses HTTP/1, which limits the number of concurrent connections.
##  Desktop app
You can turn a SvelteKit SPA into a desktop app with Tauri, Wails, or Electron.
##  Browser extension
You can build browser extensions using either `adapter-static` or community adapters specifically tailored towards browser extensions.
##  Embedded device
Because of its efficient rendering, Svelte can be run on low power devices. Embedded devices like microcontrollers and TVs may limit the number of concurrent connections. In order to reduce the number of concurrent requests, you may find `bundleStrategy: 'single'` to be a helpful option in this deployment configuration.


---




---

Derived state is declared with the `$derived` rune:
```
<script>
	let count = $state(0);
	let doubled = $derived(count * 2);
</script>

<button onclick={() => count++}>
	{doubled}
</button>

<p>{count} doubled is {doubled}</p>
```

The expression inside `$derived(...)` should be free of side-effects. Svelte will disallow state changes (e.g. `count++`) inside derived expressions.
As with `$state`, you can mark class fields as `$derived`.
> Code in Svelte components is only executed once at creation. Without the `$derived` rune, `doubled` would maintain its original value even when `count` changes.
##  $derived.by
Sometimes you need to create complex derivations that don’t fit inside a short expression. In these cases, you can use `$derived.by` which accepts a function as its argument.
```
<script>
	let numbers = $state([1, 2, 3]);
	let total = $derived.by(() => {
		let total = 0;
		for (const n of numbers) {
			total += n;
		}
		return total;
	});
</script>

<button onclick={() => numbers.push(numbers.length + 1)}>
	{numbers.join(' + ')} = {total}
</button>
```

In essence, `$derived(expression)` is equivalent to `$derived.by(() => expression)`.
##  Understanding dependencies
Anything read synchronously inside the `$derived` expression (or `$derived.by` function body) is considered a _dependency_ of the derived state. When the state changes, the derived will be marked as _dirty_ and recalculated when it is next read.
To exempt a piece of state from being treated as a dependency, use `untrack`.
##  Overriding derived values
Derived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them (unless they are declared with `const`). This can be useful for things like _optimistic UI_ , where a value is derived from the ‘source of truth’ (such as data from your server) but you’d like to show immediate feedback to the user:
```
<script>
	let { post, like } = $props();

	let likes = $derived(post.likes);

	async function onclick() {
		// increment the `likes` count immediately...
		likes += 1;

		// and tell the server, which will eventually update `post`
		try {
			await like();
		} catch {
			// failed! roll back the change
			likes -= 1;
		}
	}
</script>

<button {onclick}>🧡 {likes}</button>
```

> Prior to Svelte 5.25, deriveds were read-only.
##  Deriveds and reactivity
Unlike `$state`, which converts objects and arrays to deeply reactive proxies, `$derived` values are left as-is. For example, in a case like this...
```
let items = $state([...]);

let index = $state(0);
let selected = $derived(items[index]);
```

...you can change (or `bind:` to) properties of `selected` and it will affect the underlying `items` array. If `items` was _not_ deeply reactive, mutating `selected` would have no effect.
##  Update propagation
Svelte uses something called _push-pull reactivity_ — when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the ‘push’), but derived values are not re-evaluated until they are actually read (the ‘pull’).
If the new value of a derived is referentially identical to its previous value, downstream updates will be skipped. In other words, Svelte will only update the text inside the button when `large` changes, not when `count` changes, even though `large` depends on `count`:
```
<script>
	let count = $state(0);
	let large = $derived(count > 10);
</script>

<button onclick={() => count++}>
	{large}
</button>
```

Edit this page on GitHub llms.txt
previous next
$state $effect
Derived state is declared with the `$derived` rune:
```
<script>
	let count = $state(0);
	let doubled = $derived(count * 2);
</script>

<button onclick={() => count++}>
	{doubled}
</button>

<p>{count} doubled is {doubled}</p>
```

The expression inside `$derived(...)` should be free of side-effects. Svelte will disallow state changes (e.g. `count++`) inside derived expressions.
As with `$state`, you can mark class fields as `$derived`.
> Code in Svelte components is only executed once at creation. Without the `$derived` rune, `doubled` would maintain its original value even when `count` changes.
##  $derived.by
Sometimes you need to create complex derivations that don’t fit inside a short expression. In these cases, you can use `$derived.by` which accepts a function as its argument.
```
<script>
	let numbers = $state([1, 2, 3]);
	let total = $derived.by(() => {
		let total = 0;
		for (const n of numbers) {
			total += n;
		}
		return total;
	});
</script>

<button onclick={() => numbers.push(numbers.length + 1)}>
	{numbers.join(' + ')} = {total}
</button>
```

In essence, `$derived(expression)` is equivalent to `$derived.by(() => expression)`.
##  Understanding dependencies
Anything read synchronously inside the `$derived` expression (or `$derived.by` function body) is considered a _dependency_ of the derived state. When the state changes, the derived will be marked as _dirty_ and recalculated when it is next read.
To exempt a piece of state from being treated as a dependency, use `untrack`.
##  Overriding derived values
Derived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them (unless they are declared with `const`). This can be useful for things like _optimistic UI_ , where a value is derived from the ‘source of truth’ (such as data from your server) but you’d like to show immediate feedback to the user:
```
<script>
	let { post, like } = $props();

	let likes = $derived(post.likes);

	async function onclick() {
		// increment the `likes` count immediately...
		likes += 1;

		// and tell the server, which will eventually update `post`
		try {
			await like();
		} catch {
			// failed! roll back the change
			likes -= 1;
		}
	}
</script>

<button {onclick}>🧡 {likes}</button>
```

> Prior to Svelte 5.25, deriveds were read-only.
##  Deriveds and reactivity
Unlike `$state`, which converts objects and arrays to deeply reactive proxies, `$derived` values are left as-is. For example, in a case like this...
```
let items = $state([...]);

let index = $state(0);
let selected = $derived(items[index]);
```

...you can change (or `bind:` to) properties of `selected` and it will affect the underlying `items` array. If `items` was _not_ deeply reactive, mutating `selected` would have no effect.
##  Update propagation
Svelte uses something called _push-pull reactivity_ — when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the ‘push’), but derived values are not re-evaluated until they are actually read (the ‘pull’).
If the new value of a derived is referentially identical to its previous value, downstream updates will be skipped. In other words, Svelte will only update the text inside the button when `large` changes, not when `count` changes, even though `large` depends on `count`:
```
<script>
	let count = $state(0);
	let large = $derived(count > 10);
</script>

<button onclick={() => count++}>
	{large}
</button>
```

Edit this page on GitHub llms.txt
previous next
$state $effect
Derived state is declared with the `$derived` rune:
```
<script>
	let count = $state(0);
	let doubled = $derived(count * 2);
</script>

<button onclick={() => count++}>
	{doubled}
</button>

<p>{count} doubled is {doubled}</p>
```

The expression inside `$derived(...)` should be free of side-effects. Svelte will disallow state changes (e.g. `count++`) inside derived expressions.
As with `$state`, you can mark class fields as `$derived`.
> Code in Svelte components is only executed once at creation. Without the `$derived` rune, `doubled` would maintain its original value even when `count` changes.
##  $derived.by
Sometimes you need to create complex derivations that don’t fit inside a short expression. In these cases, you can use `$derived.by` which accepts a function as its argument.
```
<script>
	let numbers = $state([1, 2, 3]);
	let total = $derived.by(() => {
		let total = 0;
		for (const n of numbers) {
			total += n;
		}
		return total;
	});
</script>

<button onclick={() => numbers.push(numbers.length + 1)}>
	{numbers.join(' + ')} = {total}
</button>
```

In essence, `$derived(expression)` is equivalent to `$derived.by(() => expression)`.
##  Understanding dependencies
Anything read synchronously inside the `$derived` expression (or `$derived.by` function body) is considered a _dependency_ of the derived state. When the state changes, the derived will be marked as _dirty_ and recalculated when it is next read.
To exempt a piece of state from being treated as a dependency, use `untrack`.
##  Overriding derived values
Derived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them (unless they are declared with `const`). This can be useful for things like _optimistic UI_ , where a value is derived from the ‘source of truth’ (such as data from your server) but you’d like to show immediate feedback to the user:
```
<script>
	let { post, like } = $props();

	let likes = $derived(post.likes);

	async function onclick() {
		// increment the `likes` count immediately...
		likes += 1;

		// and tell the server, which will eventually update `post`
		try {
			await like();
		} catch {
			// failed! roll back the change
			likes -= 1;
		}
	}
</script>

<button {onclick}>🧡 {likes}</button>
```

> Prior to Svelte 5.25, deriveds were read-only.
##  Deriveds and reactivity
Unlike `$state`, which converts objects and arrays to deeply reactive proxies, `$derived` values are left as-is. For example, in a case like this...
```
let items = $state([...]);

let index = $state(0);
let selected = $derived(items[index]);
```

...you can change (or `bind:` to) properties of `selected` and it will affect the underlying `items` array. If `items` was _not_ deeply reactive, mutating `selected` would have no effect.
##  Update propagation
Svelte uses something called _push-pull reactivity_ — when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the ‘push’), but derived values are not re-evaluated until they are actually read (the ‘pull’).
If the new value of a derived is referentially identical to its previous value, downstream updates will be skipped. In other words, Svelte will only update the text inside the button when `large` changes, not when `count` changes, even though `large` depends on `count`:
```
<script>
	let count = $state(0);
	let large = $derived(count > 10);
</script>

<button onclick={() => count++}>
	{large}
</button>
```



---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

To inject raw HTML into your component, use the `{@html ...}` tag:
```
<article>
	{@html content}
</article>
```

> Make sure that you either escape the passed string or only populate it with values that are under your control in order to prevent XSS attacks. Never render unsanitized content.
The expression should be valid standalone HTML — this will not work, because `</div>` is not valid HTML:
```
{@html '<div>'}content{@html '</div>'}
```

It also will not compile Svelte code.
##  Styling
Content rendered this way is ‘invisible’ to Svelte and as such will not receive scoped styles — in other words, this will not work, and the `a` and `img` styles will be regarded as unused:
```
<article>
	{@html content}
</article>

<style>
	article {
		a { color: hotpink }
		img { width: 100% }
	}
</style>
```

Instead, use the `:global` modifier to target everything inside the `<article>`:
```
<style>
	article :global {
		a { color: hotpink }
		img { width: 100% }
	}
</style>
```

Edit this page on GitHub llms.txt
previous next
{@render ...} {@attach ...}
To inject raw HTML into your component, use the `{@html ...}` tag:
```
<article>
	{@html content}
</article>
```

> Make sure that you either escape the passed string or only populate it with values that are under your control in order to prevent XSS attacks. Never render unsanitized content.
The expression should be valid standalone HTML — this will not work, because `</div>` is not valid HTML:
```
{@html '<div>'}content{@html '</div>'}
```

It also will not compile Svelte code.
##  Styling
Content rendered this way is ‘invisible’ to Svelte and as such will not receive scoped styles — in other words, this will not work, and the `a` and `img` styles will be regarded as unused:
```
<article>
	{@html content}
</article>

<style>
	article {
		a { color: hotpink }
		img { width: 100% }
	}
</style>
```

Instead, use the `:global` modifier to target everything inside the `<article>`:
```
<style>
	article :global {
		a { color: hotpink }
		img { width: 100% }
	}
</style>
```

Edit this page on GitHub llms.txt
previous next
{@render ...} {@attach ...}
To inject raw HTML into your component, use the `{@html ...}` tag:
```
<article>
	{@html content}
</article>
```

> Make sure that you either escape the passed string or only populate it with values that are under your control in order to prevent XSS attacks. Never render unsanitized content.
The expression should be valid standalone HTML — this will not work, because `</div>` is not valid HTML:
```
{@html '<div>'}content{@html '</div>'}
```

It also will not compile Svelte code.
##  Styling
Content rendered this way is ‘invisible’ to Svelte and as such will not receive scoped styles — in other words, this will not work, and the `a` and `img` styles will be regarded as unused:
```
<article>
	{@html content}
</article>

<style>
	article {
		a { color: hotpink }
		img { width: 100% }
	}
</style>
```

Instead, use the `:global` modifier to target everything inside the `<article>`:
```
<style>
	article :global {
		a { color: hotpink }
		img { width: 100% }
	}
</style>
```



---

The `in:` and `out:` directives are identical to `transition:`, except that the resulting transitions are not bidirectional — an `in` transition will continue to ‘play’ alongside the `out` transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.
```
<script>
  import { fade, fly } from 'svelte/transition';
  
  let visible = $state(false);
</script>

<label>
  <input type="checkbox" bind:checked={visible}>
  visible
</label>

{#if visible}
	<div in:fly={{ y: 200 }} out:fade>flies in, fades out</div>
{/if}
```

Edit this page on GitHub llms.txt
previous next
transition: animate:
The `in:` and `out:` directives are identical to `transition:`, except that the resulting transitions are not bidirectional — an `in` transition will continue to ‘play’ alongside the `out` transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.
```
<script>
  import { fade, fly } from 'svelte/transition';
  
  let visible = $state(false);
</script>

<label>
  <input type="checkbox" bind:checked={visible}>
  visible
</label>

{#if visible}
	<div in:fly={{ y: 200 }} out:fade>flies in, fades out</div>
{/if}
```

Edit this page on GitHub llms.txt
previous next
transition: animate:
The `in:` and `out:` directives are identical to `transition:`, except that the resulting transitions are not bidirectional — an `in` transition will continue to ‘play’ alongside the `out` transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.
```
<script>
  import { fade, fly } from 'svelte/transition';
  
  let visible = $state(false);
</script>

<label>
  <input type="checkbox" bind:checked={visible}>
  visible
</label>

{#if visible}
	<div in:fly={{ y: 200 }} out:fade>flies in, fades out</div>
{/if}
```



---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---




---




---




---

Svelte components can also be compiled to custom elements (aka web components) using the `customElement: true` compiler option. You should specify a tag name for the component using the `<svelte:options>` element.
```
<svelte:options customElement="my-element" />

<script>
	let { name = 'world' } = $props();
</script>

<h1>Hello {name}!</h1>
<slot />
```

You can leave out the tag name for any of your inner components which you don’t want to expose and use them like regular Svelte components. Consumers of the component can still name it afterwards if needed, using the static `element` property which contains the custom element constructor and which is available when the `customElement` compiler option is `true`.
```
import ```
type MyElement = SvelteComponent<Record<string, any>, any, any>
const MyElement: LegacyComponentType
```
`MyElement from './MyElement.svelte'; `var customElements: CustomElementRegistry`
Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element.
MDN Reference
customElements.`CustomElementRegistry.define(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions): void`
MDN Reference
define('my-element', `const MyElement: LegacyComponentType`MyElement.element);`
```

Once a custom element has been defined, it can be used as a regular DOM element:
```
```
module document
var document: Document
```
`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML = ` <my-element> <p>This is some slotted content</p> </my-element> `;`
```

Any props are exposed as properties of the DOM element (as well as being readable/writable as attributes, where possible).
```
const ```
module el
const el: Element | null
```
`el = `var document: Document`
MDN Reference
document.`ParentNode.querySelector<Element>(selectors: string): Element | null (+4 overloads)`
Returns the first element that is a descendant of node that matches selectors.
MDN Reference
querySelector('my-element'); // get the current value of the 'name' prop `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
module el
const el: Element | null
```
`el.name); // set a new value, updating the shadow DOM ````
module el
const el: Element | null
```
`el.name = 'everybody';`
```

Note that you need to list out all properties explicitly, i.e. doing `let props = $props()` without declaring `props` in the component options means that Svelte can’t know which props to expose as properties on the DOM element.
##  Component lifecycle
Custom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately.
When a custom element is created, the Svelte component it wraps is _not_ created right away. It is only created in the next tick after the `connectedCallback` is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the `extend` option.
When a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily (but synchronously) detach the element from the DOM don’t lead to unmounting the inner component.
The inner Svelte component is destroyed in the next tick after the `disconnectedCallback` is invoked.
##  Component options
When constructing a custom element, you can tailor several aspects by defining `customElement` as an object within `<svelte:options>` since Svelte 4. This object may contain the following properties:
  * `tag: string`: an optional `tag` property for the custom element’s name. If set, a custom element with this tag name will be defined with the document’s `customElements` registry upon importing this component.
  * `shadow`: an optional property that can be set to `"none"` to forgo shadow root creation. Note that styles are then no longer encapsulated, and you can’t use slots
  * `props`: an optional property to modify certain details and behaviors of your component’s properties. It offers the following settings:
    * `attribute: string`: To update a custom element’s prop, you have two alternatives: either set the property on the custom element’s reference as illustrated above or use an HTML attribute. For the latter, the default attribute name is the lowercase property name. Modify this by assigning `attribute: "<desired name>"`.
    * `reflect: boolean`: By default, updated prop values do not reflect back to the DOM. To enable this behavior, set `reflect: true`.
    * `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'`: While converting an attribute value to a prop value and reflecting it back, the prop value is assumed to be a `String` by default. This may not always be accurate. For instance, for a number type, define it using `type: "Number"` You don’t need to list all properties, those not listed will use the default settings.
  * `extend`: an optional property which expects a function as its argument. It is passed the custom element class generated by Svelte and expects you to return a custom element class. This comes in handy if you have very specific requirements to the life cycle of the custom element or want to enhance the class to for example use ElementInternals for better HTML form integration.


```
<svelte:options
	customElement={{
		tag: 'custom-element',
		shadow: 'none',
		props: {
			name: { reflect: true, type: 'Number', attribute: 'element-index' }
		},
		extend: (customElementConstructor) => {
			// Extend the class so we can let it participate in HTML forms
			return class extends customElementConstructor {
				static formAssociated = true;

				constructor() {
					super();
					this.attachedInternals = this.attachInternals();
				}

				// Add the function here, not below in the component so that
				// it's always available, not just when the inner Svelte component
				// is mounted
				randomIndex() {
					this.elementIndex = Math.random();
				}
			};
		}
	}}
/>

<script>
	let { elementIndex, attachedInternals } = $props();
	// ...
	function check() {
		attachedInternals.checkValidity();
	}
</script>

...
```

##  Caveats and limitations
Custom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as most frameworks. There are, however, some important differences to be aware of:
  * Styles are _encapsulated_ , rather than merely _scoped_ (unless you set `shadow: "none"`). This means that any non-component styles (such as you might have in a `global.css` file) will not apply to the custom element, including styles with the `:global(...)` modifier
  * Instead of being extracted out as a separate .css file, styles are inlined into the component as a JavaScript string
  * Custom elements are not generally suitable for server-side rendering, as the shadow DOM is invisible until JavaScript loads
  * In Svelte, slotted content renders _lazily_. In the DOM, it renders _eagerly_. In other words, it will always be created even if the component’s `<slot>` element is inside an `{#if ...}` block. Similarly, including a `<slot>` in an `{#each ...}` block will not cause the slotted content to be rendered multiple times
  * The deprecated `let:` directive has no effect, because custom elements do not have a way to pass data to the parent component that fills the slot
  * Polyfills are required to support older browsers
  * You can use Svelte’s context feature between regular Svelte components within a custom element, but you can’t use them across custom elements. In other words, you can’t use `setContext` on a parent custom element and read that with `getContext` in a child custom element.
  * Don’t declare properties or attributes starting with `on`, as their usage will be interpreted as an event listener. In other words, Svelte treats `<custom-element oneworld={true}></custom-element>` as `customElement.addEventListener('eworld', true)` (and not as `customElement.oneworld = true`)


Edit this page on GitHub llms.txt
previous next
TypeScript Svelte 4 migration guide
Svelte components can also be compiled to custom elements (aka web components) using the `customElement: true` compiler option. You should specify a tag name for the component using the `<svelte:options>` element.
```
<svelte:options customElement="my-element" />

<script>
	let { name = 'world' } = $props();
</script>

<h1>Hello {name}!</h1>
<slot />
```

You can leave out the tag name for any of your inner components which you don’t want to expose and use them like regular Svelte components. Consumers of the component can still name it afterwards if needed, using the static `element` property which contains the custom element constructor and which is available when the `customElement` compiler option is `true`.
```
import ```
type MyElement = SvelteComponent<Record<string, any>, any, any>
const MyElement: LegacyComponentType
```
`MyElement from './MyElement.svelte'; `var customElements: CustomElementRegistry`
Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element.
MDN Reference
customElements.`CustomElementRegistry.define(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions): void`
MDN Reference
define('my-element', `const MyElement: LegacyComponentType`MyElement.element);`
```

Once a custom element has been defined, it can be used as a regular DOM element:
```
```
module document
var document: Document
```
`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML = ` <my-element> <p>This is some slotted content</p> </my-element> `;`
```

Any props are exposed as properties of the DOM element (as well as being readable/writable as attributes, where possible).
```
const ```
module el
const el: Element | null
```
`el = `var document: Document`
MDN Reference
document.`ParentNode.querySelector<Element>(selectors: string): Element | null (+4 overloads)`
Returns the first element that is a descendant of node that matches selectors.
MDN Reference
querySelector('my-element'); // get the current value of the 'name' prop `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
module el
const el: Element | null
```
`el.name); // set a new value, updating the shadow DOM ````
module el
const el: Element | null
```
`el.name = 'everybody';`
```

Note that you need to list out all properties explicitly, i.e. doing `let props = $props()` without declaring `props` in the component options means that Svelte can’t know which props to expose as properties on the DOM element.
##  Component lifecycle
Custom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately.
When a custom element is created, the Svelte component it wraps is _not_ created right away. It is only created in the next tick after the `connectedCallback` is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the `extend` option.
When a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily (but synchronously) detach the element from the DOM don’t lead to unmounting the inner component.
The inner Svelte component is destroyed in the next tick after the `disconnectedCallback` is invoked.
##  Component options
When constructing a custom element, you can tailor several aspects by defining `customElement` as an object within `<svelte:options>` since Svelte 4. This object may contain the following properties:
  * `tag: string`: an optional `tag` property for the custom element’s name. If set, a custom element with this tag name will be defined with the document’s `customElements` registry upon importing this component.
  * `shadow`: an optional property that can be set to `"none"` to forgo shadow root creation. Note that styles are then no longer encapsulated, and you can’t use slots
  * `props`: an optional property to modify certain details and behaviors of your component’s properties. It offers the following settings:
    * `attribute: string`: To update a custom element’s prop, you have two alternatives: either set the property on the custom element’s reference as illustrated above or use an HTML attribute. For the latter, the default attribute name is the lowercase property name. Modify this by assigning `attribute: "<desired name>"`.
    * `reflect: boolean`: By default, updated prop values do not reflect back to the DOM. To enable this behavior, set `reflect: true`.
    * `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'`: While converting an attribute value to a prop value and reflecting it back, the prop value is assumed to be a `String` by default. This may not always be accurate. For instance, for a number type, define it using `type: "Number"` You don’t need to list all properties, those not listed will use the default settings.
  * `extend`: an optional property which expects a function as its argument. It is passed the custom element class generated by Svelte and expects you to return a custom element class. This comes in handy if you have very specific requirements to the life cycle of the custom element or want to enhance the class to for example use ElementInternals for better HTML form integration.


```
<svelte:options
	customElement={{
		tag: 'custom-element',
		shadow: 'none',
		props: {
			name: { reflect: true, type: 'Number', attribute: 'element-index' }
		},
		extend: (customElementConstructor) => {
			// Extend the class so we can let it participate in HTML forms
			return class extends customElementConstructor {
				static formAssociated = true;

				constructor() {
					super();
					this.attachedInternals = this.attachInternals();
				}

				// Add the function here, not below in the component so that
				// it's always available, not just when the inner Svelte component
				// is mounted
				randomIndex() {
					this.elementIndex = Math.random();
				}
			};
		}
	}}
/>

<script>
	let { elementIndex, attachedInternals } = $props();
	// ...
	function check() {
		attachedInternals.checkValidity();
	}
</script>

...
```

##  Caveats and limitations
Custom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as most frameworks. There are, however, some important differences to be aware of:
  * Styles are _encapsulated_ , rather than merely _scoped_ (unless you set `shadow: "none"`). This means that any non-component styles (such as you might have in a `global.css` file) will not apply to the custom element, including styles with the `:global(...)` modifier
  * Instead of being extracted out as a separate .css file, styles are inlined into the component as a JavaScript string
  * Custom elements are not generally suitable for server-side rendering, as the shadow DOM is invisible until JavaScript loads
  * In Svelte, slotted content renders _lazily_. In the DOM, it renders _eagerly_. In other words, it will always be created even if the component’s `<slot>` element is inside an `{#if ...}` block. Similarly, including a `<slot>` in an `{#each ...}` block will not cause the slotted content to be rendered multiple times
  * The deprecated `let:` directive has no effect, because custom elements do not have a way to pass data to the parent component that fills the slot
  * Polyfills are required to support older browsers
  * You can use Svelte’s context feature between regular Svelte components within a custom element, but you can’t use them across custom elements. In other words, you can’t use `setContext` on a parent custom element and read that with `getContext` in a child custom element.
  * Don’t declare properties or attributes starting with `on`, as their usage will be interpreted as an event listener. In other words, Svelte treats `<custom-element oneworld={true}></custom-element>` as `customElement.addEventListener('eworld', true)` (and not as `customElement.oneworld = true`)


Edit this page on GitHub llms.txt
previous next
TypeScript Svelte 4 migration guide
Svelte components can also be compiled to custom elements (aka web components) using the `customElement: true` compiler option. You should specify a tag name for the component using the `<svelte:options>` element.
```
<svelte:options customElement="my-element" />

<script>
	let { name = 'world' } = $props();
</script>

<h1>Hello {name}!</h1>
<slot />
```

You can leave out the tag name for any of your inner components which you don’t want to expose and use them like regular Svelte components. Consumers of the component can still name it afterwards if needed, using the static `element` property which contains the custom element constructor and which is available when the `customElement` compiler option is `true`.
```
import ```
type MyElement = SvelteComponent<Record<string, any>, any, any>
const MyElement: LegacyComponentType
```
`MyElement from './MyElement.svelte'; `var customElements: CustomElementRegistry`
Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element.
MDN Reference
customElements.`CustomElementRegistry.define(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions): void`
MDN Reference
define('my-element', `const MyElement: LegacyComponentType`MyElement.element);`
```

Once a custom element has been defined, it can be used as a regular DOM element:
```
```
module document
var document: Document
```
`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML = ` <my-element> <p>This is some slotted content</p> </my-element> `;`
```

Any props are exposed as properties of the DOM element (as well as being readable/writable as attributes, where possible).
```
const ```
module el
const el: Element | null
```
`el = `var document: Document`
MDN Reference
document.`ParentNode.querySelector<Element>(selectors: string): Element | null (+4 overloads)`
Returns the first element that is a descendant of node that matches selectors.
MDN Reference
querySelector('my-element'); // get the current value of the 'name' prop `var console: Console`
The `console` module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.
The module exports two specific components:
  * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling `require('console')`.


_**Warning**_ : The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the `note on process I/O` for more information.
Example using the global `console`:
```
console.log('hello world');
// Prints: hello world, to stdout
console.log('hello %s', 'world');
// Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
// Prints error message and stack trace to stderr:
//   Error: Whoops, something bad happened
//     at [eval]:5:15
//     at Script.runInThisContext (node:vm:132:18)
//     at Object.runInThisContext (node:vm:309:38)
//     at node:internal/process/execution:77:19
//     at [eval]-wrapper:6:22
//     at evalScript (node:internal/process/execution:76:60)
//     at node:internal/main/eval_string:23:3

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to stderr
```

Example using the `Console` class:
```
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
// Prints: hello world, to out
myConsole.log('hello %s', 'world');
// Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
// Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
// Prints: Danger Will Robinson! Danger!, to err
```

@seesource
console.`Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)`
Prints to `stdout` with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to `printf(3)` (the arguments are all passed to `util.format()`).
```
const count = 5;
console.log('count: %d', count);
// Prints: count: 5, to stdout
console.log('count:', count);
// Prints: count: 5, to stdout
```

See `util.format()` for more information.
@sincev0.1.100
log(````
module el
const el: Element | null
```
`el.name); // set a new value, updating the shadow DOM ````
module el
const el: Element | null
```
`el.name = 'everybody';`
```

Note that you need to list out all properties explicitly, i.e. doing `let props = $props()` without declaring `props` in the component options means that Svelte can’t know which props to expose as properties on the DOM element.
##  Component lifecycle
Custom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately.
When a custom element is created, the Svelte component it wraps is _not_ created right away. It is only created in the next tick after the `connectedCallback` is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the `extend` option.
When a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily (but synchronously) detach the element from the DOM don’t lead to unmounting the inner component.
The inner Svelte component is destroyed in the next tick after the `disconnectedCallback` is invoked.
##  Component options
When constructing a custom element, you can tailor several aspects by defining `customElement` as an object within `<svelte:options>` since Svelte 4. This object may contain the following properties:
  * `tag: string`: an optional `tag` property for the custom element’s name. If set, a custom element with this tag name will be defined with the document’s `customElements` registry upon importing this component.
  * `shadow`: an optional property that can be set to `"none"` to forgo shadow root creation. Note that styles are then no longer encapsulated, and you can’t use slots
  * `props`: an optional property to modify certain details and behaviors of your component’s properties. It offers the following settings:
    * `attribute: string`: To update a custom element’s prop, you have two alternatives: either set the property on the custom element’s reference as illustrated above or use an HTML attribute. For the latter, the default attribute name is the lowercase property name. Modify this by assigning `attribute: "<desired name>"`.
    * `reflect: boolean`: By default, updated prop values do not reflect back to the DOM. To enable this behavior, set `reflect: true`.
    * `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'`: While converting an attribute value to a prop value and reflecting it back, the prop value is assumed to be a `String` by default. This may not always be accurate. For instance, for a number type, define it using `type: "Number"` You don’t need to list all properties, those not listed will use the default settings.
  * `extend`: an optional property which expects a function as its argument. It is passed the custom element class generated by Svelte and expects you to return a custom element class. This comes in handy if you have very specific requirements to the life cycle of the custom element or want to enhance the class to for example use ElementInternals for better HTML form integration.


```
<svelte:options
	customElement={{
		tag: 'custom-element',
		shadow: 'none',
		props: {
			name: { reflect: true, type: 'Number', attribute: 'element-index' }
		},
		extend: (customElementConstructor) => {
			// Extend the class so we can let it participate in HTML forms
			return class extends customElementConstructor {
				static formAssociated = true;

				constructor() {
					super();
					this.attachedInternals = this.attachInternals();
				}

				// Add the function here, not below in the component so that
				// it's always available, not just when the inner Svelte component
				// is mounted
				randomIndex() {
					this.elementIndex = Math.random();
				}
			};
		}
	}}
/>

<script>
	let { elementIndex, attachedInternals } = $props();
	// ...
	function check() {
		attachedInternals.checkValidity();
	}
</script>

...
```

##  Caveats and limitations
Custom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as most frameworks. There are, however, some important differences to be aware of:
  * Styles are _encapsulated_ , rather than merely _scoped_ (unless you set `shadow: "none"`). This means that any non-component styles (such as you might have in a `global.css` file) will not apply to the custom element, including styles with the `:global(...)` modifier
  * Instead of being extracted out as a separate .css file, styles are inlined into the component as a JavaScript string
  * Custom elements are not generally suitable for server-side rendering, as the shadow DOM is invisible until JavaScript loads
  * In Svelte, slotted content renders _lazily_. In the DOM, it renders _eagerly_. In other words, it will always be created even if the component’s `<slot>` element is inside an `{#if ...}` block. Similarly, including a `<slot>` in an `{#each ...}` block will not cause the slotted content to be rendered multiple times
  * The deprecated `let:` directive has no effect, because custom elements do not have a way to pass data to the parent component that fills the slot
  * Polyfills are required to support older browsers
  * You can use Svelte’s context feature between regular Svelte components within a custom element, but you can’t use them across custom elements. In other words, you can’t use `setContext` on a parent custom element and read that with `getContext` in a child custom element.
  * Don’t declare properties or attributes starting with `on`, as their usage will be interpreted as an event listener. In other words, Svelte treats `<custom-element oneworld={true}></custom-element>` as `customElement.addEventListener('eworld', true)` (and not as `customElement.oneworld = true`)




---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---




---

```
import {
	function backIn(t: number): numberbackIn,
	function backInOut(t: number): numberbackInOut,
	function backOut(t: number): numberbackOut,
	function bounceIn(t: number): numberbounceIn,
	function bounceInOut(t: number): numberbounceInOut,
	function bounceOut(t: number): numberbounceOut,
	function circIn(t: number): numbercircIn,
	function circInOut(t: number): numbercircInOut,
	function circOut(t: number): numbercircOut,
	function cubicIn(t: number): numbercubicIn,
	function cubicInOut(t: number): numbercubicInOut,
	function cubicOut(t: number): numbercubicOut,
	function elasticIn(t: number): numberelasticIn,
	function elasticInOut(t: number): numberelasticInOut,
	function elasticOut(t: number): numberelasticOut,
	function expoIn(t: number): numberexpoIn,
	function expoInOut(t: number): numberexpoInOut,
	function expoOut(t: number): numberexpoOut,
	function linear(t: number): numberlinear,
	function quadIn(t: number): numberquadIn,
	function quadInOut(t: number): numberquadInOut,
	function quadOut(t: number): numberquadOut,
	function quartIn(t: number): numberquartIn,
	function quartInOut(t: number): numberquartInOut,
	function quartOut(t: number): numberquartOut,
	function quintIn(t: number): numberquintIn,
	function quintInOut(t: number): numberquintInOut,
	function quintOut(t: number): numberquintOut,
	function sineIn(t: number): numbersineIn,
	function sineInOut(t: number): numbersineInOut,
	function sineOut(t: number): numbersineOut
} from 'svelte/easing';
```

##  backIn
```
function backIn(t: number): number;
```

##  backInOut
```
function backInOut(t: number): number;
```

##  backOut
```
function backOut(t: number): number;
```

##  bounceIn
```
function bounceIn(t: number): number;
```

##  bounceInOut
```
function bounceInOut(t: number): number;
```

##  bounceOut
```
function bounceOut(t: number): number;
```

##  circIn
```
function circIn(t: number): number;
```

##  circInOut
```
function circInOut(t: number): number;
```

##  circOut
```
function circOut(t: number): number;
```

##  cubicIn
```
function cubicIn(t: number): number;
```

##  cubicInOut
```
function cubicInOut(t: number): number;
```

##  cubicOut
```
function cubicOut(t: number): number;
```

##  elasticIn
```
function elasticIn(t: number): number;
```

##  elasticInOut
```
function elasticInOut(t: number): number;
```

##  elasticOut
```
function elasticOut(t: number): number;
```

##  expoIn
```
function expoIn(t: number): number;
```

##  expoInOut
```
function expoInOut(t: number): number;
```

##  expoOut
```
function expoOut(t: number): number;
```

##  linear
```
function linear(t: number): number;
```

##  quadIn
```
function quadIn(t: number): number;
```

##  quadInOut
```
function quadInOut(t: number): number;
```

##  quadOut
```
function quadOut(t: number): number;
```

##  quartIn
```
function quartIn(t: number): number;
```

##  quartInOut
```
function quartInOut(t: number): number;
```

##  quartOut
```
function quartOut(t: number): number;
```

##  quintIn
```
function quintIn(t: number): number;
```

##  quintInOut
```
function quintInOut(t: number): number;
```

##  quintOut
```
function quintOut(t: number): number;
```

##  sineIn
```
function sineIn(t: number): number;
```

##  sineInOut
```
function sineInOut(t: number): number;
```

##  sineOut
```
function sineOut(t: number): number;
```

Edit this page on GitHub llms.txt
previous next
svelte/compiler svelte/events
```
import {
	function backIn(t: number): numberbackIn,
	function backInOut(t: number): numberbackInOut,
	function backOut(t: number): numberbackOut,
	function bounceIn(t: number): numberbounceIn,
	function bounceInOut(t: number): numberbounceInOut,
	function bounceOut(t: number): numberbounceOut,
	function circIn(t: number): numbercircIn,
	function circInOut(t: number): numbercircInOut,
	function circOut(t: number): numbercircOut,
	function cubicIn(t: number): numbercubicIn,
	function cubicInOut(t: number): numbercubicInOut,
	function cubicOut(t: number): numbercubicOut,
	function elasticIn(t: number): numberelasticIn,
	function elasticInOut(t: number): numberelasticInOut,
	function elasticOut(t: number): numberelasticOut,
	function expoIn(t: number): numberexpoIn,
	function expoInOut(t: number): numberexpoInOut,
	function expoOut(t: number): numberexpoOut,
	function linear(t: number): numberlinear,
	function quadIn(t: number): numberquadIn,
	function quadInOut(t: number): numberquadInOut,
	function quadOut(t: number): numberquadOut,
	function quartIn(t: number): numberquartIn,
	function quartInOut(t: number): numberquartInOut,
	function quartOut(t: number): numberquartOut,
	function quintIn(t: number): numberquintIn,
	function quintInOut(t: number): numberquintInOut,
	function quintOut(t: number): numberquintOut,
	function sineIn(t: number): numbersineIn,
	function sineInOut(t: number): numbersineInOut,
	function sineOut(t: number): numbersineOut
} from 'svelte/easing';
```

##  backIn
```
function backIn(t: number): number;
```

##  backInOut
```
function backInOut(t: number): number;
```

##  backOut
```
function backOut(t: number): number;
```

##  bounceIn
```
function bounceIn(t: number): number;
```

##  bounceInOut
```
function bounceInOut(t: number): number;
```

##  bounceOut
```
function bounceOut(t: number): number;
```

##  circIn
```
function circIn(t: number): number;
```

##  circInOut
```
function circInOut(t: number): number;
```

##  circOut
```
function circOut(t: number): number;
```

##  cubicIn
```
function cubicIn(t: number): number;
```

##  cubicInOut
```
function cubicInOut(t: number): number;
```

##  cubicOut
```
function cubicOut(t: number): number;
```

##  elasticIn
```
function elasticIn(t: number): number;
```

##  elasticInOut
```
function elasticInOut(t: number): number;
```

##  elasticOut
```
function elasticOut(t: number): number;
```

##  expoIn
```
function expoIn(t: number): number;
```

##  expoInOut
```
function expoInOut(t: number): number;
```

##  expoOut
```
function expoOut(t: number): number;
```

##  linear
```
function linear(t: number): number;
```

##  quadIn
```
function quadIn(t: number): number;
```

##  quadInOut
```
function quadInOut(t: number): number;
```

##  quadOut
```
function quadOut(t: number): number;
```

##  quartIn
```
function quartIn(t: number): number;
```

##  quartInOut
```
function quartInOut(t: number): number;
```

##  quartOut
```
function quartOut(t: number): number;
```

##  quintIn
```
function quintIn(t: number): number;
```

##  quintInOut
```
function quintInOut(t: number): number;
```

##  quintOut
```
function quintOut(t: number): number;
```

##  sineIn
```
function sineIn(t: number): number;
```

##  sineInOut
```
function sineInOut(t: number): number;
```

##  sineOut
```
function sineOut(t: number): number;
```

Edit this page on GitHub llms.txt
previous next
svelte/compiler svelte/events
```
import {
	function backIn(t: number): numberbackIn,
	function backInOut(t: number): numberbackInOut,
	function backOut(t: number): numberbackOut,
	function bounceIn(t: number): numberbounceIn,
	function bounceInOut(t: number): numberbounceInOut,
	function bounceOut(t: number): numberbounceOut,
	function circIn(t: number): numbercircIn,
	function circInOut(t: number): numbercircInOut,
	function circOut(t: number): numbercircOut,
	function cubicIn(t: number): numbercubicIn,
	function cubicInOut(t: number): numbercubicInOut,
	function cubicOut(t: number): numbercubicOut,
	function elasticIn(t: number): numberelasticIn,
	function elasticInOut(t: number): numberelasticInOut,
	function elasticOut(t: number): numberelasticOut,
	function expoIn(t: number): numberexpoIn,
	function expoInOut(t: number): numberexpoInOut,
	function expoOut(t: number): numberexpoOut,
	function linear(t: number): numberlinear,
	function quadIn(t: number): numberquadIn,
	function quadInOut(t: number): numberquadInOut,
	function quadOut(t: number): numberquadOut,
	function quartIn(t: number): numberquartIn,
	function quartInOut(t: number): numberquartInOut,
	function quartOut(t: number): numberquartOut,
	function quintIn(t: number): numberquintIn,
	function quintInOut(t: number): numberquintInOut,
	function quintOut(t: number): numberquintOut,
	function sineIn(t: number): numbersineIn,
	function sineInOut(t: number): numbersineInOut,
	function sineOut(t: number): numbersineOut
} from 'svelte/easing';
```

##  backIn
```
function backIn(t: number): number;
```

##  backInOut
```
function backInOut(t: number): number;
```

##  backOut
```
function backOut(t: number): number;
```

##  bounceIn
```
function bounceIn(t: number): number;
```

##  bounceInOut
```
function bounceInOut(t: number): number;
```

##  bounceOut
```
function bounceOut(t: number): number;
```

##  circIn
```
function circIn(t: number): number;
```

##  circInOut
```
function circInOut(t: number): number;
```

##  circOut
```
function circOut(t: number): number;
```

##  cubicIn
```
function cubicIn(t: number): number;
```

##  cubicInOut
```
function cubicInOut(t: number): number;
```

##  cubicOut
```
function cubicOut(t: number): number;
```

##  elasticIn
```
function elasticIn(t: number): number;
```

##  elasticInOut
```
function elasticInOut(t: number): number;
```

##  elasticOut
```
function elasticOut(t: number): number;
```

##  expoIn
```
function expoIn(t: number): number;
```

##  expoInOut
```
function expoInOut(t: number): number;
```

##  expoOut
```
function expoOut(t: number): number;
```

##  linear
```
function linear(t: number): number;
```

##  quadIn
```
function quadIn(t: number): number;
```

##  quadInOut
```
function quadInOut(t: number): number;
```

##  quadOut
```
function quadOut(t: number): number;
```

##  quartIn
```
function quartIn(t: number): number;
```

##  quartInOut
```
function quartInOut(t: number): number;
```

##  quartOut
```
function quartOut(t: number): number;
```

##  quintIn
```
function quintIn(t: number): number;
```

##  quintInOut
```
function quintInOut(t: number): number;
```

##  quintOut
```
function quintOut(t: number): number;
```

##  sineIn
```
function sineIn(t: number): number;
```

##  sineInOut
```
function sineInOut(t: number): number;
```

##  sineOut
```
function sineOut(t: number): number;
```



---

Components are the building blocks of Svelte applications. They are written into `.svelte` files, using a superset of HTML.
All three sections — script, styles and markup — are optional.
MyComponent
```
<script module>
	// module-level logic goes here
	// (you will rarely use this)
</script>

<script>
	// instance-level logic goes here
</script>

<!-- markup (zero or more items) goes here -->

<style>
	/* styles go here */
</style>
```
```
<script module>
	// module-level logic goes here
	// (you will rarely use this)
</script>

<script lang="ts">
	// instance-level logic goes here
</script>

<!-- markup (zero or more items) goes here -->

<style>
	/* styles go here */
</style>
```

##  <script>
A `<script>` block contains JavaScript (or TypeScript, when adding the `lang="ts"` attribute) that runs when a component instance is created. Variables declared (or imported) at the top level can be referenced in the component’s markup.
In addition to normal JavaScript, you can use _runes_ to declare component props and add reactivity to your component. Runes are covered in the next section.
##  <script module>
A `<script>` tag with a `module` attribute runs once when the module first evaluates, rather than for each component instance. Variables declared in this block can be referenced elsewhere in the component, but not vice versa.
```
<script module>
	let total = 0;
</script>

<script>
	total += 1;
	console.log(`instantiated ${total} times`);
</script>
```

You can `export` bindings from this block, and they will become exports of the compiled module. You cannot `export default`, since the default export is the component itself.
> If you are using TypeScript and import such exports from a `module` block into a `.ts` file, make sure to have your editor setup so that TypeScript knows about them. This is the case for our VS Code extension and the IntelliJ plugin, but in other cases you might need to setup our TypeScript editor plugin.
> Legacy mode
> In Svelte 4, this script tag was created using `<script context="module">`
##  <style>
CSS inside a `<style>` block will be scoped to that component.
```
<style>
	p {
		/* this will only affect <p> elements in this component */
		color: burlywood;
	}
</style>
```

For more information, head to the section on styling.
Edit this page on GitHub llms.txt
previous next
Getting started .svelte.js and .svelte.ts files
Components are the building blocks of Svelte applications. They are written into `.svelte` files, using a superset of HTML.
All three sections — script, styles and markup — are optional.
MyComponent
```
<script module>
	// module-level logic goes here
	// (you will rarely use this)
</script>

<script>
	// instance-level logic goes here
</script>

<!-- markup (zero or more items) goes here -->

<style>
	/* styles go here */
</style>
```
```
<script module>
	// module-level logic goes here
	// (you will rarely use this)
</script>

<script lang="ts">
	// instance-level logic goes here
</script>

<!-- markup (zero or more items) goes here -->

<style>
	/* styles go here */
</style>
```

##  <script>
A `<script>` block contains JavaScript (or TypeScript, when adding the `lang="ts"` attribute) that runs when a component instance is created. Variables declared (or imported) at the top level can be referenced in the component’s markup.
In addition to normal JavaScript, you can use _runes_ to declare component props and add reactivity to your component. Runes are covered in the next section.
##  <script module>
A `<script>` tag with a `module` attribute runs once when the module first evaluates, rather than for each component instance. Variables declared in this block can be referenced elsewhere in the component, but not vice versa.
```
<script module>
	let total = 0;
</script>

<script>
	total += 1;
	console.log(`instantiated ${total} times`);
</script>
```

You can `export` bindings from this block, and they will become exports of the compiled module. You cannot `export default`, since the default export is the component itself.
> If you are using TypeScript and import such exports from a `module` block into a `.ts` file, make sure to have your editor setup so that TypeScript knows about them. This is the case for our VS Code extension and the IntelliJ plugin, but in other cases you might need to setup our TypeScript editor plugin.
> Legacy mode
> In Svelte 4, this script tag was created using `<script context="module">`
##  <style>
CSS inside a `<style>` block will be scoped to that component.
```
<style>
	p {
		/* this will only affect <p> elements in this component */
		color: burlywood;
	}
</style>
```

For more information, head to the section on styling.
Edit this page on GitHub llms.txt
previous next
Getting started .svelte.js and .svelte.ts files
Components are the building blocks of Svelte applications. They are written into `.svelte` files, using a superset of HTML.
All three sections — script, styles and markup — are optional.
MyComponent
```
<script module>
	// module-level logic goes here
	// (you will rarely use this)
</script>

<script>
	// instance-level logic goes here
</script>

<!-- markup (zero or more items) goes here -->

<style>
	/* styles go here */
</style>
```
```
<script module>
	// module-level logic goes here
	// (you will rarely use this)
</script>

<script lang="ts">
	// instance-level logic goes here
</script>

<!-- markup (zero or more items) goes here -->

<style>
	/* styles go here */
</style>
```

##  <script>
A `<script>` block contains JavaScript (or TypeScript, when adding the `lang="ts"` attribute) that runs when a component instance is created. Variables declared (or imported) at the top level can be referenced in the component’s markup.
In addition to normal JavaScript, you can use _runes_ to declare component props and add reactivity to your component. Runes are covered in the next section.
##  <script module>
A `<script>` tag with a `module` attribute runs once when the module first evaluates, rather than for each component instance. Variables declared in this block can be referenced elsewhere in the component, but not vice versa.
```
<script module>
	let total = 0;
</script>

<script>
	total += 1;
	console.log(`instantiated ${total} times`);
</script>
```

You can `export` bindings from this block, and they will become exports of the compiled module. You cannot `export default`, since the default export is the component itself.
> If you are using TypeScript and import such exports from a `module` block into a `.ts` file, make sure to have your editor setup so that TypeScript knows about them. This is the case for our VS Code extension and the IntelliJ plugin, but in other cases you might need to setup our TypeScript editor plugin.
> Legacy mode
> In Svelte 4, this script tag was created using `<script context="module">`
##  <style>
CSS inside a `<style>` block will be scoped to that component.
```
<style>
	p {
		/* this will only affect <p> elements in this component */
		color: burlywood;
	}
</style>
```

For more information, head to the section on styling.


---

Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use — you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.
##  Unit and integration testing using Vitest
Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you’re using Vite (including via SvelteKit), we recommend using Vitest. You can use the Svelte CLI to setup Vitest either during project creation or later on.
To setup Vitest manually, first install it:
```
npm install -D vitest
```

Then adjust your `vite.config.js`:
vite.config
```
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig } from 'vitest/config';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig({
	// ...
	// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node
	```
UserConfig.resolve?: (ResolveOptions & {
    alias?: AliasOptions;
}) | undefined
```
`
Configure resolver
resolve: `var process: NodeJS.Process`process.`NodeJS.Process.env: NodeJS.ProcessEnv`
The `process.env` property returns an object containing the user environment. See `environ(7)`.
An example of this object looks like:
```
{
  TERM: 'xterm-256color',
  SHELL: '/usr/local/bin/bash',
  USER: 'maciej',
  PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
  PWD: '/Users/maciej',
  EDITOR: 'vim',
  SHLVL: '1',
  HOME: '/Users/maciej',
  LOGNAME: 'maciej',
  _: '/usr/local/bin/node'
}
```

It is possible to modify this object, but such modifications will not be reflected outside the Node.js process, or (unless explicitly requested) to other `Worker` threads. In other words, the following example would not work:
```
node -e 'process.env.foo = "bar"' &#x26;#x26;&#x26;#x26; echo $foo
```

While the following will:
```
import { env } from 'node:process';

env.foo = 'bar';
console.log(env.foo);
```

Assigning a property on `process.env` will implicitly convert the value to a string. **This behavior is deprecated.** Future versions of Node.js may throw an error when the value is not a string, number, or boolean.
```
import { env } from 'node:process';

env.test = null;
console.log(env.test);
// => 'null'
env.test = undefined;
console.log(env.test);
// => 'undefined'
```

Use `delete` to delete a property from `process.env`.
```
import { env } from 'node:process';

env.TEST = 1;
delete env.TEST;
console.log(env.TEST);
// => undefined
```

On Windows operating systems, environment variables are case-insensitive.
```
import { env } from 'node:process';

env.TEST = 1;
console.log(env.test);
// => 1
```

Unless explicitly specified when creating a `Worker` instance, each `Worker` thread has its own copy of `process.env`, based on its parent thread’s `process.env`, or whatever was specified as the `env` option to the `Worker` constructor. Changes to `process.env` will not be visible across `Worker` threads, and only the main thread can make changes that are visible to the operating system or to native add-ons. On Windows, a copy of `process.env` on a `Worker` instance operates in a case-sensitive manner unlike the main thread.
@sincev0.1.27
env.`string | undefined`VITEST ? { `ResolveOptions.conditions?: string[] | undefined`conditions: ['browser'] } : `var undefined`undefined });`
```

> If loading the browser version of all your packages is undesirable, because (for example) you also test backend libraries, you may need to resort to an alias configuration
You can now write unit tests for code inside your `.js/.ts` files:
multiplier.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import multipliermultiplier } from './multiplier.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Multiplier', () => {
	let let double: anydouble = import multipliermultiplier(0, 2);

	expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)expect(let double: anydouble.value).JestAssertion<any>.toEqual: <number>(expected: number) => void


Used when you want to check that two objects have the same value.
This matcher recursively checks the equality of all fields, rather than checking for object identity.





@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });

toEqual(0);

	let double: anydouble.set(5);

	expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)expect(let double: anydouble.value).JestAssertion<any>.toEqual: <number>(expected: number) => void


Used when you want to check that two objects have the same value.
This matcher recursively checks the equality of all fields, rather than checking for object identity.





@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });

toEqual(10);
});
```

multiplier.svelte
```
/**
 * @param {number} initial
 * @param {number} k
 */
export function ```
function multiplier(initial: number, k: number): {
    readonly value: number;
    set: (c: number) => void;
}
```
`
@paraminitial
@paramk
multiplier(`initial: number`
@paraminitial
initial, `k: number`
@paramk
k) { let `let count: number`count = ````
function $state<number>(initial: number): number (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(`initial: number`
@paraminitial
initial); return { get `value: number`value() { return `let count: number`count * `k: number`
@paramk
k; }, /** @param {number} c */ `set: (c: number) => void`
@paramc
set: (`c: number`
@paramc
c) => { `let count: number`count = `c: number`
@paramc
c; } }; }`
```
```
export function ```
function multiplier(initial: number, k: number): {
    readonly value: number;
    set: (c: number) => void;
}
```
`multiplier(`initial: number`initial: number, `k: number`k: number) { let `let count: number`count = ````
function $state<number>(initial: number): number (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(`initial: number`initial); return { get `value: number`value() { return `let count: number`count * `k: number`k; }, `set: (c: number) => void`set: (`c: number`c: number) => { `let count: number`count = `c: number`c; } }; }`
```

###  Using runes inside your test files
Since Vitest processes your test files the same way as your source files, you can use runes inside your tests as long as the filename includes `.svelte`:
multiplier.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import multipliermultiplier } from './multiplier.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Multiplier', () => {
	let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); let `let double: any`double = `import multiplier`multiplier(() => `let count: number`count, 2); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let double: any`double.value).`JestAssertion<any>.toEqual: <number>(expected: number) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual(0); `let count: number`count = 5; `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let double: any`double.value).`JestAssertion<any>.toEqual: <number>(expected: number) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual(10); });`
```

multiplier.svelte
```
/**
 * @param {() => number} getCount
 * @param {number} k
 */
export function ```
function multiplier(getCount: () => number, k: number): {
    readonly value: number;
}
```
`
@paramgetCount
@paramk
multiplier(`getCount: () => number`
@paramgetCount
getCount, `k: number`
@paramk
k) { return { get `value: number`value() { return `getCount: () => number`
@paramgetCount
getCount() * `k: number`
@paramk
k; } }; }`
```
```
export function ```
function multiplier(getCount: () => number, k: number): {
    readonly value: number;
}
```
`multiplier(`getCount: () => number`getCount: () => number, `k: number`k: number) { return { get `value: number`value() { return `getCount: () => number`getCount() * `k: number`k; } }; }`
```

If the code being tested uses effects, you need to wrap the test inside `$effect.root`:
logger.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import loggerlogger } from './logger.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Effect', () => {
	const const cleanup: () => voidcleanup = ```
namespace $effect
function $effect(fn: () => void | (() => void)): void
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect.`function $effect.root(fn: () => void | (() => void)): () => void`
The `$effect.root` rune is an advanced feature that creates a non-tracked scope that doesn’t auto-cleanup. This is useful for nested effects that you want to manually control. This rune also allows for creation of effects outside of the component initialisation phase.
Example:
```
&#x3C;script>
  let count = $state(0);

  const cleanup = $effect.root(() => {
	$effect(() => {
			console.log(count);
		})

	 return () => {
	   console.log('effect root cleanup');
			}
  });
&#x3C;/script>

&#x3C;button onclick={() => cleanup()}>cleanup&#x3C;/button>
```

https://svelte.dev/docs/svelte/$effect#$effect.root
root(() => { let `let count: number`count = ````
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); // logger uses an $effect to log updates of its input let `let log: any`log = `import logger`logger(() => `let count: number`count); // effects normally run after a microtask, // use flushSync to execute all pending effects synchronously `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let log: any`log.value).`JestAssertion<any>.toEqual: <number[]>(expected: number[]) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual([0]); `let count: number`count = 1; `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let log: any`log.value).`JestAssertion<any>.toEqual: <number[]>(expected: number[]) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual([0, 1]); }); `const cleanup: () => void`cleanup(); });`
```

logger.svelte
```
/**
 * @param {() => any} getValue
 */
export function ```
function logger(getValue: () => any): {
    readonly value: any[];
}
```
`
@paramgetValue
logger(`getValue: () => any`
@paramgetValue
getValue) { /** @type {any[]} */ let `let log: any[]`
@type{any[]}
log = ````
function $state<never[]>(initial: never[]): never[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([]); ````
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { `let log: any[]`
@type{any[]}
log.`Array<any>.push(...items: any[]): number`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push(`getValue: () => any`
@paramgetValue
getValue()); }); return { get `value: any[]`value() { return `let log: any[]`
@type{any[]}
log; } }; }`
```
```
export function ```
function logger(getValue: () => any): {
    readonly value: any[];
}
```
`logger(`getValue: () => any`getValue: () => any) { let `let log: any[]`log: any[] = ````
function $state<never[]>(initial: never[]): never[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([]); ````
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { `let log: any[]`log.`Array<any>.push(...items: any[]): number`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push(`getValue: () => any`getValue()); }); return { get `value: any[]`value() { return `let log: any[]`log; } }; }`
```

###  Component testing
It is possible to test your components in isolation using Vitest.
> Before writing component tests, think about whether you actually need to test the component, or if it’s more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component
To get started, install jsdom (a library that shims DOM APIs):
```
npm install -D jsdom
```

Then adjust your `vite.config.js`:
vite.config
```
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig } from 'vitest/config';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig({
	UserConfig.plugins?: PluginOption[] | undefined


Array of vite plugins to use.


plugins: [
		/* ... */
	],
	UserConfig.test?: InlineConfig | undefined


Options for Vitest


test: {
		// If you are testing components client-side, you need to setup a DOM environment.
		// If not all your files should have this environment, you can use a
		// `// @vitest-environment jsdom` comment at the top of the test files instead.
		InlineConfig.environment?: VitestEnvironment | undefined


Running environment


Supports ‘node’, ‘jsdom’, ‘happy-dom’, ‘edge-runtime’


If used unsupported string, will try to load the package vitest-environment-${env}





@default'node'

environment: 'jsdom'
	},
	// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node
	```
UserConfig.resolve?: (ResolveOptions & {
    alias?: AliasOptions;
}) | undefined
```
`
Configure resolver
resolve: `var process: NodeJS.Process`process.`NodeJS.Process.env: NodeJS.ProcessEnv`
The `process.env` property returns an object containing the user environment. See `environ(7)`.
An example of this object looks like:
```
{
  TERM: 'xterm-256color',
  SHELL: '/usr/local/bin/bash',
  USER: 'maciej',
  PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
  PWD: '/Users/maciej',
  EDITOR: 'vim',
  SHLVL: '1',
  HOME: '/Users/maciej',
  LOGNAME: 'maciej',
  _: '/usr/local/bin/node'
}
```

It is possible to modify this object, but such modifications will not be reflected outside the Node.js process, or (unless explicitly requested) to other `Worker` threads. In other words, the following example would not work:
```
node -e 'process.env.foo = "bar"' &#x26;#x26;&#x26;#x26; echo $foo
```

While the following will:
```
import { env } from 'node:process';

env.foo = 'bar';
console.log(env.foo);
```

Assigning a property on `process.env` will implicitly convert the value to a string. **This behavior is deprecated.** Future versions of Node.js may throw an error when the value is not a string, number, or boolean.
```
import { env } from 'node:process';

env.test = null;
console.log(env.test);
// => 'null'
env.test = undefined;
console.log(env.test);
// => 'undefined'
```

Use `delete` to delete a property from `process.env`.
```
import { env } from 'node:process';

env.TEST = 1;
delete env.TEST;
console.log(env.TEST);
// => undefined
```

On Windows operating systems, environment variables are case-insensitive.
```
import { env } from 'node:process';

env.TEST = 1;
console.log(env.test);
// => 1
```

Unless explicitly specified when creating a `Worker` instance, each `Worker` thread has its own copy of `process.env`, based on its parent thread’s `process.env`, or whatever was specified as the `env` option to the `Worker` constructor. Changes to `process.env` will not be visible across `Worker` threads, and only the main thread can make changes that are visible to the operating system or to native add-ons. On Windows, a copy of `process.env` on a `Worker` instance operates in a case-sensitive manner unlike the main thread.
@sincev0.1.27
env.`string | undefined`VITEST ? { `ResolveOptions.conditions?: string[] | undefined`conditions: ['browser'] } : `var undefined`undefined });`
```

After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:
component.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync, function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.


mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import { `const expect: ExpectStatic`expect, `const test: TestAPI`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test } from 'vitest'; import ````
type Component = SvelteComponent<Record<string, any>, any, any>
const Component: LegacyComponentType
```
`Component from './Component.svelte'; `test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test('Component', () => { // Instantiate the component using Svelte's `mount` API const ````
const component: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`component = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const Component: LegacyComponentType`Component, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body, // `document` exists because of jsdom `props?: Record<string, any> | undefined`
Component properties.
props: { `initial: number`initial: 0 } }); `expect<string>(actual: string, message?: string): Assertion<string> (+1 overload)`expect(`var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML).`JestAssertion<string>.toBe: <string>(expected: string) => void`
Checks that a value is what you expect. It calls `Object.is` to compare values. Don’t use `toBe` with floating-point numbers.
@exampleexpect(result).toBe(42); expect(status).toBe(true);
toBe('<button>0</button>'); // Click the button, then flush the changes so you can synchronously write expectations `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`ParentNode.querySelector<"button">(selectors: "button"): HTMLButtonElement | null (+4 overloads)`
Returns the first element that is a descendant of node that matches selectors.
MDN Reference
querySelector('button').`HTMLElement.click(): void`
MDN Reference
click(); `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<string>(actual: string, message?: string): Assertion<string> (+1 overload)`expect(`var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML).`JestAssertion<string>.toBe: <string>(expected: string) => void`
Checks that a value is what you expect. It calls `Object.is` to compare values. Don’t use `toBe` with floating-point numbers.
@exampleexpect(result).toBe(42); expect(status).toBe(true);
toBe('<button>1</button>'); // Remove the component from the DOM ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const component: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`component); });`
```

While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like @testing-library/svelte can help streamline your tests. The above test could be rewritten like this:
component.test
```
import { function render<C extends unknown, Q extends Queries = typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>(Component: ComponentType<...>, options?: SvelteComponentOptions<C>, renderOptions?: RenderOptions<Q>): RenderResult<C, Q>


Render a component into the document.







@template{import('./component-types.js').Component} C




@template{import('@testing-library/dom').Queries} [Q=typeof import('@testing-library/dom').queries]




@paramComponent - The component to render.




@paramoptions - Customize how Svelte renders the component.




@paramrenderOptions - Customize how Testing Library sets up the document and binds queries.




@returnsThe rendered component and bound testing functions.



render, const screen: Screen<typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>screen } from '@testing-library/svelte';
import ```
const userEvent: {
    readonly setup: typeof setupMain;
    readonly clear: typeof clear;
    readonly click: typeof click;
    readonly copy: typeof copy;
    ... 12 more ...;
    readonly tab: typeof tab;
}
```
`userEvent from '@testing-library/user-event'; import { `const expect: ExpectStatic`expect, `const test: TestAPI`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test } from 'vitest'; import ````
type Component = SvelteComponent<Record<string, any>, any, any>
const Component: LegacyComponentType
```
`Component from './Component.svelte'; `test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test('Component', async () => { const `const user: UserEvent`user = ````
const userEvent: {
    readonly setup: typeof setupMain;
    readonly clear: typeof clear;
    readonly click: typeof click;
    readonly copy: typeof copy;
    ... 12 more ...;
    readonly tab: typeof tab;
}
```
`userEvent.`setup: (options?: Options) => UserEvent`
Start a “session” with userEvent. All APIs returned by this function share an input device state and a default configuration.
setup(); `render<SvelteComponent<Record<string, any>, any, any>, typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>(Component: ComponentType<...>, options?: SvelteComponentOptions<...> | undefined, renderOptions?: RenderOptions<...> | undefined): RenderResult<...>`
Render a component into the document.
@template{import('./component-types.js').Component} C
@template{import('@testing-library/dom').Queries} [Q=typeof import('@testing-library/dom').queries]
@paramComponent - The component to render.
@paramoptions - Customize how Svelte renders the component.
@paramrenderOptions - Customize how Testing Library sets up the document and binds queries.
@returnsThe rendered component and bound testing functions.
render(`const Component: LegacyComponentType`Component); const `const button: HTMLElement`button = `const screen: Screen<typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>`screen.`getByRole<HTMLElement>(role: ByRoleMatcher, options?: ByRoleOptions | undefined): HTMLElement (+1 overload)`getByRole('button'); `expect<HTMLElement>(actual: HTMLElement, message?: string): Assertion<HTMLElement> (+1 overload)`expect(`const button: HTMLElement`button).toHaveTextContent(0); await `const user: UserEvent`user.`click: (element: Element) => Promise<void>`click(`const button: HTMLElement`button); `expect<HTMLElement>(actual: HTMLElement, message?: string): Assertion<HTMLElement> (+1 overload)`expect(`const button: HTMLElement`button).toHaveTextContent(1); });`
```

When writing component tests that involve two-way bindings, context or snippet props, it’s best to create a wrapper component for your specific test and interact with that. `@testing-library/svelte` contains some examples.
##  E2E tests using Playwright
E2E (short for ‘end to end’) tests allow you to test your full application through the eyes of the user. This section uses Playwright as an example, but you can also use other solutions like Cypress or NightwatchJS.
You can use the Svelte CLI to setup Playwright either during project creation or later on. You can also set it up with `npm init playwright`. Additionally, you may also want to install an IDE plugin such as the VS Code extension to be able to execute tests from inside your IDE.
If you’ve run `npm init playwright` or are not using Vite, you may need to adjust the Playwright config to tell Playwright what to do before running the tests - mainly starting your application at a certain port. For example:
playwright.config
```
const ```
const config: {
    webServer: {
        command: string;
        port: number;
    };
    testDir: string;
    testMatch: RegExp;
}
```
`config = { ````
webServer: {
    command: string;
    port: number;
}
```
`webServer: { `command: string`command: 'npm run build && npm run preview', `port: number`port: 4173 }, `testDir: string`testDir: 'tests', `testMatch: RegExp`testMatch: /(.+\\.)?(test|spec)\\.[jt]s/ }; export default ````
const config: {
    webServer: {
        command: string;
        port: number;
    };
    testDir: string;
    testMatch: RegExp;
}
```
`config;`
```

You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.
tests/hello-world.spec
```
import { import expectexpect, import testtest } from '@playwright/test';

import testtest('home page has expected h1', async ({ page }) => {
	await page: anypage.goto('/');
	await import expectexpect(page: anypage.locator('h1')).toBeVisible();
});
```

Edit this page on GitHub llms.txt
previous next
Imperative component API TypeScript
Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use — you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.
##  Unit and integration testing using Vitest
Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you’re using Vite (including via SvelteKit), we recommend using Vitest. You can use the Svelte CLI to setup Vitest either during project creation or later on.
To setup Vitest manually, first install it:
```
npm install -D vitest
```

Then adjust your `vite.config.js`:
vite.config
```
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig } from 'vitest/config';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig({
	// ...
	// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node
	```
UserConfig.resolve?: (ResolveOptions & {
    alias?: AliasOptions;
}) | undefined
```
`
Configure resolver
resolve: `var process: NodeJS.Process`process.`NodeJS.Process.env: NodeJS.ProcessEnv`
The `process.env` property returns an object containing the user environment. See `environ(7)`.
An example of this object looks like:
```
{
  TERM: 'xterm-256color',
  SHELL: '/usr/local/bin/bash',
  USER: 'maciej',
  PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
  PWD: '/Users/maciej',
  EDITOR: 'vim',
  SHLVL: '1',
  HOME: '/Users/maciej',
  LOGNAME: 'maciej',
  _: '/usr/local/bin/node'
}
```

It is possible to modify this object, but such modifications will not be reflected outside the Node.js process, or (unless explicitly requested) to other `Worker` threads. In other words, the following example would not work:
```
node -e 'process.env.foo = "bar"' &#x26;#x26;&#x26;#x26; echo $foo
```

While the following will:
```
import { env } from 'node:process';

env.foo = 'bar';
console.log(env.foo);
```

Assigning a property on `process.env` will implicitly convert the value to a string. **This behavior is deprecated.** Future versions of Node.js may throw an error when the value is not a string, number, or boolean.
```
import { env } from 'node:process';

env.test = null;
console.log(env.test);
// => 'null'
env.test = undefined;
console.log(env.test);
// => 'undefined'
```

Use `delete` to delete a property from `process.env`.
```
import { env } from 'node:process';

env.TEST = 1;
delete env.TEST;
console.log(env.TEST);
// => undefined
```

On Windows operating systems, environment variables are case-insensitive.
```
import { env } from 'node:process';

env.TEST = 1;
console.log(env.test);
// => 1
```

Unless explicitly specified when creating a `Worker` instance, each `Worker` thread has its own copy of `process.env`, based on its parent thread’s `process.env`, or whatever was specified as the `env` option to the `Worker` constructor. Changes to `process.env` will not be visible across `Worker` threads, and only the main thread can make changes that are visible to the operating system or to native add-ons. On Windows, a copy of `process.env` on a `Worker` instance operates in a case-sensitive manner unlike the main thread.
@sincev0.1.27
env.`string | undefined`VITEST ? { `ResolveOptions.conditions?: string[] | undefined`conditions: ['browser'] } : `var undefined`undefined });`
```

> If loading the browser version of all your packages is undesirable, because (for example) you also test backend libraries, you may need to resort to an alias configuration
You can now write unit tests for code inside your `.js/.ts` files:
multiplier.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import multipliermultiplier } from './multiplier.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Multiplier', () => {
	let let double: anydouble = import multipliermultiplier(0, 2);

	expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)expect(let double: anydouble.value).JestAssertion<any>.toEqual: <number>(expected: number) => void


Used when you want to check that two objects have the same value.
This matcher recursively checks the equality of all fields, rather than checking for object identity.





@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });

toEqual(0);

	let double: anydouble.set(5);

	expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)expect(let double: anydouble.value).JestAssertion<any>.toEqual: <number>(expected: number) => void


Used when you want to check that two objects have the same value.
This matcher recursively checks the equality of all fields, rather than checking for object identity.





@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });

toEqual(10);
});
```

multiplier.svelte
```
/**
 * @param {number} initial
 * @param {number} k
 */
export function ```
function multiplier(initial: number, k: number): {
    readonly value: number;
    set: (c: number) => void;
}
```
`
@paraminitial
@paramk
multiplier(`initial: number`
@paraminitial
initial, `k: number`
@paramk
k) { let `let count: number`count = ````
function $state<number>(initial: number): number (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(`initial: number`
@paraminitial
initial); return { get `value: number`value() { return `let count: number`count * `k: number`
@paramk
k; }, /** @param {number} c */ `set: (c: number) => void`
@paramc
set: (`c: number`
@paramc
c) => { `let count: number`count = `c: number`
@paramc
c; } }; }`
```
```
export function ```
function multiplier(initial: number, k: number): {
    readonly value: number;
    set: (c: number) => void;
}
```
`multiplier(`initial: number`initial: number, `k: number`k: number) { let `let count: number`count = ````
function $state<number>(initial: number): number (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(`initial: number`initial); return { get `value: number`value() { return `let count: number`count * `k: number`k; }, `set: (c: number) => void`set: (`c: number`c: number) => { `let count: number`count = `c: number`c; } }; }`
```

###  Using runes inside your test files
Since Vitest processes your test files the same way as your source files, you can use runes inside your tests as long as the filename includes `.svelte`:
multiplier.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import multipliermultiplier } from './multiplier.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Multiplier', () => {
	let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); let `let double: any`double = `import multiplier`multiplier(() => `let count: number`count, 2); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let double: any`double.value).`JestAssertion<any>.toEqual: <number>(expected: number) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual(0); `let count: number`count = 5; `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let double: any`double.value).`JestAssertion<any>.toEqual: <number>(expected: number) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual(10); });`
```

multiplier.svelte
```
/**
 * @param {() => number} getCount
 * @param {number} k
 */
export function ```
function multiplier(getCount: () => number, k: number): {
    readonly value: number;
}
```
`
@paramgetCount
@paramk
multiplier(`getCount: () => number`
@paramgetCount
getCount, `k: number`
@paramk
k) { return { get `value: number`value() { return `getCount: () => number`
@paramgetCount
getCount() * `k: number`
@paramk
k; } }; }`
```
```
export function ```
function multiplier(getCount: () => number, k: number): {
    readonly value: number;
}
```
`multiplier(`getCount: () => number`getCount: () => number, `k: number`k: number) { return { get `value: number`value() { return `getCount: () => number`getCount() * `k: number`k; } }; }`
```

If the code being tested uses effects, you need to wrap the test inside `$effect.root`:
logger.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import loggerlogger } from './logger.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Effect', () => {
	const const cleanup: () => voidcleanup = ```
namespace $effect
function $effect(fn: () => void | (() => void)): void
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect.`function $effect.root(fn: () => void | (() => void)): () => void`
The `$effect.root` rune is an advanced feature that creates a non-tracked scope that doesn’t auto-cleanup. This is useful for nested effects that you want to manually control. This rune also allows for creation of effects outside of the component initialisation phase.
Example:
```
&#x3C;script>
  let count = $state(0);

  const cleanup = $effect.root(() => {
	$effect(() => {
			console.log(count);
		})

	 return () => {
	   console.log('effect root cleanup');
			}
  });
&#x3C;/script>

&#x3C;button onclick={() => cleanup()}>cleanup&#x3C;/button>
```

https://svelte.dev/docs/svelte/$effect#$effect.root
root(() => { let `let count: number`count = ````
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); // logger uses an $effect to log updates of its input let `let log: any`log = `import logger`logger(() => `let count: number`count); // effects normally run after a microtask, // use flushSync to execute all pending effects synchronously `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let log: any`log.value).`JestAssertion<any>.toEqual: <number[]>(expected: number[]) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual([0]); `let count: number`count = 1; `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let log: any`log.value).`JestAssertion<any>.toEqual: <number[]>(expected: number[]) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual([0, 1]); }); `const cleanup: () => void`cleanup(); });`
```

logger.svelte
```
/**
 * @param {() => any} getValue
 */
export function ```
function logger(getValue: () => any): {
    readonly value: any[];
}
```
`
@paramgetValue
logger(`getValue: () => any`
@paramgetValue
getValue) { /** @type {any[]} */ let `let log: any[]`
@type{any[]}
log = ````
function $state<never[]>(initial: never[]): never[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([]); ````
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { `let log: any[]`
@type{any[]}
log.`Array<any>.push(...items: any[]): number`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push(`getValue: () => any`
@paramgetValue
getValue()); }); return { get `value: any[]`value() { return `let log: any[]`
@type{any[]}
log; } }; }`
```
```
export function ```
function logger(getValue: () => any): {
    readonly value: any[];
}
```
`logger(`getValue: () => any`getValue: () => any) { let `let log: any[]`log: any[] = ````
function $state<never[]>(initial: never[]): never[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([]); ````
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { `let log: any[]`log.`Array<any>.push(...items: any[]): number`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push(`getValue: () => any`getValue()); }); return { get `value: any[]`value() { return `let log: any[]`log; } }; }`
```

###  Component testing
It is possible to test your components in isolation using Vitest.
> Before writing component tests, think about whether you actually need to test the component, or if it’s more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component
To get started, install jsdom (a library that shims DOM APIs):
```
npm install -D jsdom
```

Then adjust your `vite.config.js`:
vite.config
```
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig } from 'vitest/config';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig({
	UserConfig.plugins?: PluginOption[] | undefined


Array of vite plugins to use.


plugins: [
		/* ... */
	],
	UserConfig.test?: InlineConfig | undefined


Options for Vitest


test: {
		// If you are testing components client-side, you need to setup a DOM environment.
		// If not all your files should have this environment, you can use a
		// `// @vitest-environment jsdom` comment at the top of the test files instead.
		InlineConfig.environment?: VitestEnvironment | undefined


Running environment


Supports ‘node’, ‘jsdom’, ‘happy-dom’, ‘edge-runtime’


If used unsupported string, will try to load the package vitest-environment-${env}





@default'node'

environment: 'jsdom'
	},
	// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node
	```
UserConfig.resolve?: (ResolveOptions & {
    alias?: AliasOptions;
}) | undefined
```
`
Configure resolver
resolve: `var process: NodeJS.Process`process.`NodeJS.Process.env: NodeJS.ProcessEnv`
The `process.env` property returns an object containing the user environment. See `environ(7)`.
An example of this object looks like:
```
{
  TERM: 'xterm-256color',
  SHELL: '/usr/local/bin/bash',
  USER: 'maciej',
  PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
  PWD: '/Users/maciej',
  EDITOR: 'vim',
  SHLVL: '1',
  HOME: '/Users/maciej',
  LOGNAME: 'maciej',
  _: '/usr/local/bin/node'
}
```

It is possible to modify this object, but such modifications will not be reflected outside the Node.js process, or (unless explicitly requested) to other `Worker` threads. In other words, the following example would not work:
```
node -e 'process.env.foo = "bar"' &#x26;#x26;&#x26;#x26; echo $foo
```

While the following will:
```
import { env } from 'node:process';

env.foo = 'bar';
console.log(env.foo);
```

Assigning a property on `process.env` will implicitly convert the value to a string. **This behavior is deprecated.** Future versions of Node.js may throw an error when the value is not a string, number, or boolean.
```
import { env } from 'node:process';

env.test = null;
console.log(env.test);
// => 'null'
env.test = undefined;
console.log(env.test);
// => 'undefined'
```

Use `delete` to delete a property from `process.env`.
```
import { env } from 'node:process';

env.TEST = 1;
delete env.TEST;
console.log(env.TEST);
// => undefined
```

On Windows operating systems, environment variables are case-insensitive.
```
import { env } from 'node:process';

env.TEST = 1;
console.log(env.test);
// => 1
```

Unless explicitly specified when creating a `Worker` instance, each `Worker` thread has its own copy of `process.env`, based on its parent thread’s `process.env`, or whatever was specified as the `env` option to the `Worker` constructor. Changes to `process.env` will not be visible across `Worker` threads, and only the main thread can make changes that are visible to the operating system or to native add-ons. On Windows, a copy of `process.env` on a `Worker` instance operates in a case-sensitive manner unlike the main thread.
@sincev0.1.27
env.`string | undefined`VITEST ? { `ResolveOptions.conditions?: string[] | undefined`conditions: ['browser'] } : `var undefined`undefined });`
```

After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:
component.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync, function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.


mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import { `const expect: ExpectStatic`expect, `const test: TestAPI`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test } from 'vitest'; import ````
type Component = SvelteComponent<Record<string, any>, any, any>
const Component: LegacyComponentType
```
`Component from './Component.svelte'; `test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test('Component', () => { // Instantiate the component using Svelte's `mount` API const ````
const component: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`component = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const Component: LegacyComponentType`Component, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body, // `document` exists because of jsdom `props?: Record<string, any> | undefined`
Component properties.
props: { `initial: number`initial: 0 } }); `expect<string>(actual: string, message?: string): Assertion<string> (+1 overload)`expect(`var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML).`JestAssertion<string>.toBe: <string>(expected: string) => void`
Checks that a value is what you expect. It calls `Object.is` to compare values. Don’t use `toBe` with floating-point numbers.
@exampleexpect(result).toBe(42); expect(status).toBe(true);
toBe('<button>0</button>'); // Click the button, then flush the changes so you can synchronously write expectations `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`ParentNode.querySelector<"button">(selectors: "button"): HTMLButtonElement | null (+4 overloads)`
Returns the first element that is a descendant of node that matches selectors.
MDN Reference
querySelector('button').`HTMLElement.click(): void`
MDN Reference
click(); `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<string>(actual: string, message?: string): Assertion<string> (+1 overload)`expect(`var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML).`JestAssertion<string>.toBe: <string>(expected: string) => void`
Checks that a value is what you expect. It calls `Object.is` to compare values. Don’t use `toBe` with floating-point numbers.
@exampleexpect(result).toBe(42); expect(status).toBe(true);
toBe('<button>1</button>'); // Remove the component from the DOM ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const component: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`component); });`
```

While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like @testing-library/svelte can help streamline your tests. The above test could be rewritten like this:
component.test
```
import { function render<C extends unknown, Q extends Queries = typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>(Component: ComponentType<...>, options?: SvelteComponentOptions<C>, renderOptions?: RenderOptions<Q>): RenderResult<C, Q>


Render a component into the document.







@template{import('./component-types.js').Component} C




@template{import('@testing-library/dom').Queries} [Q=typeof import('@testing-library/dom').queries]




@paramComponent - The component to render.




@paramoptions - Customize how Svelte renders the component.




@paramrenderOptions - Customize how Testing Library sets up the document and binds queries.




@returnsThe rendered component and bound testing functions.



render, const screen: Screen<typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>screen } from '@testing-library/svelte';
import ```
const userEvent: {
    readonly setup: typeof setupMain;
    readonly clear: typeof clear;
    readonly click: typeof click;
    readonly copy: typeof copy;
    ... 12 more ...;
    readonly tab: typeof tab;
}
```
`userEvent from '@testing-library/user-event'; import { `const expect: ExpectStatic`expect, `const test: TestAPI`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test } from 'vitest'; import ````
type Component = SvelteComponent<Record<string, any>, any, any>
const Component: LegacyComponentType
```
`Component from './Component.svelte'; `test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test('Component', async () => { const `const user: UserEvent`user = ````
const userEvent: {
    readonly setup: typeof setupMain;
    readonly clear: typeof clear;
    readonly click: typeof click;
    readonly copy: typeof copy;
    ... 12 more ...;
    readonly tab: typeof tab;
}
```
`userEvent.`setup: (options?: Options) => UserEvent`
Start a “session” with userEvent. All APIs returned by this function share an input device state and a default configuration.
setup(); `render<SvelteComponent<Record<string, any>, any, any>, typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>(Component: ComponentType<...>, options?: SvelteComponentOptions<...> | undefined, renderOptions?: RenderOptions<...> | undefined): RenderResult<...>`
Render a component into the document.
@template{import('./component-types.js').Component} C
@template{import('@testing-library/dom').Queries} [Q=typeof import('@testing-library/dom').queries]
@paramComponent - The component to render.
@paramoptions - Customize how Svelte renders the component.
@paramrenderOptions - Customize how Testing Library sets up the document and binds queries.
@returnsThe rendered component and bound testing functions.
render(`const Component: LegacyComponentType`Component); const `const button: HTMLElement`button = `const screen: Screen<typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>`screen.`getByRole<HTMLElement>(role: ByRoleMatcher, options?: ByRoleOptions | undefined): HTMLElement (+1 overload)`getByRole('button'); `expect<HTMLElement>(actual: HTMLElement, message?: string): Assertion<HTMLElement> (+1 overload)`expect(`const button: HTMLElement`button).toHaveTextContent(0); await `const user: UserEvent`user.`click: (element: Element) => Promise<void>`click(`const button: HTMLElement`button); `expect<HTMLElement>(actual: HTMLElement, message?: string): Assertion<HTMLElement> (+1 overload)`expect(`const button: HTMLElement`button).toHaveTextContent(1); });`
```

When writing component tests that involve two-way bindings, context or snippet props, it’s best to create a wrapper component for your specific test and interact with that. `@testing-library/svelte` contains some examples.
##  E2E tests using Playwright
E2E (short for ‘end to end’) tests allow you to test your full application through the eyes of the user. This section uses Playwright as an example, but you can also use other solutions like Cypress or NightwatchJS.
You can use the Svelte CLI to setup Playwright either during project creation or later on. You can also set it up with `npm init playwright`. Additionally, you may also want to install an IDE plugin such as the VS Code extension to be able to execute tests from inside your IDE.
If you’ve run `npm init playwright` or are not using Vite, you may need to adjust the Playwright config to tell Playwright what to do before running the tests - mainly starting your application at a certain port. For example:
playwright.config
```
const ```
const config: {
    webServer: {
        command: string;
        port: number;
    };
    testDir: string;
    testMatch: RegExp;
}
```
`config = { ````
webServer: {
    command: string;
    port: number;
}
```
`webServer: { `command: string`command: 'npm run build && npm run preview', `port: number`port: 4173 }, `testDir: string`testDir: 'tests', `testMatch: RegExp`testMatch: /(.+\\.)?(test|spec)\\.[jt]s/ }; export default ````
const config: {
    webServer: {
        command: string;
        port: number;
    };
    testDir: string;
    testMatch: RegExp;
}
```
`config;`
```

You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.
tests/hello-world.spec
```
import { import expectexpect, import testtest } from '@playwright/test';

import testtest('home page has expected h1', async ({ page }) => {
	await page: anypage.goto('/');
	await import expectexpect(page: anypage.locator('h1')).toBeVisible();
});
```

Edit this page on GitHub llms.txt
previous next
Imperative component API TypeScript
Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use — you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.
##  Unit and integration testing using Vitest
Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you’re using Vite (including via SvelteKit), we recommend using Vitest. You can use the Svelte CLI to setup Vitest either during project creation or later on.
To setup Vitest manually, first install it:
```
npm install -D vitest
```

Then adjust your `vite.config.js`:
vite.config
```
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig } from 'vitest/config';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig({
	// ...
	// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node
	```
UserConfig.resolve?: (ResolveOptions & {
    alias?: AliasOptions;
}) | undefined
```
`
Configure resolver
resolve: `var process: NodeJS.Process`process.`NodeJS.Process.env: NodeJS.ProcessEnv`
The `process.env` property returns an object containing the user environment. See `environ(7)`.
An example of this object looks like:
```
{
  TERM: 'xterm-256color',
  SHELL: '/usr/local/bin/bash',
  USER: 'maciej',
  PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
  PWD: '/Users/maciej',
  EDITOR: 'vim',
  SHLVL: '1',
  HOME: '/Users/maciej',
  LOGNAME: 'maciej',
  _: '/usr/local/bin/node'
}
```

It is possible to modify this object, but such modifications will not be reflected outside the Node.js process, or (unless explicitly requested) to other `Worker` threads. In other words, the following example would not work:
```
node -e 'process.env.foo = "bar"' &#x26;#x26;&#x26;#x26; echo $foo
```

While the following will:
```
import { env } from 'node:process';

env.foo = 'bar';
console.log(env.foo);
```

Assigning a property on `process.env` will implicitly convert the value to a string. **This behavior is deprecated.** Future versions of Node.js may throw an error when the value is not a string, number, or boolean.
```
import { env } from 'node:process';

env.test = null;
console.log(env.test);
// => 'null'
env.test = undefined;
console.log(env.test);
// => 'undefined'
```

Use `delete` to delete a property from `process.env`.
```
import { env } from 'node:process';

env.TEST = 1;
delete env.TEST;
console.log(env.TEST);
// => undefined
```

On Windows operating systems, environment variables are case-insensitive.
```
import { env } from 'node:process';

env.TEST = 1;
console.log(env.test);
// => 1
```

Unless explicitly specified when creating a `Worker` instance, each `Worker` thread has its own copy of `process.env`, based on its parent thread’s `process.env`, or whatever was specified as the `env` option to the `Worker` constructor. Changes to `process.env` will not be visible across `Worker` threads, and only the main thread can make changes that are visible to the operating system or to native add-ons. On Windows, a copy of `process.env` on a `Worker` instance operates in a case-sensitive manner unlike the main thread.
@sincev0.1.27
env.`string | undefined`VITEST ? { `ResolveOptions.conditions?: string[] | undefined`conditions: ['browser'] } : `var undefined`undefined });`
```

> If loading the browser version of all your packages is undesirable, because (for example) you also test backend libraries, you may need to resort to an alias configuration
You can now write unit tests for code inside your `.js/.ts` files:
multiplier.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import multipliermultiplier } from './multiplier.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Multiplier', () => {
	let let double: anydouble = import multipliermultiplier(0, 2);

	expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)expect(let double: anydouble.value).JestAssertion<any>.toEqual: <number>(expected: number) => void


Used when you want to check that two objects have the same value.
This matcher recursively checks the equality of all fields, rather than checking for object identity.





@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });

toEqual(0);

	let double: anydouble.set(5);

	expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)expect(let double: anydouble.value).JestAssertion<any>.toEqual: <number>(expected: number) => void


Used when you want to check that two objects have the same value.
This matcher recursively checks the equality of all fields, rather than checking for object identity.





@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });

toEqual(10);
});
```

multiplier.svelte
```
/**
 * @param {number} initial
 * @param {number} k
 */
export function ```
function multiplier(initial: number, k: number): {
    readonly value: number;
    set: (c: number) => void;
}
```
`
@paraminitial
@paramk
multiplier(`initial: number`
@paraminitial
initial, `k: number`
@paramk
k) { let `let count: number`count = ````
function $state<number>(initial: number): number (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(`initial: number`
@paraminitial
initial); return { get `value: number`value() { return `let count: number`count * `k: number`
@paramk
k; }, /** @param {number} c */ `set: (c: number) => void`
@paramc
set: (`c: number`
@paramc
c) => { `let count: number`count = `c: number`
@paramc
c; } }; }`
```
```
export function ```
function multiplier(initial: number, k: number): {
    readonly value: number;
    set: (c: number) => void;
}
```
`multiplier(`initial: number`initial: number, `k: number`k: number) { let `let count: number`count = ````
function $state<number>(initial: number): number (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(`initial: number`initial); return { get `value: number`value() { return `let count: number`count * `k: number`k; }, `set: (c: number) => void`set: (`c: number`c: number) => { `let count: number`count = `c: number`c; } }; }`
```

###  Using runes inside your test files
Since Vitest processes your test files the same way as your source files, you can use runes inside your tests as long as the filename includes `.svelte`:
multiplier.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import multipliermultiplier } from './multiplier.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Multiplier', () => {
	let let count: numbercount = ```
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); let `let double: any`double = `import multiplier`multiplier(() => `let count: number`count, 2); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let double: any`double.value).`JestAssertion<any>.toEqual: <number>(expected: number) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual(0); `let count: number`count = 5; `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let double: any`double.value).`JestAssertion<any>.toEqual: <number>(expected: number) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual(10); });`
```

multiplier.svelte
```
/**
 * @param {() => number} getCount
 * @param {number} k
 */
export function ```
function multiplier(getCount: () => number, k: number): {
    readonly value: number;
}
```
`
@paramgetCount
@paramk
multiplier(`getCount: () => number`
@paramgetCount
getCount, `k: number`
@paramk
k) { return { get `value: number`value() { return `getCount: () => number`
@paramgetCount
getCount() * `k: number`
@paramk
k; } }; }`
```
```
export function ```
function multiplier(getCount: () => number, k: number): {
    readonly value: number;
}
```
`multiplier(`getCount: () => number`getCount: () => number, `k: number`k: number) { return { get `value: number`value() { return `getCount: () => number`getCount() * `k: number`k; } }; }`
```

If the code being tested uses effects, you need to wrap the test inside `$effect.root`:
logger.svelte.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync } from 'svelte';
import { const expect: ExpectStaticexpect, const test: TestAPI


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test } from 'vitest';
import { import loggerlogger } from './logger.svelte.js';

test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)


Defines a test case with a given name and test function. The test function can optionally be configured with test options.







@paramname - The name of the test or a function that will be used as a test name.




@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.




@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.




@throwsError If called inside another test function.




@examplets // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); 




@examplets // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); 



test('Effect', () => {
	const const cleanup: () => voidcleanup = ```
namespace $effect
function $effect(fn: () => void | (() => void)): void
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect.`function $effect.root(fn: () => void | (() => void)): () => void`
The `$effect.root` rune is an advanced feature that creates a non-tracked scope that doesn’t auto-cleanup. This is useful for nested effects that you want to manually control. This rune also allows for creation of effects outside of the component initialisation phase.
Example:
```
&#x3C;script>
  let count = $state(0);

  const cleanup = $effect.root(() => {
	$effect(() => {
			console.log(count);
		})

	 return () => {
	   console.log('effect root cleanup');
			}
  });
&#x3C;/script>

&#x3C;button onclick={() => cleanup()}>cleanup&#x3C;/button>
```

https://svelte.dev/docs/svelte/$effect#$effect.root
root(() => { let `let count: number`count = ````
function $state<0>(initial: 0): 0 (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state(0); // logger uses an $effect to log updates of its input let `let log: any`log = `import logger`logger(() => `let count: number`count); // effects normally run after a microtask, // use flushSync to execute all pending effects synchronously `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let log: any`log.value).`JestAssertion<any>.toEqual: <number[]>(expected: number[]) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual([0]); `let count: number`count = 1; `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<any>(actual: any, message?: string): Assertion<any> (+1 overload)`expect(`let log: any`log.value).`JestAssertion<any>.toEqual: <number[]>(expected: number[]) => void`
Used when you want to check that two objects have the same value. This matcher recursively checks the equality of all fields, rather than checking for object identity.
@exampleexpect(user).toEqual({ name: 'Alice', age: 30 });
toEqual([0, 1]); }); `const cleanup: () => void`cleanup(); });`
```

logger.svelte
```
/**
 * @param {() => any} getValue
 */
export function ```
function logger(getValue: () => any): {
    readonly value: any[];
}
```
`
@paramgetValue
logger(`getValue: () => any`
@paramgetValue
getValue) { /** @type {any[]} */ let `let log: any[]`
@type{any[]}
log = ````
function $state<never[]>(initial: never[]): never[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([]); ````
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { `let log: any[]`
@type{any[]}
log.`Array<any>.push(...items: any[]): number`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push(`getValue: () => any`
@paramgetValue
getValue()); }); return { get `value: any[]`value() { return `let log: any[]`
@type{any[]}
log; } }; }`
```
```
export function ```
function logger(getValue: () => any): {
    readonly value: any[];
}
```
`logger(`getValue: () => any`getValue: () => any) { let `let log: any[]`log: any[] = ````
function $state<never[]>(initial: never[]): never[] (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state([]); ````
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { `let log: any[]`log.`Array<any>.push(...items: any[]): number`
Appends new elements to the end of an array, and returns the new length of the array.
@paramitems New elements to add to the array.
push(`getValue: () => any`getValue()); }); return { get `value: any[]`value() { return `let log: any[]`log; } }; }`
```

###  Component testing
It is possible to test your components in isolation using Vitest.
> Before writing component tests, think about whether you actually need to test the component, or if it’s more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component
To get started, install jsdom (a library that shims DOM APIs):
```
npm install -D jsdom
```

Then adjust your `vite.config.js`:
vite.config
```
import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig } from 'vitest/config';

export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)defineConfig({
	UserConfig.plugins?: PluginOption[] | undefined


Array of vite plugins to use.


plugins: [
		/* ... */
	],
	UserConfig.test?: InlineConfig | undefined


Options for Vitest


test: {
		// If you are testing components client-side, you need to setup a DOM environment.
		// If not all your files should have this environment, you can use a
		// `// @vitest-environment jsdom` comment at the top of the test files instead.
		InlineConfig.environment?: VitestEnvironment | undefined


Running environment


Supports ‘node’, ‘jsdom’, ‘happy-dom’, ‘edge-runtime’


If used unsupported string, will try to load the package vitest-environment-${env}





@default'node'

environment: 'jsdom'
	},
	// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node
	```
UserConfig.resolve?: (ResolveOptions & {
    alias?: AliasOptions;
}) | undefined
```
`
Configure resolver
resolve: `var process: NodeJS.Process`process.`NodeJS.Process.env: NodeJS.ProcessEnv`
The `process.env` property returns an object containing the user environment. See `environ(7)`.
An example of this object looks like:
```
{
  TERM: 'xterm-256color',
  SHELL: '/usr/local/bin/bash',
  USER: 'maciej',
  PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
  PWD: '/Users/maciej',
  EDITOR: 'vim',
  SHLVL: '1',
  HOME: '/Users/maciej',
  LOGNAME: 'maciej',
  _: '/usr/local/bin/node'
}
```

It is possible to modify this object, but such modifications will not be reflected outside the Node.js process, or (unless explicitly requested) to other `Worker` threads. In other words, the following example would not work:
```
node -e 'process.env.foo = "bar"' &#x26;#x26;&#x26;#x26; echo $foo
```

While the following will:
```
import { env } from 'node:process';

env.foo = 'bar';
console.log(env.foo);
```

Assigning a property on `process.env` will implicitly convert the value to a string. **This behavior is deprecated.** Future versions of Node.js may throw an error when the value is not a string, number, or boolean.
```
import { env } from 'node:process';

env.test = null;
console.log(env.test);
// => 'null'
env.test = undefined;
console.log(env.test);
// => 'undefined'
```

Use `delete` to delete a property from `process.env`.
```
import { env } from 'node:process';

env.TEST = 1;
delete env.TEST;
console.log(env.TEST);
// => undefined
```

On Windows operating systems, environment variables are case-insensitive.
```
import { env } from 'node:process';

env.TEST = 1;
console.log(env.test);
// => 1
```

Unless explicitly specified when creating a `Worker` instance, each `Worker` thread has its own copy of `process.env`, based on its parent thread’s `process.env`, or whatever was specified as the `env` option to the `Worker` constructor. Changes to `process.env` will not be visible across `Worker` threads, and only the main thread can make changes that are visible to the operating system or to native add-ons. On Windows, a copy of `process.env` on a `Worker` instance operates in a case-sensitive manner unlike the main thread.
@sincev0.1.27
env.`string | undefined`VITEST ? { `ResolveOptions.conditions?: string[] | undefined`conditions: ['browser'] } : `var undefined`undefined });`
```

After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:
component.test
```
import { function flushSync<T = void>(fn?: (() => T) | undefined): T


Synchronously flush any pending updates.
Returns void if no callback is provided, otherwise returns the result of calling the callback.


flushSync, function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.


mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import { `const expect: ExpectStatic`expect, `const test: TestAPI`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test } from 'vitest'; import ````
type Component = SvelteComponent<Record<string, any>, any, any>
const Component: LegacyComponentType
```
`Component from './Component.svelte'; `test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test('Component', () => { // Instantiate the component using Svelte's `mount` API const ````
const component: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`component = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const Component: LegacyComponentType`Component, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body, // `document` exists because of jsdom `props?: Record<string, any> | undefined`
Component properties.
props: { `initial: number`initial: 0 } }); `expect<string>(actual: string, message?: string): Assertion<string> (+1 overload)`expect(`var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML).`JestAssertion<string>.toBe: <string>(expected: string) => void`
Checks that a value is what you expect. It calls `Object.is` to compare values. Don’t use `toBe` with floating-point numbers.
@exampleexpect(result).toBe(42); expect(status).toBe(true);
toBe('<button>0</button>'); // Click the button, then flush the changes so you can synchronously write expectations `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`ParentNode.querySelector<"button">(selectors: "button"): HTMLButtonElement | null (+4 overloads)`
Returns the first element that is a descendant of node that matches selectors.
MDN Reference
querySelector('button').`HTMLElement.click(): void`
MDN Reference
click(); `flushSync<void>(fn?: (() => void) | undefined): void`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync(); `expect<string>(actual: string, message?: string): Assertion<string> (+1 overload)`expect(`var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body.`InnerHTML.innerHTML: string`
MDN Reference
innerHTML).`JestAssertion<string>.toBe: <string>(expected: string) => void`
Checks that a value is what you expect. It calls `Object.is` to compare values. Don’t use `toBe` with floating-point numbers.
@exampleexpect(result).toBe(42); expect(status).toBe(true);
toBe('<button>1</button>'); // Remove the component from the DOM ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const component: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`component); });`
```

While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like @testing-library/svelte can help streamline your tests. The above test could be rewritten like this:
component.test
```
import { function render<C extends unknown, Q extends Queries = typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>(Component: ComponentType<...>, options?: SvelteComponentOptions<C>, renderOptions?: RenderOptions<Q>): RenderResult<C, Q>


Render a component into the document.







@template{import('./component-types.js').Component} C




@template{import('@testing-library/dom').Queries} [Q=typeof import('@testing-library/dom').queries]




@paramComponent - The component to render.




@paramoptions - Customize how Svelte renders the component.




@paramrenderOptions - Customize how Testing Library sets up the document and binds queries.




@returnsThe rendered component and bound testing functions.



render, const screen: Screen<typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>screen } from '@testing-library/svelte';
import ```
const userEvent: {
    readonly setup: typeof setupMain;
    readonly clear: typeof clear;
    readonly click: typeof click;
    readonly copy: typeof copy;
    ... 12 more ...;
    readonly tab: typeof tab;
}
```
`userEvent from '@testing-library/user-event'; import { `const expect: ExpectStatic`expect, `const test: TestAPI`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test } from 'vitest'; import ````
type Component = SvelteComponent<Record<string, any>, any, any>
const Component: LegacyComponentType
```
`Component from './Component.svelte'; `test<object>(name: string | Function, fn?: TestFunction<object> | undefined, options?: number | TestOptions): void (+2 overloads)`
Defines a test case with a given name and test function. The test function can optionally be configured with test options.
@paramname - The name of the test or a function that will be used as a test name.
@paramoptionsOrFn - Optional. The test options or the test function if no explicit name is provided.
@paramoptionsOrTest - Optional. The test function or options, depending on the previous parameters.
@throwsError If called inside another test function.
@example`ts // Define a simple test test('should add two numbers', () => {   expect(add(1, 2)).toBe(3); }); `
@example`ts // Define a test with options test('should subtract two numbers', { retry: 3 }, () => {   expect(subtract(5, 2)).toBe(3); }); `
test('Component', async () => { const `const user: UserEvent`user = ````
const userEvent: {
    readonly setup: typeof setupMain;
    readonly clear: typeof clear;
    readonly click: typeof click;
    readonly copy: typeof copy;
    ... 12 more ...;
    readonly tab: typeof tab;
}
```
`userEvent.`setup: (options?: Options) => UserEvent`
Start a “session” with userEvent. All APIs returned by this function share an input device state and a default configuration.
setup(); `render<SvelteComponent<Record<string, any>, any, any>, typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>(Component: ComponentType<...>, options?: SvelteComponentOptions<...> | undefined, renderOptions?: RenderOptions<...> | undefined): RenderResult<...>`
Render a component into the document.
@template{import('./component-types.js').Component} C
@template{import('@testing-library/dom').Queries} [Q=typeof import('@testing-library/dom').queries]
@paramComponent - The component to render.
@paramoptions - Customize how Svelte renders the component.
@paramrenderOptions - Customize how Testing Library sets up the document and binds queries.
@returnsThe rendered component and bound testing functions.
render(`const Component: LegacyComponentType`Component); const `const button: HTMLElement`button = `const screen: Screen<typeof import("/vercel/path0/node_modules/.pnpm/@testing-library+dom@10.4.0/node_modules/@testing-library/dom/types/queries")>`screen.`getByRole<HTMLElement>(role: ByRoleMatcher, options?: ByRoleOptions | undefined): HTMLElement (+1 overload)`getByRole('button'); `expect<HTMLElement>(actual: HTMLElement, message?: string): Assertion<HTMLElement> (+1 overload)`expect(`const button: HTMLElement`button).toHaveTextContent(0); await `const user: UserEvent`user.`click: (element: Element) => Promise<void>`click(`const button: HTMLElement`button); `expect<HTMLElement>(actual: HTMLElement, message?: string): Assertion<HTMLElement> (+1 overload)`expect(`const button: HTMLElement`button).toHaveTextContent(1); });`
```

When writing component tests that involve two-way bindings, context or snippet props, it’s best to create a wrapper component for your specific test and interact with that. `@testing-library/svelte` contains some examples.
##  E2E tests using Playwright
E2E (short for ‘end to end’) tests allow you to test your full application through the eyes of the user. This section uses Playwright as an example, but you can also use other solutions like Cypress or NightwatchJS.
You can use the Svelte CLI to setup Playwright either during project creation or later on. You can also set it up with `npm init playwright`. Additionally, you may also want to install an IDE plugin such as the VS Code extension to be able to execute tests from inside your IDE.
If you’ve run `npm init playwright` or are not using Vite, you may need to adjust the Playwright config to tell Playwright what to do before running the tests - mainly starting your application at a certain port. For example:
playwright.config
```
const ```
const config: {
    webServer: {
        command: string;
        port: number;
    };
    testDir: string;
    testMatch: RegExp;
}
```
`config = { ````
webServer: {
    command: string;
    port: number;
}
```
`webServer: { `command: string`command: 'npm run build && npm run preview', `port: number`port: 4173 }, `testDir: string`testDir: 'tests', `testMatch: RegExp`testMatch: /(.+\\.)?(test|spec)\\.[jt]s/ }; export default ````
const config: {
    webServer: {
        command: string;
        port: number;
    };
    testDir: string;
    testMatch: RegExp;
}
```
`config;`
```

You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.
tests/hello-world.spec
```
import { import expectexpect, import testtest } from '@playwright/test';

import testtest('home page has expected h1', async ({ page }) => {
	await page: anypage.goto('/');
	await import expectexpect(page: anypage.locator('h1')).toBeVisible();
});
```



---

In runes mode, event handlers are just like any other attribute or prop.
In legacy mode, we use the `on:` directive:
App
```
<script>
	let count = 0;

	/** @param {MouseEvent} event */
	function handleClick(event) {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	count: {count}
</button>
```
```
<script lang="ts">
	let count = 0;

	function handleClick(event: MouseEvent) {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	count: {count}
</button>
```

Handlers can be declared inline with no performance penalty:
```
<button on:click={() => (count += 1)}>
	count: {count}
</button>
```

Add _modifiers_ to element event handlers with the `|` character.
```
<form on:submit|preventDefault={handleSubmit}>
	<!-- the `submit` event's default is prevented,
	     so the page won't reload -->
</form>
```

The following modifiers are available:
  * `preventDefault` — calls `event.preventDefault()` before running the handler
  * `stopPropagation` — calls `event.stopPropagation()`, preventing the event reaching the next element
  * `stopImmediatePropagation` - calls `event.stopImmediatePropagation()`, preventing other listeners of the same event from being fired.
  * `passive` — improves scrolling performance on touch/wheel events (Svelte will add it automatically where it’s safe to do so)
  * `nonpassive` — explicitly set `passive: false`
  * `capture` — fires the handler during the _capture_ phase instead of the _bubbling_ phase
  * `once` — remove the handler after the first time it runs
  * `self` — only trigger handler if `event.target` is the element itself
  * `trusted` — only trigger handler if `event.isTrusted` is `true`. I.e. if the event is triggered by a user action.


Modifiers can be chained together, e.g. `on:click|once|capture={...}`.
If the `on:` directive is used without a value, the component will _forward_ the event, meaning that a consumer of the component can listen for it.
```
<button on:click>
	The component itself will emit the click event
</button>
```

It’s possible to have multiple event listeners for the same event:
App
```
<script>
	let count = 0;

	function increment() {
		count += 1;
	}

	/** @param {MouseEvent} event */
	function log(event) {
		console.log(event);
	}
</script>

<button on:click={increment} on:click={log}>
	clicks: {count}
</button>
```
```
<script lang="ts">
	let count = 0;

	function increment() {
		count += 1;
	}

	function log(event: MouseEvent) {
		console.log(event);
	}
</script>

<button on:click={increment} on:click={log}>
	clicks: {count}
</button>
```

##  Component events
Components can dispatch events by creating a _dispatcher_ when they are initialised:
Stepper
```
<script>
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();
</script>

<button on:click={() => dispatch('decrement')}>decrement</button>
<button on:click={() => dispatch('increment')}>increment</button>
```
```
<script lang="ts">
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();
</script>

<button on:click={() => dispatch('decrement')}>decrement</button>
<button on:click={() => dispatch('increment')}>increment</button>
```

`dispatch` creates a `CustomEvent`. If a second argument is provided, it becomes the `detail` property of the event object.
A consumer of this component can listen for the dispatched events:
```
<script>
	import Stepper from './Stepper.svelte';

	let n = 0;
</script>

<Stepper
	on:decrement={() => n -= 1}
	on:increment={() => n += 1}
/>

<p>n: {n}</p>
```

Component events do not bubble — a parent component can only listen for events on its immediate children.
Other than `once`, modifiers are not valid on component event handlers.
> If you’re planning an eventual migration to Svelte 5, use callback props instead. This will make upgrading easier as `createEventDispatcher` is deprecated:
> Stepper
> ```
<script>
	export let decrement;
	export let increment;
</script>

<button on:click={decrement}>decrement</button>
<button on:click={increment}>increment</button>
```
```
<script lang="ts">
	export let decrement;
	export let increment;
</script>

<button on:click={decrement}>decrement</button>
<button on:click={increment}>increment</button>
```

Edit this page on GitHub llms.txt
previous next
$$props and $$restProps <slot>
In runes mode, event handlers are just like any other attribute or prop.
In legacy mode, we use the `on:` directive:
App
```
<script>
	let count = 0;

	/** @param {MouseEvent} event */
	function handleClick(event) {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	count: {count}
</button>
```
```
<script lang="ts">
	let count = 0;

	function handleClick(event: MouseEvent) {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	count: {count}
</button>
```

Handlers can be declared inline with no performance penalty:
```
<button on:click={() => (count += 1)}>
	count: {count}
</button>
```

Add _modifiers_ to element event handlers with the `|` character.
```
<form on:submit|preventDefault={handleSubmit}>
	<!-- the `submit` event's default is prevented,
	     so the page won't reload -->
</form>
```

The following modifiers are available:
  * `preventDefault` — calls `event.preventDefault()` before running the handler
  * `stopPropagation` — calls `event.stopPropagation()`, preventing the event reaching the next element
  * `stopImmediatePropagation` - calls `event.stopImmediatePropagation()`, preventing other listeners of the same event from being fired.
  * `passive` — improves scrolling performance on touch/wheel events (Svelte will add it automatically where it’s safe to do so)
  * `nonpassive` — explicitly set `passive: false`
  * `capture` — fires the handler during the _capture_ phase instead of the _bubbling_ phase
  * `once` — remove the handler after the first time it runs
  * `self` — only trigger handler if `event.target` is the element itself
  * `trusted` — only trigger handler if `event.isTrusted` is `true`. I.e. if the event is triggered by a user action.


Modifiers can be chained together, e.g. `on:click|once|capture={...}`.
If the `on:` directive is used without a value, the component will _forward_ the event, meaning that a consumer of the component can listen for it.
```
<button on:click>
	The component itself will emit the click event
</button>
```

It’s possible to have multiple event listeners for the same event:
App
```
<script>
	let count = 0;

	function increment() {
		count += 1;
	}

	/** @param {MouseEvent} event */
	function log(event) {
		console.log(event);
	}
</script>

<button on:click={increment} on:click={log}>
	clicks: {count}
</button>
```
```
<script lang="ts">
	let count = 0;

	function increment() {
		count += 1;
	}

	function log(event: MouseEvent) {
		console.log(event);
	}
</script>

<button on:click={increment} on:click={log}>
	clicks: {count}
</button>
```

##  Component events
Components can dispatch events by creating a _dispatcher_ when they are initialised:
Stepper
```
<script>
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();
</script>

<button on:click={() => dispatch('decrement')}>decrement</button>
<button on:click={() => dispatch('increment')}>increment</button>
```
```
<script lang="ts">
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();
</script>

<button on:click={() => dispatch('decrement')}>decrement</button>
<button on:click={() => dispatch('increment')}>increment</button>
```

`dispatch` creates a `CustomEvent`. If a second argument is provided, it becomes the `detail` property of the event object.
A consumer of this component can listen for the dispatched events:
```
<script>
	import Stepper from './Stepper.svelte';

	let n = 0;
</script>

<Stepper
	on:decrement={() => n -= 1}
	on:increment={() => n += 1}
/>

<p>n: {n}</p>
```

Component events do not bubble — a parent component can only listen for events on its immediate children.
Other than `once`, modifiers are not valid on component event handlers.
> If you’re planning an eventual migration to Svelte 5, use callback props instead. This will make upgrading easier as `createEventDispatcher` is deprecated:
> Stepper
> ```
<script>
	export let decrement;
	export let increment;
</script>

<button on:click={decrement}>decrement</button>
<button on:click={increment}>increment</button>
```
```
<script lang="ts">
	export let decrement;
	export let increment;
</script>

<button on:click={decrement}>decrement</button>
<button on:click={increment}>increment</button>
```

Edit this page on GitHub llms.txt
previous next
$$props and $$restProps <slot>
In runes mode, event handlers are just like any other attribute or prop.
In legacy mode, we use the `on:` directive:
App
```
<script>
	let count = 0;

	/** @param {MouseEvent} event */
	function handleClick(event) {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	count: {count}
</button>
```
```
<script lang="ts">
	let count = 0;

	function handleClick(event: MouseEvent) {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	count: {count}
</button>
```

Handlers can be declared inline with no performance penalty:
```
<button on:click={() => (count += 1)}>
	count: {count}
</button>
```

Add _modifiers_ to element event handlers with the `|` character.
```
<form on:submit|preventDefault={handleSubmit}>
	<!-- the `submit` event's default is prevented,
	     so the page won't reload -->
</form>
```

The following modifiers are available:
  * `preventDefault` — calls `event.preventDefault()` before running the handler
  * `stopPropagation` — calls `event.stopPropagation()`, preventing the event reaching the next element
  * `stopImmediatePropagation` - calls `event.stopImmediatePropagation()`, preventing other listeners of the same event from being fired.
  * `passive` — improves scrolling performance on touch/wheel events (Svelte will add it automatically where it’s safe to do so)
  * `nonpassive` — explicitly set `passive: false`
  * `capture` — fires the handler during the _capture_ phase instead of the _bubbling_ phase
  * `once` — remove the handler after the first time it runs
  * `self` — only trigger handler if `event.target` is the element itself
  * `trusted` — only trigger handler if `event.isTrusted` is `true`. I.e. if the event is triggered by a user action.


Modifiers can be chained together, e.g. `on:click|once|capture={...}`.
If the `on:` directive is used without a value, the component will _forward_ the event, meaning that a consumer of the component can listen for it.
```
<button on:click>
	The component itself will emit the click event
</button>
```

It’s possible to have multiple event listeners for the same event:
App
```
<script>
	let count = 0;

	function increment() {
		count += 1;
	}

	/** @param {MouseEvent} event */
	function log(event) {
		console.log(event);
	}
</script>

<button on:click={increment} on:click={log}>
	clicks: {count}
</button>
```
```
<script lang="ts">
	let count = 0;

	function increment() {
		count += 1;
	}

	function log(event: MouseEvent) {
		console.log(event);
	}
</script>

<button on:click={increment} on:click={log}>
	clicks: {count}
</button>
```

##  Component events
Components can dispatch events by creating a _dispatcher_ when they are initialised:
Stepper
```
<script>
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();
</script>

<button on:click={() => dispatch('decrement')}>decrement</button>
<button on:click={() => dispatch('increment')}>increment</button>
```
```
<script lang="ts">
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();
</script>

<button on:click={() => dispatch('decrement')}>decrement</button>
<button on:click={() => dispatch('increment')}>increment</button>
```

`dispatch` creates a `CustomEvent`. If a second argument is provided, it becomes the `detail` property of the event object.
A consumer of this component can listen for the dispatched events:
```
<script>
	import Stepper from './Stepper.svelte';

	let n = 0;
</script>

<Stepper
	on:decrement={() => n -= 1}
	on:increment={() => n += 1}
/>

<p>n: {n}</p>
```

Component events do not bubble — a parent component can only listen for events on its immediate children.
Other than `once`, modifiers are not valid on component event handlers.
> If you’re planning an eventual migration to Svelte 5, use callback props instead. This will make upgrading easier as `createEventDispatcher` is deprecated:
> Stepper
> ```
<script>
	export let decrement;
	export let increment;
</script>

<button on:click={decrement}>decrement</button>
<button on:click={increment}>increment</button>
```
```
<script lang="ts">
	export let decrement;
	export let increment;
</script>

<button on:click={decrement}>decrement</button>
<button on:click={increment}>increment</button>
```



---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

This module provides various functions for use during the migration, since some features can’t be replaced one to one with new features. All imports are marked as deprecated and should be migrated away from over time.
```
import {
	function asClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(component: SvelteComponent<Props, Events, Slots> | Component<Props>): ComponentType<SvelteComponent<Props, Events, Slots> & Exports>


Takes the component function and returns a Svelte 4 compatible component constructor.





@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.

asClassComponent,
	function createBubbler(): (type: string) => (event: Event) => boolean


Function to create a bubble function that mimic the behavior of on:click without handler available in svelte 4.





@deprecatedUse this only as a temporary solution to migrate your automatically delegated events in Svelte 5.

createBubbler,
	```
function createClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(options: ComponentConstructorOptions<Props> & {
    component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
}): SvelteComponent<Props, Events, Slots> & Exports
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent, `function handlers(...handlers: EventListener[]): EventListener`
Function to mimic the multiple listeners available in svelte 4
@deprecated
handlers, `function nonpassive(node: HTMLElement, [event, handler]: [event: string, handler: () => EventListener]): void`
Substitute for the `nonpassive` event modifier, implemented as an action
@deprecated
nonpassive, `function once(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `once` event modifier
@deprecated
once, `function passive(node: HTMLElement, [event, handler]: [event: string, handler: () => EventListener]): void`
Substitute for the `passive` event modifier, implemented as an action
@deprecated
passive, `function preventDefault(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `preventDefault` event modifier
@deprecated
preventDefault, `function run(fn: () => void | (() => void)): void`
Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
@deprecatedUse this only as a temporary solution to migrate your component code to Svelte 5.
run, `function self(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `self` event modifier
@deprecated
self, `function stopImmediatePropagation(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `stopImmediatePropagation` event modifier
@deprecated
stopImmediatePropagation, `function stopPropagation(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `stopPropagation` event modifier
@deprecated
stopPropagation, `function trusted(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `trusted` event modifier
@deprecated
trusted } from 'svelte/legacy';`
```

##  asClassComponent
> Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
Takes the component function and returns a Svelte 4 compatible component constructor.
```
function asClassComponent<
	Props extends Record<string, any>,
	Exports extends Record<string, any>,
	Events extends Record<string, any>,
	Slots extends Record<string, any>
>(
	component:
		| SvelteComponent<Props, Events, Slots>
		| Component<Props>
): ComponentType<
	SvelteComponent<Props, Events, Slots> & Exports
>;
```

##  createBubbler
> Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.
Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.
```
function createBubbler(): (
	type: string
) => (event: Event) => boolean;
```

##  createClassComponent
> Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
```
function createClassComponent<
	Props extends Record<string, any>,
	Exports extends Record<string, any>,
	Events extends Record<string, any>,
	Slots extends Record<string, any>
>(
	options: ComponentConstructorOptions<Props> & {
		component:
			| ComponentType<SvelteComponent<Props, Events, Slots>>
			| Component<Props>;
	}
): SvelteComponent<Props, Events, Slots> & Exports;
```

##  handlers
Function to mimic the multiple listeners available in svelte 4
```
function handlers(
	...handlers: EventListener[]
): EventListener;
```

##  nonpassive
Substitute for the `nonpassive` event modifier, implemented as an action
```
function nonpassive(
	node: HTMLElement,
	[event, handler]: [
		event: string,
		handler: () => EventListener
	]
): void;
```

##  once
Substitute for the `once` event modifier
```
function once(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  passive
Substitute for the `passive` event modifier, implemented as an action
```
function passive(
	node: HTMLElement,
	[event, handler]: [
		event: string,
		handler: () => EventListener
	]
): void;
```

##  preventDefault
Substitute for the `preventDefault` event modifier
```
function preventDefault(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  run
> Use this only as a temporary solution to migrate your component code to Svelte 5.
Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
```
function run(fn: () => void | (() => void)): void;
```

##  self
Substitute for the `self` event modifier
```
function self(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  stopImmediatePropagation
Substitute for the `stopImmediatePropagation` event modifier
```
function stopImmediatePropagation(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  stopPropagation
Substitute for the `stopPropagation` event modifier
```
function stopPropagation(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  trusted
Substitute for the `trusted` event modifier
```
function trusted(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  LegacyComponentType
Support using the component as both a class and function during the transition period
```
type LegacyComponentType = {
	new (o: ComponentConstructorOptions): SvelteComponent;
	(
		...args: Parameters<Component<Record<string, any>>>
	): ReturnType<
		Component<Record<string, any>, Record<string, any>>
	>;
};
```

Edit this page on GitHub llms.txt
previous next
svelte/events svelte/motion
This module provides various functions for use during the migration, since some features can’t be replaced one to one with new features. All imports are marked as deprecated and should be migrated away from over time.
```
import {
	function asClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(component: SvelteComponent<Props, Events, Slots> | Component<Props>): ComponentType<SvelteComponent<Props, Events, Slots> & Exports>


Takes the component function and returns a Svelte 4 compatible component constructor.





@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.

asClassComponent,
	function createBubbler(): (type: string) => (event: Event) => boolean


Function to create a bubble function that mimic the behavior of on:click without handler available in svelte 4.





@deprecatedUse this only as a temporary solution to migrate your automatically delegated events in Svelte 5.

createBubbler,
	```
function createClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(options: ComponentConstructorOptions<Props> & {
    component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
}): SvelteComponent<Props, Events, Slots> & Exports
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent, `function handlers(...handlers: EventListener[]): EventListener`
Function to mimic the multiple listeners available in svelte 4
@deprecated
handlers, `function nonpassive(node: HTMLElement, [event, handler]: [event: string, handler: () => EventListener]): void`
Substitute for the `nonpassive` event modifier, implemented as an action
@deprecated
nonpassive, `function once(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `once` event modifier
@deprecated
once, `function passive(node: HTMLElement, [event, handler]: [event: string, handler: () => EventListener]): void`
Substitute for the `passive` event modifier, implemented as an action
@deprecated
passive, `function preventDefault(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `preventDefault` event modifier
@deprecated
preventDefault, `function run(fn: () => void | (() => void)): void`
Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
@deprecatedUse this only as a temporary solution to migrate your component code to Svelte 5.
run, `function self(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `self` event modifier
@deprecated
self, `function stopImmediatePropagation(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `stopImmediatePropagation` event modifier
@deprecated
stopImmediatePropagation, `function stopPropagation(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `stopPropagation` event modifier
@deprecated
stopPropagation, `function trusted(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `trusted` event modifier
@deprecated
trusted } from 'svelte/legacy';`
```

##  asClassComponent
> Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
Takes the component function and returns a Svelte 4 compatible component constructor.
```
function asClassComponent<
	Props extends Record<string, any>,
	Exports extends Record<string, any>,
	Events extends Record<string, any>,
	Slots extends Record<string, any>
>(
	component:
		| SvelteComponent<Props, Events, Slots>
		| Component<Props>
): ComponentType<
	SvelteComponent<Props, Events, Slots> & Exports
>;
```

##  createBubbler
> Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.
Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.
```
function createBubbler(): (
	type: string
) => (event: Event) => boolean;
```

##  createClassComponent
> Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
```
function createClassComponent<
	Props extends Record<string, any>,
	Exports extends Record<string, any>,
	Events extends Record<string, any>,
	Slots extends Record<string, any>
>(
	options: ComponentConstructorOptions<Props> & {
		component:
			| ComponentType<SvelteComponent<Props, Events, Slots>>
			| Component<Props>;
	}
): SvelteComponent<Props, Events, Slots> & Exports;
```

##  handlers
Function to mimic the multiple listeners available in svelte 4
```
function handlers(
	...handlers: EventListener[]
): EventListener;
```

##  nonpassive
Substitute for the `nonpassive` event modifier, implemented as an action
```
function nonpassive(
	node: HTMLElement,
	[event, handler]: [
		event: string,
		handler: () => EventListener
	]
): void;
```

##  once
Substitute for the `once` event modifier
```
function once(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  passive
Substitute for the `passive` event modifier, implemented as an action
```
function passive(
	node: HTMLElement,
	[event, handler]: [
		event: string,
		handler: () => EventListener
	]
): void;
```

##  preventDefault
Substitute for the `preventDefault` event modifier
```
function preventDefault(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  run
> Use this only as a temporary solution to migrate your component code to Svelte 5.
Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
```
function run(fn: () => void | (() => void)): void;
```

##  self
Substitute for the `self` event modifier
```
function self(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  stopImmediatePropagation
Substitute for the `stopImmediatePropagation` event modifier
```
function stopImmediatePropagation(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  stopPropagation
Substitute for the `stopPropagation` event modifier
```
function stopPropagation(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  trusted
Substitute for the `trusted` event modifier
```
function trusted(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  LegacyComponentType
Support using the component as both a class and function during the transition period
```
type LegacyComponentType = {
	new (o: ComponentConstructorOptions): SvelteComponent;
	(
		...args: Parameters<Component<Record<string, any>>>
	): ReturnType<
		Component<Record<string, any>, Record<string, any>>
	>;
};
```

Edit this page on GitHub llms.txt
previous next
svelte/events svelte/motion
This module provides various functions for use during the migration, since some features can’t be replaced one to one with new features. All imports are marked as deprecated and should be migrated away from over time.
```
import {
	function asClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(component: SvelteComponent<Props, Events, Slots> | Component<Props>): ComponentType<SvelteComponent<Props, Events, Slots> & Exports>


Takes the component function and returns a Svelte 4 compatible component constructor.





@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.

asClassComponent,
	function createBubbler(): (type: string) => (event: Event) => boolean


Function to create a bubble function that mimic the behavior of on:click without handler available in svelte 4.





@deprecatedUse this only as a temporary solution to migrate your automatically delegated events in Svelte 5.

createBubbler,
	```
function createClassComponent<Props extends Record<string, any>, Exports extends Record<string, any>, Events extends Record<string, any>, Slots extends Record<string, any>>(options: ComponentConstructorOptions<Props> & {
    component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
}): SvelteComponent<Props, Events, Slots> & Exports
```
`
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
@deprecatedUse this only as a temporary solution to migrate your imperative component code to Svelte 5.
createClassComponent, `function handlers(...handlers: EventListener[]): EventListener`
Function to mimic the multiple listeners available in svelte 4
@deprecated
handlers, `function nonpassive(node: HTMLElement, [event, handler]: [event: string, handler: () => EventListener]): void`
Substitute for the `nonpassive` event modifier, implemented as an action
@deprecated
nonpassive, `function once(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `once` event modifier
@deprecated
once, `function passive(node: HTMLElement, [event, handler]: [event: string, handler: () => EventListener]): void`
Substitute for the `passive` event modifier, implemented as an action
@deprecated
passive, `function preventDefault(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `preventDefault` event modifier
@deprecated
preventDefault, `function run(fn: () => void | (() => void)): void`
Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
@deprecatedUse this only as a temporary solution to migrate your component code to Svelte 5.
run, `function self(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `self` event modifier
@deprecated
self, `function stopImmediatePropagation(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `stopImmediatePropagation` event modifier
@deprecated
stopImmediatePropagation, `function stopPropagation(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `stopPropagation` event modifier
@deprecated
stopPropagation, `function trusted(fn: (event: Event, ...args: Array<unknown>) => void): (event: Event, ...args: unknown[]) => void`
Substitute for the `trusted` event modifier
@deprecated
trusted } from 'svelte/legacy';`
```

##  asClassComponent
> Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
Takes the component function and returns a Svelte 4 compatible component constructor.
```
function asClassComponent<
	Props extends Record<string, any>,
	Exports extends Record<string, any>,
	Events extends Record<string, any>,
	Slots extends Record<string, any>
>(
	component:
		| SvelteComponent<Props, Events, Slots>
		| Component<Props>
): ComponentType<
	SvelteComponent<Props, Events, Slots> & Exports
>;
```

##  createBubbler
> Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.
Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.
```
function createBubbler(): (
	type: string
) => (event: Event) => boolean;
```

##  createClassComponent
> Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
```
function createClassComponent<
	Props extends Record<string, any>,
	Exports extends Record<string, any>,
	Events extends Record<string, any>,
	Slots extends Record<string, any>
>(
	options: ComponentConstructorOptions<Props> & {
		component:
			| ComponentType<SvelteComponent<Props, Events, Slots>>
			| Component<Props>;
	}
): SvelteComponent<Props, Events, Slots> & Exports;
```

##  handlers
Function to mimic the multiple listeners available in svelte 4
```
function handlers(
	...handlers: EventListener[]
): EventListener;
```

##  nonpassive
Substitute for the `nonpassive` event modifier, implemented as an action
```
function nonpassive(
	node: HTMLElement,
	[event, handler]: [
		event: string,
		handler: () => EventListener
	]
): void;
```

##  once
Substitute for the `once` event modifier
```
function once(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  passive
Substitute for the `passive` event modifier, implemented as an action
```
function passive(
	node: HTMLElement,
	[event, handler]: [
		event: string,
		handler: () => EventListener
	]
): void;
```

##  preventDefault
Substitute for the `preventDefault` event modifier
```
function preventDefault(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  run
> Use this only as a temporary solution to migrate your component code to Svelte 5.
Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
```
function run(fn: () => void | (() => void)): void;
```

##  self
Substitute for the `self` event modifier
```
function self(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  stopImmediatePropagation
Substitute for the `stopImmediatePropagation` event modifier
```
function stopImmediatePropagation(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  stopPropagation
Substitute for the `stopPropagation` event modifier
```
function stopPropagation(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  trusted
Substitute for the `trusted` event modifier
```
function trusted(
	fn: (event: Event, ...args: Array<unknown>) => void
): (event: Event, ...args: unknown[]) => void;
```

##  LegacyComponentType
Support using the component as both a class and function during the transition period
```
type LegacyComponentType = {
	new (o: ComponentConstructorOptions): SvelteComponent;
	(
		...args: Parameters<Component<Record<string, any>>>
	): ReturnType<
		Component<Record<string, any>, Record<string, any>>
	>;
};
```



---

```
import {
	class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.


SvelteComponent,
	class SvelteComponentTyped<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>

@deprecatedUse Component instead. See migration guide for more information.

SvelteComponentTyped,
	function afterUpdate(fn: () => void): void


Schedules a callback to run immediately after the component has been updated.


The first time the callback runs will be after the initial onMount.


In runes mode use $effect instead.





@deprecatedUse $effect instead

afterUpdate,
	function beforeUpdate(fn: () => void): void


Schedules a callback to run immediately before the component is updated after any state change.


The first time the callback runs will be before the initial onMount.


In runes mode use $effect.pre instead.





@deprecatedUse $effect.pre instead

beforeUpdate,
	function createEventDispatcher<EventMap extends Record<string, any> = any>(): EventDispatcher<EventMap>


Creates an event dispatcher that can be used to dispatch component events.
Event dispatchers are functions that can take two arguments: name and detail.


Component events created with createEventDispatcher create a
CustomEvent.
These events do not bubble.
The detail argument corresponds to the CustomEvent.detail
property and can contain any type of data.


The event dispatcher can be typed to narrow the allowed event names and the type of the detail argument:





```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher, ````
function createRawSnippet<Params extends unknown[]>(fn: (...params: Getters<Params>) => {
    render: () => string;
    setup?: (element: Element) => void | (() => void);
}): Snippet<Params>
```
`
Create a snippet programmatically
createRawSnippet, `function flushSync<T = void>(fn?: (() => T) | undefined): T`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync, `function getAllContexts<T extends Map<any, any> = Map<any, any>>(): T`
Retrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.
getAllContexts, `function getContext<T>(key: any): T`
Retrieves the context that belongs to the closest parent component with the specified `key`. Must be called during component initialisation.
getContext, `function hasContext(key: any): boolean`
Checks whether a given `key` has been set in the context of a parent component. Must be called during component initialisation.
hasContext, ````
function hydrate<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: {} extends Props ? {
    target: Document | Element | ShadowRoot;
    props?: Props;
    events?: Record<string, (e: any) => any>;
    context?: Map<any, any>;
    intro?: boolean;
    recover?: boolean;
} : {
    target: Document | Element | ShadowRoot;
    props: Props;
    events?: Record<string, (e: any) => any>;
    context?: Map<any, any>;
    intro?: boolean;
    recover?: boolean;
}): Exports
```
`
Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
hydrate, `function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount, `function onDestroy(fn: () => any): void`
Schedules a callback to run immediately before the component is unmounted.
Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.
onDestroy, `function onMount<T>(fn: () => NotFunction<T> | Promise<NotFunction<T>> | (() => any)): void`
`onMount`, like `$effect`, schedules a function to run as soon as the component has been mounted to the DOM. Unlike `$effect`, the provided function only runs once.
It must be called during the component’s initialisation (but doesn’t need to live _inside_ the component; it can be called from an external module). If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
`onMount` functions do not run during server-side rendering.
onMount, `function setContext<T>(key: any, context: T): T`
Associates an arbitrary `context` object with the current component and the specified `key` and returns that object. The context is then available to children of the component (including slotted content) with `getContext`.
Like lifecycle functions, this must be called during component initialisation.
setContext, `function tick(): Promise<void>`
Returns a promise that resolves once any pending state changes have been applied.
tick, ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount, `function untrack<T>(fn: () => T): T`
When used inside a `$derived` or `$effect`, any state read inside `fn` will not be treated as a dependency.
```
$effect(() => {
  // this will run when `data` changes, but not when `time` changes
  save(data, {
	timestamp: untrack(() => time)
  });
});
```

untrack } from 'svelte';`
```

##  SvelteComponent
This was the base class for Svelte components in Svelte 4. Svelte 5+ components are completely different under the hood. For typing, use `Component` instead. To instantiate components, use `mount` instead. See migration guide for more info.
```
class SvelteComponent<
	Props extends Record<string, any> = Record<string, any>,
	Events extends Record<string, any> = any,
	Slots extends Record<string, any> = any
> {…}
```

```
static element?: typeof HTMLElement;
```

The custom element version of the component. Only present if compiled with the `customElement` compiler option
```
[prop: string]: any;
```

```
constructor(options: ComponentConstructorOptions<Properties<Props, Slots>>);
```

  * deprecated This constructor only exists when using the `asClassComponent` compatibility helper, which is a stop-gap solution. Migrate towards using `mount` instead. See migration guide for more info.


```
$destroy(): void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


```
$on<K extends Extract<keyof Events, string>>(
	type: K,
	callback: (e: Events[K]) => void
): () => void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


```
$set(props: Partial<Props>): void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


##  SvelteComponentTyped
> Use `Component` instead. See migration guide for more information.
```
class SvelteComponentTyped<
	Props extends Record<string, any> = Record<string, any>,
	Events extends Record<string, any> = any,
	Slots extends Record<string, any> = any
> extends SvelteComponent<Props, Events, Slots> {}
```

##  afterUpdate
> Use `$effect` instead
Schedules a callback to run immediately after the component has been updated.
The first time the callback runs will be after the initial `onMount`.
In runes mode use `$effect` instead.
```
function afterUpdate(fn: () => void): void;
```

##  beforeUpdate
> Use `$effect.pre` instead
Schedules a callback to run immediately before the component is updated after any state change.
The first time the callback runs will be before the initial `onMount`.
In runes mode use `$effect.pre` instead.
```
function beforeUpdate(fn: () => void): void;
```

##  createEventDispatcher
> Use callback props and/or the `$host()` rune instead — see migration guide
Creates an event dispatcher that can be used to dispatch component events. Event dispatchers are functions that can take two arguments: `name` and `detail`.
Component events created with `createEventDispatcher` create a CustomEvent. These events do not bubble. The `detail` argument corresponds to the CustomEvent.detail property and can contain any type of data.
The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
```
const const dispatch: anydispatch = createEventDispatcher<{
 loaded: nullloaded: null; // does not take a detail argument
 change: stringchange: string; // takes a detail argument of type string, which is required
 optional: number | nulloptional: number | null; // takes an optional detail argument of type number
}>();
```

```
function createEventDispatcher<
	EventMap extends Record<string, any> = any
>(): EventDispatcher<EventMap>;
```

##  createRawSnippet
Create a snippet programmatically
```
function createRawSnippet<Params extends unknown[]>(
	fn: (...params: Getters<Params>) => {
		render: () => string;
		setup?: (element: Element) => void | (() => void);
	}
): Snippet<Params>;
```

##  flushSync
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
```
function flushSync<T = void>(fn?: (() => T) | undefined): T;
```

##  getAllContexts
Retrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.
```
function getAllContexts<
	T extends Map<any, any> = Map<any, any>
>(): T;
```

##  getContext
Retrieves the context that belongs to the closest parent component with the specified `key`. Must be called during component initialisation.
```
function getContext<T>(key: any): T;
```

##  hasContext
Checks whether a given `key` has been set in the context of a parent component. Must be called during component initialisation.
```
function hasContext(key: any): boolean;
```

##  hydrate
Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
```
function hydrate<
	Props extends Record<string, any>,
	Exports extends Record<string, any>
>(
	component:
		| ComponentType<SvelteComponent<Props>>
		| Component<Props, Exports, any>,
	options: {} extends Props
		? {
				target: Document | Element | ShadowRoot;
				props?: Props;
				events?: Record<string, (e: any) => any>;
				context?: Map<any, any>;
				intro?: boolean;
				recover?: boolean;
			}
		: {
				target: Document | Element | ShadowRoot;
				props: Props;
				events?: Record<string, (e: any) => any>;
				context?: Map<any, any>;
				intro?: boolean;
				recover?: boolean;
			}
): Exports;
```

##  mount
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
```
function mount<
	Props extends Record<string, any>,
	Exports extends Record<string, any>
>(
	component:
		| ComponentType<SvelteComponent<Props>>
		| Component<Props, Exports, any>,
	options: MountOptions<Props>
): Exports;
```

##  onDestroy
Schedules a callback to run immediately before the component is unmounted.
Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.
```
function onDestroy(fn: () => any): void;
```

##  onMount
`onMount`, like `$effect`, schedules a function to run as soon as the component has been mounted to the DOM. Unlike `$effect`, the provided function only runs once.
It must be called during the component’s initialisation (but doesn’t need to live _inside_ the component; it can be called from an external module). If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
`onMount` functions do not run during server-side rendering.
```
function onMount<T>(
	fn: () =>
		| NotFunction<T>
		| Promise<NotFunction<T>>
		| (() => any)
): void;
```

##  setContext
Associates an arbitrary `context` object with the current component and the specified `key` and returns that object. The context is then available to children of the component (including slotted content) with `getContext`.
Like lifecycle functions, this must be called during component initialisation.
```
function setContext<T>(key: any, context: T): T;
```

##  tick
Returns a promise that resolves once any pending state changes have been applied.
```
function tick(): Promise<void>;
```

##  unmount
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.


mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte'; const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body }); // later... ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app, { `outro?: boolean | undefined`outro: true });`
```

```
function unmount(
	component: Record<string, any>,
	options?:
		| {
				outro?: boolean;
		  }
		| undefined
): Promise<void>;
```

##  untrack
When used inside a `$derived` or `$effect`, any state read inside `fn` will not be treated as a dependency.
```
```
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { // this will run when `data` changes, but not when `time` changes save(data, { `timestamp: any`timestamp: untrack(() => time) }); });`
```

```
function untrack<T>(fn: () => T): T;
```

##  Component
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; export declare const ````
const MyComponent: Component<{
    foo: string;
}, {}, string>
```
`MyComponent: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string }> {}`
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
<script lang="ts">
	import { MyComponent } from "component-library";
</script>
<MyComponent foo={'bar'} />
```

```
interface Component<
	Props extends Record<string, any> = {},
	Exports extends Record<string, any> = {},
	Bindings extends keyof Props | '' = string
> {…}
```

```
(
	this: void,
	internals: ComponentInternals,
	props: Props
): {
	/**
	 * @deprecated This method only exists when using one of the legacy compatibility helpers, which
	 * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)
	 * for more info.
	 */
	$on?(type: string, callback: (e: any) => void): () => void;
	/**
	 * @deprecated This method only exists when using one of the legacy compatibility helpers, which
	 * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)
	 * for more info.
	 */
	$set?(props: Partial<Props>): void;
} & Exports;
```

  * `internal` An internal object used by Svelte. Do not use or modify.
  * `props` The props passed to the component.


```
element?: typeof HTMLElement;
```

The custom element version of the component. Only present if compiled with the `customElement` compiler option
##  ComponentConstructorOptions
> In Svelte 4, components are classes. In Svelte 5, they are functions. Use `mount` instead to instantiate components. See migration guide for more info.
```
interface ComponentConstructorOptions<
	Props extends Record<string, any> = Record<string, any>
> {…}
```

```
target: Element | Document | ShadowRoot;
```

```
anchor?: Element;
```

```
props?: Props;
```

```
context?: Map<any, any>;
```

```
hydrate?: boolean;
```

```
intro?: boolean;
```

```
recover?: boolean;
```

```
sync?: boolean;
```

```
idPrefix?: string;
```

```
$$inline?: boolean;
```

##  ComponentEvents
> The new `Component` type does not have a dedicated Events type. Use `ComponentProps` instead.
```
type ComponentEvents<Comp extends SvelteComponent> =
	Comp extends SvelteComponent<any, infer Events>
		? Events
		: never;
```

##  ComponentInternals
Internal implementation details that vary between environments
```
type ComponentInternals = Branded<{}, 'ComponentInternals'>;
```

##  ComponentProps
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never


Convenience type to get the props the given component expects.


Example: Ensure a variable contains the props expected by MyComponent:





```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps } from 'svelte'; import ````
type MyComponent = SvelteComponent<Record<string, any>, any, any>
const MyComponent: LegacyComponentType
```
`MyComponent from './MyComponent.svelte'; // Errors if these aren't the correct props expected by MyComponent. const `const props: Record<string, any>`props: `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps<typeof `const MyComponent: LegacyComponentType`MyComponent> = { `foo: string`foo: 'bar' };`
```

> In Svelte 4, you would do `ComponentProps<MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component, `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps } from 'svelte'; import ````
type MyComponent = SvelteComponent<Record<string, any>, any, any>
const MyComponent: LegacyComponentType
```
`MyComponent from './MyComponent.svelte'; function `function withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`withProps<`function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent extends `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<any>>( `component: TComponent extends Component<any>`component: `function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent, `props: ComponentProps<TComponent>`props: `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps<`function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent> ) {}; // Errors if the second argument is not the correct props expected by the component in the first argument. `function withProps<LegacyComponentType>(component: LegacyComponentType, props: Record<string, any>): void`withProps(`const MyComponent: LegacyComponentType`MyComponent, { `foo: string`foo: 'bar' });`
```

```
type ComponentProps<
	Comp extends SvelteComponent | Component<any, any>
> =
	Comp extends SvelteComponent<infer Props>
		? Props
		: Comp extends Component<infer Props, any>
			? Props
			: never;
```

##  ComponentType
> This type is obsolete when working with the new `Component` type.
```
type ComponentType<
	Comp extends SvelteComponent = SvelteComponent
> = (new (
	options: ComponentConstructorOptions<
		Comp extends SvelteComponent<infer Props>
			? Props
			: Record<string, any>
	>
) => Comp) & {
	/** The custom element version of the component. Only present if compiled with the `customElement` compiler option */
	element?: typeof HTMLElement;
};
```

##  EventDispatcher
```
interface EventDispatcher<
	EventMap extends Record<string, any>
> {…}
```

```
<Type extends keyof EventMap>(
	...args: null extends EventMap[Type]
		? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions]
		: undefined extends EventMap[Type]
			? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions]
			: [type: Type, parameter: EventMap[Type], options?: DispatchOptions]
): boolean;
```

##  MountOptions
Defines the options accepted by the `mount()` function.
```
type MountOptions<
	Props extends Record<string, any> = Record<string, any>
> = {
	/**
	 * Target element where the component will be mounted.
	 */
	target: Document | Element | ShadowRoot;
	/**
	 * Optional node inside `target`. When specified, it is used to render the component immediately before it.
	 */
	anchor?: Node;
	/**
	 * Allows the specification of events.
	 * @deprecated Use callback props instead.
	 */
	events?: Record<string, (e: any) => any>;
	/**
	 * Can be accessed via `getContext()` at the component level.
	 */
	context?: Map<any, any>;
	/**
	 * Whether or not to play transitions on initial render.
	 * @default true
	 */
	intro?: boolean;
} & ({} extends Props
	? {
			/**
			 * Component properties.
			 */
			props?: Props;
		}
	: {
			/**
			 * Component properties.
			 */
			props: Props;
		});
```

##  Snippet
The type of a `#snippet` block. You can use it to (for example) express that your component expects a snippet of a certain type:
```
let { ```
let banner: Snippet<[{
    text: string;
}]>
```
`banner }: { ````
banner: Snippet<[{
    text: string;
}]>
```
`banner: `type Snippet = /*unresolved*/ any`Snippet<[{ `text: string`text: string }]> } = ````
function $props(): any
namespace $props
```
`
Declares the props that a component accepts. Example:
```
let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();
```

https://svelte.dev/docs/svelte/$props
$props();`
```

You can only call a snippet through the `{@render ...}` tag.
See the snippet documentation for more info.
```
interface Snippet<Parameters extends unknown[] = []> {…}
```

```
(
	this: void,
	// this conditional allows tuples but not arrays. Arrays would indicate a
	// rest parameter type, which is not supported. If rest parameters are added
	// in the future, the condition can be removed.
	...args: number extends Parameters['length'] ? never : Parameters
): {
	'{@render ...} must be called with a Snippet': "import type { Snippet } from 'svelte'";
} & typeof SnippetReturn;
```

Edit this page on GitHub llms.txt
previous next
Frequently asked questions svelte/action
```
import {
	class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.


SvelteComponent,
	class SvelteComponentTyped<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>

@deprecatedUse Component instead. See migration guide for more information.

SvelteComponentTyped,
	function afterUpdate(fn: () => void): void


Schedules a callback to run immediately after the component has been updated.


The first time the callback runs will be after the initial onMount.


In runes mode use $effect instead.





@deprecatedUse $effect instead

afterUpdate,
	function beforeUpdate(fn: () => void): void


Schedules a callback to run immediately before the component is updated after any state change.


The first time the callback runs will be before the initial onMount.


In runes mode use $effect.pre instead.





@deprecatedUse $effect.pre instead

beforeUpdate,
	function createEventDispatcher<EventMap extends Record<string, any> = any>(): EventDispatcher<EventMap>


Creates an event dispatcher that can be used to dispatch component events.
Event dispatchers are functions that can take two arguments: name and detail.


Component events created with createEventDispatcher create a
CustomEvent.
These events do not bubble.
The detail argument corresponds to the CustomEvent.detail
property and can contain any type of data.


The event dispatcher can be typed to narrow the allowed event names and the type of the detail argument:





```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher, ````
function createRawSnippet<Params extends unknown[]>(fn: (...params: Getters<Params>) => {
    render: () => string;
    setup?: (element: Element) => void | (() => void);
}): Snippet<Params>
```
`
Create a snippet programmatically
createRawSnippet, `function flushSync<T = void>(fn?: (() => T) | undefined): T`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync, `function getAllContexts<T extends Map<any, any> = Map<any, any>>(): T`
Retrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.
getAllContexts, `function getContext<T>(key: any): T`
Retrieves the context that belongs to the closest parent component with the specified `key`. Must be called during component initialisation.
getContext, `function hasContext(key: any): boolean`
Checks whether a given `key` has been set in the context of a parent component. Must be called during component initialisation.
hasContext, ````
function hydrate<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: {} extends Props ? {
    target: Document | Element | ShadowRoot;
    props?: Props;
    events?: Record<string, (e: any) => any>;
    context?: Map<any, any>;
    intro?: boolean;
    recover?: boolean;
} : {
    target: Document | Element | ShadowRoot;
    props: Props;
    events?: Record<string, (e: any) => any>;
    context?: Map<any, any>;
    intro?: boolean;
    recover?: boolean;
}): Exports
```
`
Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
hydrate, `function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount, `function onDestroy(fn: () => any): void`
Schedules a callback to run immediately before the component is unmounted.
Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.
onDestroy, `function onMount<T>(fn: () => NotFunction<T> | Promise<NotFunction<T>> | (() => any)): void`
`onMount`, like `$effect`, schedules a function to run as soon as the component has been mounted to the DOM. Unlike `$effect`, the provided function only runs once.
It must be called during the component’s initialisation (but doesn’t need to live _inside_ the component; it can be called from an external module). If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
`onMount` functions do not run during server-side rendering.
onMount, `function setContext<T>(key: any, context: T): T`
Associates an arbitrary `context` object with the current component and the specified `key` and returns that object. The context is then available to children of the component (including slotted content) with `getContext`.
Like lifecycle functions, this must be called during component initialisation.
setContext, `function tick(): Promise<void>`
Returns a promise that resolves once any pending state changes have been applied.
tick, ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount, `function untrack<T>(fn: () => T): T`
When used inside a `$derived` or `$effect`, any state read inside `fn` will not be treated as a dependency.
```
$effect(() => {
  // this will run when `data` changes, but not when `time` changes
  save(data, {
	timestamp: untrack(() => time)
  });
});
```

untrack } from 'svelte';`
```

##  SvelteComponent
This was the base class for Svelte components in Svelte 4. Svelte 5+ components are completely different under the hood. For typing, use `Component` instead. To instantiate components, use `mount` instead. See migration guide for more info.
```
class SvelteComponent<
	Props extends Record<string, any> = Record<string, any>,
	Events extends Record<string, any> = any,
	Slots extends Record<string, any> = any
> {…}
```

```
static element?: typeof HTMLElement;
```

The custom element version of the component. Only present if compiled with the `customElement` compiler option
```
[prop: string]: any;
```

```
constructor(options: ComponentConstructorOptions<Properties<Props, Slots>>);
```

  * deprecated This constructor only exists when using the `asClassComponent` compatibility helper, which is a stop-gap solution. Migrate towards using `mount` instead. See migration guide for more info.


```
$destroy(): void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


```
$on<K extends Extract<keyof Events, string>>(
	type: K,
	callback: (e: Events[K]) => void
): () => void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


```
$set(props: Partial<Props>): void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


##  SvelteComponentTyped
> Use `Component` instead. See migration guide for more information.
```
class SvelteComponentTyped<
	Props extends Record<string, any> = Record<string, any>,
	Events extends Record<string, any> = any,
	Slots extends Record<string, any> = any
> extends SvelteComponent<Props, Events, Slots> {}
```

##  afterUpdate
> Use `$effect` instead
Schedules a callback to run immediately after the component has been updated.
The first time the callback runs will be after the initial `onMount`.
In runes mode use `$effect` instead.
```
function afterUpdate(fn: () => void): void;
```

##  beforeUpdate
> Use `$effect.pre` instead
Schedules a callback to run immediately before the component is updated after any state change.
The first time the callback runs will be before the initial `onMount`.
In runes mode use `$effect.pre` instead.
```
function beforeUpdate(fn: () => void): void;
```

##  createEventDispatcher
> Use callback props and/or the `$host()` rune instead — see migration guide
Creates an event dispatcher that can be used to dispatch component events. Event dispatchers are functions that can take two arguments: `name` and `detail`.
Component events created with `createEventDispatcher` create a CustomEvent. These events do not bubble. The `detail` argument corresponds to the CustomEvent.detail property and can contain any type of data.
The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
```
const const dispatch: anydispatch = createEventDispatcher<{
 loaded: nullloaded: null; // does not take a detail argument
 change: stringchange: string; // takes a detail argument of type string, which is required
 optional: number | nulloptional: number | null; // takes an optional detail argument of type number
}>();
```

```
function createEventDispatcher<
	EventMap extends Record<string, any> = any
>(): EventDispatcher<EventMap>;
```

##  createRawSnippet
Create a snippet programmatically
```
function createRawSnippet<Params extends unknown[]>(
	fn: (...params: Getters<Params>) => {
		render: () => string;
		setup?: (element: Element) => void | (() => void);
	}
): Snippet<Params>;
```

##  flushSync
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
```
function flushSync<T = void>(fn?: (() => T) | undefined): T;
```

##  getAllContexts
Retrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.
```
function getAllContexts<
	T extends Map<any, any> = Map<any, any>
>(): T;
```

##  getContext
Retrieves the context that belongs to the closest parent component with the specified `key`. Must be called during component initialisation.
```
function getContext<T>(key: any): T;
```

##  hasContext
Checks whether a given `key` has been set in the context of a parent component. Must be called during component initialisation.
```
function hasContext(key: any): boolean;
```

##  hydrate
Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
```
function hydrate<
	Props extends Record<string, any>,
	Exports extends Record<string, any>
>(
	component:
		| ComponentType<SvelteComponent<Props>>
		| Component<Props, Exports, any>,
	options: {} extends Props
		? {
				target: Document | Element | ShadowRoot;
				props?: Props;
				events?: Record<string, (e: any) => any>;
				context?: Map<any, any>;
				intro?: boolean;
				recover?: boolean;
			}
		: {
				target: Document | Element | ShadowRoot;
				props: Props;
				events?: Record<string, (e: any) => any>;
				context?: Map<any, any>;
				intro?: boolean;
				recover?: boolean;
			}
): Exports;
```

##  mount
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
```
function mount<
	Props extends Record<string, any>,
	Exports extends Record<string, any>
>(
	component:
		| ComponentType<SvelteComponent<Props>>
		| Component<Props, Exports, any>,
	options: MountOptions<Props>
): Exports;
```

##  onDestroy
Schedules a callback to run immediately before the component is unmounted.
Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.
```
function onDestroy(fn: () => any): void;
```

##  onMount
`onMount`, like `$effect`, schedules a function to run as soon as the component has been mounted to the DOM. Unlike `$effect`, the provided function only runs once.
It must be called during the component’s initialisation (but doesn’t need to live _inside_ the component; it can be called from an external module). If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
`onMount` functions do not run during server-side rendering.
```
function onMount<T>(
	fn: () =>
		| NotFunction<T>
		| Promise<NotFunction<T>>
		| (() => any)
): void;
```

##  setContext
Associates an arbitrary `context` object with the current component and the specified `key` and returns that object. The context is then available to children of the component (including slotted content) with `getContext`.
Like lifecycle functions, this must be called during component initialisation.
```
function setContext<T>(key: any, context: T): T;
```

##  tick
Returns a promise that resolves once any pending state changes have been applied.
```
function tick(): Promise<void>;
```

##  unmount
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.


mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte'; const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body }); // later... ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app, { `outro?: boolean | undefined`outro: true });`
```

```
function unmount(
	component: Record<string, any>,
	options?:
		| {
				outro?: boolean;
		  }
		| undefined
): Promise<void>;
```

##  untrack
When used inside a `$derived` or `$effect`, any state read inside `fn` will not be treated as a dependency.
```
```
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { // this will run when `data` changes, but not when `time` changes save(data, { `timestamp: any`timestamp: untrack(() => time) }); });`
```

```
function untrack<T>(fn: () => T): T;
```

##  Component
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; export declare const ````
const MyComponent: Component<{
    foo: string;
}, {}, string>
```
`MyComponent: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string }> {}`
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
<script lang="ts">
	import { MyComponent } from "component-library";
</script>
<MyComponent foo={'bar'} />
```

```
interface Component<
	Props extends Record<string, any> = {},
	Exports extends Record<string, any> = {},
	Bindings extends keyof Props | '' = string
> {…}
```

```
(
	this: void,
	internals: ComponentInternals,
	props: Props
): {
	/**
	 * @deprecated This method only exists when using one of the legacy compatibility helpers, which
	 * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)
	 * for more info.
	 */
	$on?(type: string, callback: (e: any) => void): () => void;
	/**
	 * @deprecated This method only exists when using one of the legacy compatibility helpers, which
	 * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)
	 * for more info.
	 */
	$set?(props: Partial<Props>): void;
} & Exports;
```

  * `internal` An internal object used by Svelte. Do not use or modify.
  * `props` The props passed to the component.


```
element?: typeof HTMLElement;
```

The custom element version of the component. Only present if compiled with the `customElement` compiler option
##  ComponentConstructorOptions
> In Svelte 4, components are classes. In Svelte 5, they are functions. Use `mount` instead to instantiate components. See migration guide for more info.
```
interface ComponentConstructorOptions<
	Props extends Record<string, any> = Record<string, any>
> {…}
```

```
target: Element | Document | ShadowRoot;
```

```
anchor?: Element;
```

```
props?: Props;
```

```
context?: Map<any, any>;
```

```
hydrate?: boolean;
```

```
intro?: boolean;
```

```
recover?: boolean;
```

```
sync?: boolean;
```

```
idPrefix?: string;
```

```
$$inline?: boolean;
```

##  ComponentEvents
> The new `Component` type does not have a dedicated Events type. Use `ComponentProps` instead.
```
type ComponentEvents<Comp extends SvelteComponent> =
	Comp extends SvelteComponent<any, infer Events>
		? Events
		: never;
```

##  ComponentInternals
Internal implementation details that vary between environments
```
type ComponentInternals = Branded<{}, 'ComponentInternals'>;
```

##  ComponentProps
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never


Convenience type to get the props the given component expects.


Example: Ensure a variable contains the props expected by MyComponent:





```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps } from 'svelte'; import ````
type MyComponent = SvelteComponent<Record<string, any>, any, any>
const MyComponent: LegacyComponentType
```
`MyComponent from './MyComponent.svelte'; // Errors if these aren't the correct props expected by MyComponent. const `const props: Record<string, any>`props: `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps<typeof `const MyComponent: LegacyComponentType`MyComponent> = { `foo: string`foo: 'bar' };`
```

> In Svelte 4, you would do `ComponentProps<MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component, `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps } from 'svelte'; import ````
type MyComponent = SvelteComponent<Record<string, any>, any, any>
const MyComponent: LegacyComponentType
```
`MyComponent from './MyComponent.svelte'; function `function withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`withProps<`function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent extends `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<any>>( `component: TComponent extends Component<any>`component: `function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent, `props: ComponentProps<TComponent>`props: `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps<`function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent> ) {}; // Errors if the second argument is not the correct props expected by the component in the first argument. `function withProps<LegacyComponentType>(component: LegacyComponentType, props: Record<string, any>): void`withProps(`const MyComponent: LegacyComponentType`MyComponent, { `foo: string`foo: 'bar' });`
```

```
type ComponentProps<
	Comp extends SvelteComponent | Component<any, any>
> =
	Comp extends SvelteComponent<infer Props>
		? Props
		: Comp extends Component<infer Props, any>
			? Props
			: never;
```

##  ComponentType
> This type is obsolete when working with the new `Component` type.
```
type ComponentType<
	Comp extends SvelteComponent = SvelteComponent
> = (new (
	options: ComponentConstructorOptions<
		Comp extends SvelteComponent<infer Props>
			? Props
			: Record<string, any>
	>
) => Comp) & {
	/** The custom element version of the component. Only present if compiled with the `customElement` compiler option */
	element?: typeof HTMLElement;
};
```

##  EventDispatcher
```
interface EventDispatcher<
	EventMap extends Record<string, any>
> {…}
```

```
<Type extends keyof EventMap>(
	...args: null extends EventMap[Type]
		? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions]
		: undefined extends EventMap[Type]
			? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions]
			: [type: Type, parameter: EventMap[Type], options?: DispatchOptions]
): boolean;
```

##  MountOptions
Defines the options accepted by the `mount()` function.
```
type MountOptions<
	Props extends Record<string, any> = Record<string, any>
> = {
	/**
	 * Target element where the component will be mounted.
	 */
	target: Document | Element | ShadowRoot;
	/**
	 * Optional node inside `target`. When specified, it is used to render the component immediately before it.
	 */
	anchor?: Node;
	/**
	 * Allows the specification of events.
	 * @deprecated Use callback props instead.
	 */
	events?: Record<string, (e: any) => any>;
	/**
	 * Can be accessed via `getContext()` at the component level.
	 */
	context?: Map<any, any>;
	/**
	 * Whether or not to play transitions on initial render.
	 * @default true
	 */
	intro?: boolean;
} & ({} extends Props
	? {
			/**
			 * Component properties.
			 */
			props?: Props;
		}
	: {
			/**
			 * Component properties.
			 */
			props: Props;
		});
```

##  Snippet
The type of a `#snippet` block. You can use it to (for example) express that your component expects a snippet of a certain type:
```
let { ```
let banner: Snippet<[{
    text: string;
}]>
```
`banner }: { ````
banner: Snippet<[{
    text: string;
}]>
```
`banner: `type Snippet = /*unresolved*/ any`Snippet<[{ `text: string`text: string }]> } = ````
function $props(): any
namespace $props
```
`
Declares the props that a component accepts. Example:
```
let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();
```

https://svelte.dev/docs/svelte/$props
$props();`
```

You can only call a snippet through the `{@render ...}` tag.
See the snippet documentation for more info.
```
interface Snippet<Parameters extends unknown[] = []> {…}
```

```
(
	this: void,
	// this conditional allows tuples but not arrays. Arrays would indicate a
	// rest parameter type, which is not supported. If rest parameters are added
	// in the future, the condition can be removed.
	...args: number extends Parameters['length'] ? never : Parameters
): {
	'{@render ...} must be called with a Snippet': "import type { Snippet } from 'svelte'";
} & typeof SnippetReturn;
```

Edit this page on GitHub llms.txt
previous next
Frequently asked questions svelte/action
```
import {
	class SvelteComponent<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>


This was the base class for Svelte components in Svelte 4. Svelte 5+ components
are completely different under the hood. For typing, use Component instead.
To instantiate components, use mount instead.
See migration guide for more info.


SvelteComponent,
	class SvelteComponentTyped<Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any>

@deprecatedUse Component instead. See migration guide for more information.

SvelteComponentTyped,
	function afterUpdate(fn: () => void): void


Schedules a callback to run immediately after the component has been updated.


The first time the callback runs will be after the initial onMount.


In runes mode use $effect instead.





@deprecatedUse $effect instead

afterUpdate,
	function beforeUpdate(fn: () => void): void


Schedules a callback to run immediately before the component is updated after any state change.


The first time the callback runs will be before the initial onMount.


In runes mode use $effect.pre instead.





@deprecatedUse $effect.pre instead

beforeUpdate,
	function createEventDispatcher<EventMap extends Record<string, any> = any>(): EventDispatcher<EventMap>


Creates an event dispatcher that can be used to dispatch component events.
Event dispatchers are functions that can take two arguments: name and detail.


Component events created with createEventDispatcher create a
CustomEvent.
These events do not bubble.
The detail argument corresponds to the CustomEvent.detail
property and can contain any type of data.


The event dispatcher can be typed to narrow the allowed event names and the type of the detail argument:





```
const dispatch = createEventDispatcher&#x3C;{
 loaded: never; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}>();
```

@deprecatedUse callback props and/or the `$host()` rune instead — see migration guide
createEventDispatcher, ````
function createRawSnippet<Params extends unknown[]>(fn: (...params: Getters<Params>) => {
    render: () => string;
    setup?: (element: Element) => void | (() => void);
}): Snippet<Params>
```
`
Create a snippet programmatically
createRawSnippet, `function flushSync<T = void>(fn?: (() => T) | undefined): T`
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
flushSync, `function getAllContexts<T extends Map<any, any> = Map<any, any>>(): T`
Retrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.
getAllContexts, `function getContext<T>(key: any): T`
Retrieves the context that belongs to the closest parent component with the specified `key`. Must be called during component initialisation.
getContext, `function hasContext(key: any): boolean`
Checks whether a given `key` has been set in the context of a parent component. Must be called during component initialisation.
hasContext, ````
function hydrate<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: {} extends Props ? {
    target: Document | Element | ShadowRoot;
    props?: Props;
    events?: Record<string, (e: any) => any>;
    context?: Map<any, any>;
    intro?: boolean;
    recover?: boolean;
} : {
    target: Document | Element | ShadowRoot;
    props: Props;
    events?: Record<string, (e: any) => any>;
    context?: Map<any, any>;
    intro?: boolean;
    recover?: boolean;
}): Exports
```
`
Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
hydrate, `function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount, `function onDestroy(fn: () => any): void`
Schedules a callback to run immediately before the component is unmounted.
Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.
onDestroy, `function onMount<T>(fn: () => NotFunction<T> | Promise<NotFunction<T>> | (() => any)): void`
`onMount`, like `$effect`, schedules a function to run as soon as the component has been mounted to the DOM. Unlike `$effect`, the provided function only runs once.
It must be called during the component’s initialisation (but doesn’t need to live _inside_ the component; it can be called from an external module). If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
`onMount` functions do not run during server-side rendering.
onMount, `function setContext<T>(key: any, context: T): T`
Associates an arbitrary `context` object with the current component and the specified `key` and returns that object. The context is then available to children of the component (including slotted content) with `getContext`.
Like lifecycle functions, this must be called during component initialisation.
setContext, `function tick(): Promise<void>`
Returns a promise that resolves once any pending state changes have been applied.
tick, ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount, `function untrack<T>(fn: () => T): T`
When used inside a `$derived` or `$effect`, any state read inside `fn` will not be treated as a dependency.
```
$effect(() => {
  // this will run when `data` changes, but not when `time` changes
  save(data, {
	timestamp: untrack(() => time)
  });
});
```

untrack } from 'svelte';`
```

##  SvelteComponent
This was the base class for Svelte components in Svelte 4. Svelte 5+ components are completely different under the hood. For typing, use `Component` instead. To instantiate components, use `mount` instead. See migration guide for more info.
```
class SvelteComponent<
	Props extends Record<string, any> = Record<string, any>,
	Events extends Record<string, any> = any,
	Slots extends Record<string, any> = any
> {…}
```

```
static element?: typeof HTMLElement;
```

The custom element version of the component. Only present if compiled with the `customElement` compiler option
```
[prop: string]: any;
```

```
constructor(options: ComponentConstructorOptions<Properties<Props, Slots>>);
```

  * deprecated This constructor only exists when using the `asClassComponent` compatibility helper, which is a stop-gap solution. Migrate towards using `mount` instead. See migration guide for more info.


```
$destroy(): void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


```
$on<K extends Extract<keyof Events, string>>(
	type: K,
	callback: (e: Events[K]) => void
): () => void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


```
$set(props: Partial<Props>): void;
```

  * deprecated This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See migration guide for more info.


##  SvelteComponentTyped
> Use `Component` instead. See migration guide for more information.
```
class SvelteComponentTyped<
	Props extends Record<string, any> = Record<string, any>,
	Events extends Record<string, any> = any,
	Slots extends Record<string, any> = any
> extends SvelteComponent<Props, Events, Slots> {}
```

##  afterUpdate
> Use `$effect` instead
Schedules a callback to run immediately after the component has been updated.
The first time the callback runs will be after the initial `onMount`.
In runes mode use `$effect` instead.
```
function afterUpdate(fn: () => void): void;
```

##  beforeUpdate
> Use `$effect.pre` instead
Schedules a callback to run immediately before the component is updated after any state change.
The first time the callback runs will be before the initial `onMount`.
In runes mode use `$effect.pre` instead.
```
function beforeUpdate(fn: () => void): void;
```

##  createEventDispatcher
> Use callback props and/or the `$host()` rune instead — see migration guide
Creates an event dispatcher that can be used to dispatch component events. Event dispatchers are functions that can take two arguments: `name` and `detail`.
Component events created with `createEventDispatcher` create a CustomEvent. These events do not bubble. The `detail` argument corresponds to the CustomEvent.detail property and can contain any type of data.
The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
```
const const dispatch: anydispatch = createEventDispatcher<{
 loaded: nullloaded: null; // does not take a detail argument
 change: stringchange: string; // takes a detail argument of type string, which is required
 optional: number | nulloptional: number | null; // takes an optional detail argument of type number
}>();
```

```
function createEventDispatcher<
	EventMap extends Record<string, any> = any
>(): EventDispatcher<EventMap>;
```

##  createRawSnippet
Create a snippet programmatically
```
function createRawSnippet<Params extends unknown[]>(
	fn: (...params: Getters<Params>) => {
		render: () => string;
		setup?: (element: Element) => void | (() => void);
	}
): Snippet<Params>;
```

##  flushSync
Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.
```
function flushSync<T = void>(fn?: (() => T) | undefined): T;
```

##  getAllContexts
Retrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.
```
function getAllContexts<
	T extends Map<any, any> = Map<any, any>
>(): T;
```

##  getContext
Retrieves the context that belongs to the closest parent component with the specified `key`. Must be called during component initialisation.
```
function getContext<T>(key: any): T;
```

##  hasContext
Checks whether a given `key` has been set in the context of a parent component. Must be called during component initialisation.
```
function hasContext(key: any): boolean;
```

##  hydrate
Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
```
function hydrate<
	Props extends Record<string, any>,
	Exports extends Record<string, any>
>(
	component:
		| ComponentType<SvelteComponent<Props>>
		| Component<Props, Exports, any>,
	options: {} extends Props
		? {
				target: Document | Element | ShadowRoot;
				props?: Props;
				events?: Record<string, (e: any) => any>;
				context?: Map<any, any>;
				intro?: boolean;
				recover?: boolean;
			}
		: {
				target: Document | Element | ShadowRoot;
				props: Props;
				events?: Record<string, (e: any) => any>;
				context?: Map<any, any>;
				intro?: boolean;
				recover?: boolean;
			}
): Exports;
```

##  mount
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
```
function mount<
	Props extends Record<string, any>,
	Exports extends Record<string, any>
>(
	component:
		| ComponentType<SvelteComponent<Props>>
		| Component<Props, Exports, any>,
	options: MountOptions<Props>
): Exports;
```

##  onDestroy
Schedules a callback to run immediately before the component is unmounted.
Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.
```
function onDestroy(fn: () => any): void;
```

##  onMount
`onMount`, like `$effect`, schedules a function to run as soon as the component has been mounted to the DOM. Unlike `$effect`, the provided function only runs once.
It must be called during the component’s initialisation (but doesn’t need to live _inside_ the component; it can be called from an external module). If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
`onMount` functions do not run during server-side rendering.
```
function onMount<T>(
	fn: () =>
		| NotFunction<T>
		| Promise<NotFunction<T>>
		| (() => any)
): void;
```

##  setContext
Associates an arbitrary `context` object with the current component and the specified `key` and returns that object. The context is then available to children of the component (including slotted content) with `getContext`.
Like lifecycle functions, this must be called during component initialisation.
```
function setContext<T>(key: any, context: T): T;
```

##  tick
Returns a promise that resolves once any pending state changes have been applied.
```
function tick(): Promise<void>;
```

##  unmount
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(component: ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>, options: MountOptions<Props>): Exports


Mounts a component to the given target and returns the exports and potentially the props (if compiled with accessors: true) of the component.
Transitions will play during the initial render unless the intro option is set to false.


mount, ```
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount } from 'svelte'; import ````
type App = SvelteComponent<Record<string, any>, any, any>
const App: LegacyComponentType
```
`App from './App.svelte'; const ````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app = ````
mount<Record<string, any>, {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<...>>(component: ComponentType<...> | Component<...>, options: MountOptions<...>): {
    ...;
} & Record<...>
```
`
Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. Transitions will play during the initial render unless the `intro` option is set to `false`.
mount(`const App: LegacyComponentType`App, { `target: Document | Element | ShadowRoot`
Target element where the component will be mounted.
target: `var document: Document`
MDN Reference
document.`Document.body: HTMLElement`
Specifies the beginning and end of the document body.
MDN Reference
body }); // later... ````
function unmount(component: Record<string, any>, options?: {
    outro?: boolean;
} | undefined): Promise<void>
```
`
Unmounts a component that was previously mounted using `mount` or `hydrate`.
Since 5.13.0, if `options.outro` is `true`, transitions will play before the component is removed from the DOM.
Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
```
import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });
```

unmount(````
const app: {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Record<string, any>>): void;
} & Record<string, any>
```
`app, { `outro?: boolean | undefined`outro: true });`
```

```
function unmount(
	component: Record<string, any>,
	options?:
		| {
				outro?: boolean;
		  }
		| undefined
): Promise<void>;
```

##  untrack
When used inside a `$derived` or `$effect`, any state read inside `fn` will not be treated as a dependency.
```
```
function $effect(fn: () => void | (() => void)): void
namespace $effect
```
`
Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. The timing of the execution is after the DOM has been updated.
Example:
```
$effect(() => console.log('The count is now ' + count));
```

If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted.
Does not run during server side rendering.
https://svelte.dev/docs/svelte/$effect
@paramfn The function to execute
$effect(() => { // this will run when `data` changes, but not when `time` changes save(data, { `timestamp: any`timestamp: untrack(() => time) }); });`
```

```
function untrack<T>(fn: () => T): T;
```

##  Component
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component } from 'svelte'; export declare const ````
const MyComponent: Component<{
    foo: string;
}, {}, string>
```
`MyComponent: `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<{ `foo: string`foo: string }> {}`
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
<script lang="ts">
	import { MyComponent } from "component-library";
</script>
<MyComponent foo={'bar'} />
```

```
interface Component<
	Props extends Record<string, any> = {},
	Exports extends Record<string, any> = {},
	Bindings extends keyof Props | '' = string
> {…}
```

```
(
	this: void,
	internals: ComponentInternals,
	props: Props
): {
	/**
	 * @deprecated This method only exists when using one of the legacy compatibility helpers, which
	 * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)
	 * for more info.
	 */
	$on?(type: string, callback: (e: any) => void): () => void;
	/**
	 * @deprecated This method only exists when using one of the legacy compatibility helpers, which
	 * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)
	 * for more info.
	 */
	$set?(props: Partial<Props>): void;
} & Exports;
```

  * `internal` An internal object used by Svelte. Do not use or modify.
  * `props` The props passed to the component.


```
element?: typeof HTMLElement;
```

The custom element version of the component. Only present if compiled with the `customElement` compiler option
##  ComponentConstructorOptions
> In Svelte 4, components are classes. In Svelte 5, they are functions. Use `mount` instead to instantiate components. See migration guide for more info.
```
interface ComponentConstructorOptions<
	Props extends Record<string, any> = Record<string, any>
> {…}
```

```
target: Element | Document | ShadowRoot;
```

```
anchor?: Element;
```

```
props?: Props;
```

```
context?: Map<any, any>;
```

```
hydrate?: boolean;
```

```
intro?: boolean;
```

```
recover?: boolean;
```

```
sync?: boolean;
```

```
idPrefix?: string;
```

```
$$inline?: boolean;
```

##  ComponentEvents
> The new `Component` type does not have a dedicated Events type. Use `ComponentProps` instead.
```
type ComponentEvents<Comp extends SvelteComponent> =
	Comp extends SvelteComponent<any, infer Events>
		? Events
		: never;
```

##  ComponentInternals
Internal implementation details that vary between environments
```
type ComponentInternals = Branded<{}, 'ComponentInternals'>;
```

##  ComponentProps
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never


Convenience type to get the props the given component expects.


Example: Ensure a variable contains the props expected by MyComponent:





```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps } from 'svelte'; import ````
type MyComponent = SvelteComponent<Record<string, any>, any, any>
const MyComponent: LegacyComponentType
```
`MyComponent from './MyComponent.svelte'; // Errors if these aren't the correct props expected by MyComponent. const `const props: Record<string, any>`props: `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps<typeof `const MyComponent: LegacyComponentType`MyComponent> = { `foo: string`foo: 'bar' };`
```

> In Svelte 4, you would do `ComponentProps<MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>


Can be used to create strongly typed Svelte components.


#### 
Example:



You have component library on npm called component-library, from which
you export a component called MyComponent. For Svelte+TypeScript users,
you want to provide typings. Therefore you create a index.d.ts:





```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component, `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps } from 'svelte'; import ````
type MyComponent = SvelteComponent<Record<string, any>, any, any>
const MyComponent: LegacyComponentType
```
`MyComponent from './MyComponent.svelte'; function `function withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`withProps<`function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent extends `interface Component<Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | "" = string>`
Can be used to create strongly typed Svelte components.
####  Example:
You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:
```
import type { Component } from 'svelte';
export declare const MyComponent: Component&#x3C;{ foo: string }> {}
```

Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:
```
&#x3C;script lang="ts">
	import { MyComponent } from "component-library";
&#x3C;/script>
&#x3C;MyComponent foo={'bar'} />
```

Component<any>>( `component: TComponent extends Component<any>`component: `function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent, `props: ComponentProps<TComponent>`props: `type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props extends Record<string, any>, any, any> ? Props : Comp extends Component<infer Props extends Record<...>, any, string> ? Props : never`
Convenience type to get the props the given component expects.
Example: Ensure a variable contains the props expected by `MyComponent`:
```
import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&#x3C;typeof MyComponent> = { foo: 'bar' };
```

> In Svelte 4, you would do `ComponentProps&#x3C;MyComponent>` because `MyComponent` was a class.
Example: A generic function that accepts some component and infers the type of its props:
```
import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&#x3C;TComponent extends Component&#x3C;any>>(
	component: TComponent,
	props: ComponentProps&#x3C;TComponent>
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
```

ComponentProps<`function (type parameter) TComponent in withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>): void`TComponent> ) {}; // Errors if the second argument is not the correct props expected by the component in the first argument. `function withProps<LegacyComponentType>(component: LegacyComponentType, props: Record<string, any>): void`withProps(`const MyComponent: LegacyComponentType`MyComponent, { `foo: string`foo: 'bar' });`
```

```
type ComponentProps<
	Comp extends SvelteComponent | Component<any, any>
> =
	Comp extends SvelteComponent<infer Props>
		? Props
		: Comp extends Component<infer Props, any>
			? Props
			: never;
```

##  ComponentType
> This type is obsolete when working with the new `Component` type.
```
type ComponentType<
	Comp extends SvelteComponent = SvelteComponent
> = (new (
	options: ComponentConstructorOptions<
		Comp extends SvelteComponent<infer Props>
			? Props
			: Record<string, any>
	>
) => Comp) & {
	/** The custom element version of the component. Only present if compiled with the `customElement` compiler option */
	element?: typeof HTMLElement;
};
```

##  EventDispatcher
```
interface EventDispatcher<
	EventMap extends Record<string, any>
> {…}
```

```
<Type extends keyof EventMap>(
	...args: null extends EventMap[Type]
		? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions]
		: undefined extends EventMap[Type]
			? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions]
			: [type: Type, parameter: EventMap[Type], options?: DispatchOptions]
): boolean;
```

##  MountOptions
Defines the options accepted by the `mount()` function.
```
type MountOptions<
	Props extends Record<string, any> = Record<string, any>
> = {
	/**
	 * Target element where the component will be mounted.
	 */
	target: Document | Element | ShadowRoot;
	/**
	 * Optional node inside `target`. When specified, it is used to render the component immediately before it.
	 */
	anchor?: Node;
	/**
	 * Allows the specification of events.
	 * @deprecated Use callback props instead.
	 */
	events?: Record<string, (e: any) => any>;
	/**
	 * Can be accessed via `getContext()` at the component level.
	 */
	context?: Map<any, any>;
	/**
	 * Whether or not to play transitions on initial render.
	 * @default true
	 */
	intro?: boolean;
} & ({} extends Props
	? {
			/**
			 * Component properties.
			 */
			props?: Props;
		}
	: {
			/**
			 * Component properties.
			 */
			props: Props;
		});
```

##  Snippet
The type of a `#snippet` block. You can use it to (for example) express that your component expects a snippet of a certain type:
```
let { ```
let banner: Snippet<[{
    text: string;
}]>
```
`banner }: { ````
banner: Snippet<[{
    text: string;
}]>
```
`banner: `type Snippet = /*unresolved*/ any`Snippet<[{ `text: string`text: string }]> } = ````
function $props(): any
namespace $props
```
`
Declares the props that a component accepts. Example:
```
let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();
```

https://svelte.dev/docs/svelte/$props
$props();`
```

You can only call a snippet through the `{@render ...}` tag.
See the snippet documentation for more info.
```
interface Snippet<Parameters extends unknown[] = []> {…}
```

```
(
	this: void,
	// this conditional allows tuples but not arrays. Arrays would indicate a
	// rest parameter type, which is not supported. If rest parameters are added
	// in the future, the condition can be removed.
	...args: number extends Parameters['length'] ? never : Parameters
): {
	'{@render ...} must be called with a Snippet': "import type { Snippet } from 'svelte'";
} & typeof SnippetReturn;
```



---

```
{#snippet name()}...{/snippet}
```

```
{#snippet name(param1, param2, paramN)}...{/snippet}
```

Snippets, and render tags, are a way to create reusable chunks of markup inside your components. Instead of writing duplicative code like this...
```
{#each images as image}
	{#if image.href}
		<a href={image.href}>
			<figure>
				<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
				<figcaption>{image.caption}</figcaption>
			</figure>
		</a>
	{:else}
		<figure>
			<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
			<figcaption>{image.caption}</figcaption>
		</figure>
	{/if}
{/each}
```

...you can write this:
```
{#snippet figure(image)}
	<figure>
		<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
		<figcaption>{image.caption}</figcaption>
	</figure>
{/snippet}

{#each images as image}
	{#if image.href}
		<a href={image.href}>
			{@render figure(image)}
		</a>
	{:else}
		{@render figure(image)}
	{/if}
{/each}
```

Like function declarations, snippets can have an arbitrary number of parameters, which can have default values, and you can destructure each parameter. You cannot use rest parameters, however.
##  Snippet scope
Snippets can be declared anywhere inside your component. They can reference values declared outside themselves, for example in the `<script>` tag or in `{#each ...}` blocks (demo)...
```
<script>
	let { message = `it's great to see you!` } = $props();
</script>

{#snippet hello(name)}
	<p>hello {name}! {message}!</p>
{/snippet}

{@render hello('alice')}
{@render hello('bob')}
```

...and they are ‘visible’ to everything in the same lexical scope (i.e. siblings, and children of those siblings):
```
<div>
	{#snippet x()}
		{#snippet y()}...{/snippet}

		<!-- this is fine -->
		{@render y()}
	{/snippet}

	<!-- this will error, as `y` is not in scope -->
	{@render y()}
</div>

<!-- this will also error, as `x` is not in scope -->
{@render x()}
```

Snippets can reference themselves and each other (demo):
```
{#snippet blastoff()}
	<span>🚀</span>
{/snippet}

{#snippet countdown(n)}
	{#if n > 0}
		<span>{n}...</span>
		{@render countdown(n - 1)}
	{:else}
		{@render blastoff()}
	{/if}
{/snippet}

{@render countdown(10)}
```

##  Passing snippets to components
###  Explicit props
Within the template, snippets are values just like any other. As such, they can be passed to components as props (demo):
```
<script>
	import Table from './Table.svelte';

	const fruits = [
		{ name: 'apples', qty: 5, price: 2 },
		{ name: 'bananas', qty: 10, price: 1 },
		{ name: 'cherries', qty: 20, price: 0.5 }
	];
</script>

{#snippet header()}
	<th>fruit</th>
	<th>qty</th>
	<th>price</th>
	<th>total</th>
{/snippet}

{#snippet row(d)}
	<td>{d.name}</td>
	<td>{d.qty}</td>
	<td>{d.price}</td>
	<td>{d.qty * d.price}</td>
{/snippet}

<Table data={fruits} {header} {row} />
```

Think about it like passing content instead of data to a component. The concept is similar to slots in web components.
###  Implicit props
As an authoring convenience, snippets declared directly _inside_ a component implicitly become props _on_ the component (demo):
```
<!-- this is semantically the same as the above -->
<Table data={fruits}>
	{#snippet header()}
		<th>fruit</th>
		<th>qty</th>
		<th>price</th>
		<th>total</th>
	{/snippet}

	{#snippet row(d)}
		<td>{d.name}</td>
		<td>{d.qty}</td>
		<td>{d.price}</td>
		<td>{d.qty * d.price}</td>
	{/snippet}
</Table>
```

###  Implicit children snippet
Any content inside the component tags that is _not_ a snippet declaration implicitly becomes part of the `children` snippet (demo):
App
```
<Button>click me</Button>
```

Button
```
<script>
	let { children } = $props();
</script>

<!-- result will be <button>click me</button> -->
<button>{@render children()}</button>
```
```
<script lang="ts">
	let { children } = $props();
</script>

<!-- result will be <button>click me</button> -->
<button>{@render children()}</button>
```

> Note that you cannot have a prop called `children` if you also have content inside the component — for this reason, you should avoid having props with that name
###  Optional snippet props
You can declare snippet props as being optional. You can either use optional chaining to not render anything if the snippet isn’t set...
```
<script>
	let { children } = $props();
</script>

{@render children?.()}
```

...or use an `#if` block to render fallback content:
```
<script>
	let { children } = $props();
</script>

{#if children}
	{@render children()}
{:else}
	fallback content
{/if}
```

##  Typing snippets
Snippets implement the `Snippet` interface imported from `'svelte'`:
```
<script lang="ts">
	import type { Snippet } from 'svelte';

	interface Props {
		data: any[];
		children: Snippet;
		row: Snippet<[any]>;
	}

	let { data, children, row }: Props = $props();
</script>
```

With this change, red squigglies will appear if you try and use the component without providing a `data` prop and a `row` snippet. Notice that the type argument provided to `Snippet` is a tuple, since snippets can have multiple parameters.
We can tighten things up further by declaring a generic, so that `data` and `row` refer to the same type:
```
<script lang="ts" generics="T">
	import type { Snippet } from 'svelte';

	let {
		data,
		children,
		row
	}: {
		data: T[];
		children: Snippet;
		row: Snippet<[T]>;
	} = $props();
</script>
```

##  Exporting snippets
Snippets declared at the top level of a `.svelte` file can be exported from a `<script module>` for use in other components, provided they don’t reference any declarations in a non-module `<script>` (whether directly or indirectly, via other snippets) (demo):
```
<script module>
	export { add };
</script>

{#snippet add(a, b)}
	{a} + {b} = {a + b}
{/snippet}
```

> This requires Svelte 5.5.0 or newer
##  Programmatic snippets
Snippets can be created programmatically with the `createRawSnippet` API. This is intended for advanced use cases.
##  Snippets and slots
In Svelte 4, content can be passed to components using slots. Snippets are more powerful and flexible, and as such slots are deprecated in Svelte 5.
Edit this page on GitHub llms.txt
previous next
{#await ...} {@render ...}
```
{#snippet name()}...{/snippet}
```

```
{#snippet name(param1, param2, paramN)}...{/snippet}
```

Snippets, and render tags, are a way to create reusable chunks of markup inside your components. Instead of writing duplicative code like this...
```
{#each images as image}
	{#if image.href}
		<a href={image.href}>
			<figure>
				<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
				<figcaption>{image.caption}</figcaption>
			</figure>
		</a>
	{:else}
		<figure>
			<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
			<figcaption>{image.caption}</figcaption>
		</figure>
	{/if}
{/each}
```

...you can write this:
```
{#snippet figure(image)}
	<figure>
		<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
		<figcaption>{image.caption}</figcaption>
	</figure>
{/snippet}

{#each images as image}
	{#if image.href}
		<a href={image.href}>
			{@render figure(image)}
		</a>
	{:else}
		{@render figure(image)}
	{/if}
{/each}
```

Like function declarations, snippets can have an arbitrary number of parameters, which can have default values, and you can destructure each parameter. You cannot use rest parameters, however.
##  Snippet scope
Snippets can be declared anywhere inside your component. They can reference values declared outside themselves, for example in the `<script>` tag or in `{#each ...}` blocks (demo)...
```
<script>
	let { message = `it's great to see you!` } = $props();
</script>

{#snippet hello(name)}
	<p>hello {name}! {message}!</p>
{/snippet}

{@render hello('alice')}
{@render hello('bob')}
```

...and they are ‘visible’ to everything in the same lexical scope (i.e. siblings, and children of those siblings):
```
<div>
	{#snippet x()}
		{#snippet y()}...{/snippet}

		<!-- this is fine -->
		{@render y()}
	{/snippet}

	<!-- this will error, as `y` is not in scope -->
	{@render y()}
</div>

<!-- this will also error, as `x` is not in scope -->
{@render x()}
```

Snippets can reference themselves and each other (demo):
```
{#snippet blastoff()}
	<span>🚀</span>
{/snippet}

{#snippet countdown(n)}
	{#if n > 0}
		<span>{n}...</span>
		{@render countdown(n - 1)}
	{:else}
		{@render blastoff()}
	{/if}
{/snippet}

{@render countdown(10)}
```

##  Passing snippets to components
###  Explicit props
Within the template, snippets are values just like any other. As such, they can be passed to components as props (demo):
```
<script>
	import Table from './Table.svelte';

	const fruits = [
		{ name: 'apples', qty: 5, price: 2 },
		{ name: 'bananas', qty: 10, price: 1 },
		{ name: 'cherries', qty: 20, price: 0.5 }
	];
</script>

{#snippet header()}
	<th>fruit</th>
	<th>qty</th>
	<th>price</th>
	<th>total</th>
{/snippet}

{#snippet row(d)}
	<td>{d.name}</td>
	<td>{d.qty}</td>
	<td>{d.price}</td>
	<td>{d.qty * d.price}</td>
{/snippet}

<Table data={fruits} {header} {row} />
```

Think about it like passing content instead of data to a component. The concept is similar to slots in web components.
###  Implicit props
As an authoring convenience, snippets declared directly _inside_ a component implicitly become props _on_ the component (demo):
```
<!-- this is semantically the same as the above -->
<Table data={fruits}>
	{#snippet header()}
		<th>fruit</th>
		<th>qty</th>
		<th>price</th>
		<th>total</th>
	{/snippet}

	{#snippet row(d)}
		<td>{d.name}</td>
		<td>{d.qty}</td>
		<td>{d.price}</td>
		<td>{d.qty * d.price}</td>
	{/snippet}
</Table>
```

###  Implicit children snippet
Any content inside the component tags that is _not_ a snippet declaration implicitly becomes part of the `children` snippet (demo):
App
```
<Button>click me</Button>
```

Button
```
<script>
	let { children } = $props();
</script>

<!-- result will be <button>click me</button> -->
<button>{@render children()}</button>
```
```
<script lang="ts">
	let { children } = $props();
</script>

<!-- result will be <button>click me</button> -->
<button>{@render children()}</button>
```

> Note that you cannot have a prop called `children` if you also have content inside the component — for this reason, you should avoid having props with that name
###  Optional snippet props
You can declare snippet props as being optional. You can either use optional chaining to not render anything if the snippet isn’t set...
```
<script>
	let { children } = $props();
</script>

{@render children?.()}
```

...or use an `#if` block to render fallback content:
```
<script>
	let { children } = $props();
</script>

{#if children}
	{@render children()}
{:else}
	fallback content
{/if}
```

##  Typing snippets
Snippets implement the `Snippet` interface imported from `'svelte'`:
```
<script lang="ts">
	import type { Snippet } from 'svelte';

	interface Props {
		data: any[];
		children: Snippet;
		row: Snippet<[any]>;
	}

	let { data, children, row }: Props = $props();
</script>
```

With this change, red squigglies will appear if you try and use the component without providing a `data` prop and a `row` snippet. Notice that the type argument provided to `Snippet` is a tuple, since snippets can have multiple parameters.
We can tighten things up further by declaring a generic, so that `data` and `row` refer to the same type:
```
<script lang="ts" generics="T">
	import type { Snippet } from 'svelte';

	let {
		data,
		children,
		row
	}: {
		data: T[];
		children: Snippet;
		row: Snippet<[T]>;
	} = $props();
</script>
```

##  Exporting snippets
Snippets declared at the top level of a `.svelte` file can be exported from a `<script module>` for use in other components, provided they don’t reference any declarations in a non-module `<script>` (whether directly or indirectly, via other snippets) (demo):
```
<script module>
	export { add };
</script>

{#snippet add(a, b)}
	{a} + {b} = {a + b}
{/snippet}
```

> This requires Svelte 5.5.0 or newer
##  Programmatic snippets
Snippets can be created programmatically with the `createRawSnippet` API. This is intended for advanced use cases.
##  Snippets and slots
In Svelte 4, content can be passed to components using slots. Snippets are more powerful and flexible, and as such slots are deprecated in Svelte 5.
Edit this page on GitHub llms.txt
previous next
{#await ...} {@render ...}
```
{#snippet name()}...{/snippet}
```

```
{#snippet name(param1, param2, paramN)}...{/snippet}
```

Snippets, and render tags, are a way to create reusable chunks of markup inside your components. Instead of writing duplicative code like this...
```
{#each images as image}
	{#if image.href}
		<a href={image.href}>
			<figure>
				<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
				<figcaption>{image.caption}</figcaption>
			</figure>
		</a>
	{:else}
		<figure>
			<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
			<figcaption>{image.caption}</figcaption>
		</figure>
	{/if}
{/each}
```

...you can write this:
```
{#snippet figure(image)}
	<figure>
		<img src={image.src} alt={image.caption} width={image.width} height={image.height} />
		<figcaption>{image.caption}</figcaption>
	</figure>
{/snippet}

{#each images as image}
	{#if image.href}
		<a href={image.href}>
			{@render figure(image)}
		</a>
	{:else}
		{@render figure(image)}
	{/if}
{/each}
```

Like function declarations, snippets can have an arbitrary number of parameters, which can have default values, and you can destructure each parameter. You cannot use rest parameters, however.
##  Snippet scope
Snippets can be declared anywhere inside your component. They can reference values declared outside themselves, for example in the `<script>` tag or in `{#each ...}` blocks (demo)...
```
<script>
	let { message = `it's great to see you!` } = $props();
</script>

{#snippet hello(name)}
	<p>hello {name}! {message}!</p>
{/snippet}

{@render hello('alice')}
{@render hello('bob')}
```

...and they are ‘visible’ to everything in the same lexical scope (i.e. siblings, and children of those siblings):
```
<div>
	{#snippet x()}
		{#snippet y()}...{/snippet}

		<!-- this is fine -->
		{@render y()}
	{/snippet}

	<!-- this will error, as `y` is not in scope -->
	{@render y()}
</div>

<!-- this will also error, as `x` is not in scope -->
{@render x()}
```

Snippets can reference themselves and each other (demo):
```
{#snippet blastoff()}
	<span>🚀</span>
{/snippet}

{#snippet countdown(n)}
	{#if n > 0}
		<span>{n}...</span>
		{@render countdown(n - 1)}
	{:else}
		{@render blastoff()}
	{/if}
{/snippet}

{@render countdown(10)}
```

##  Passing snippets to components
###  Explicit props
Within the template, snippets are values just like any other. As such, they can be passed to components as props (demo):
```
<script>
	import Table from './Table.svelte';

	const fruits = [
		{ name: 'apples', qty: 5, price: 2 },
		{ name: 'bananas', qty: 10, price: 1 },
		{ name: 'cherries', qty: 20, price: 0.5 }
	];
</script>

{#snippet header()}
	<th>fruit</th>
	<th>qty</th>
	<th>price</th>
	<th>total</th>
{/snippet}

{#snippet row(d)}
	<td>{d.name}</td>
	<td>{d.qty}</td>
	<td>{d.price}</td>
	<td>{d.qty * d.price}</td>
{/snippet}

<Table data={fruits} {header} {row} />
```

Think about it like passing content instead of data to a component. The concept is similar to slots in web components.
###  Implicit props
As an authoring convenience, snippets declared directly _inside_ a component implicitly become props _on_ the component (demo):
```
<!-- this is semantically the same as the above -->
<Table data={fruits}>
	{#snippet header()}
		<th>fruit</th>
		<th>qty</th>
		<th>price</th>
		<th>total</th>
	{/snippet}

	{#snippet row(d)}
		<td>{d.name}</td>
		<td>{d.qty}</td>
		<td>{d.price}</td>
		<td>{d.qty * d.price}</td>
	{/snippet}
</Table>
```

###  Implicit children snippet
Any content inside the component tags that is _not_ a snippet declaration implicitly becomes part of the `children` snippet (demo):
App
```
<Button>click me</Button>
```

Button
```
<script>
	let { children } = $props();
</script>

<!-- result will be <button>click me</button> -->
<button>{@render children()}</button>
```
```
<script lang="ts">
	let { children } = $props();
</script>

<!-- result will be <button>click me</button> -->
<button>{@render children()}</button>
```

> Note that you cannot have a prop called `children` if you also have content inside the component — for this reason, you should avoid having props with that name
###  Optional snippet props
You can declare snippet props as being optional. You can either use optional chaining to not render anything if the snippet isn’t set...
```
<script>
	let { children } = $props();
</script>

{@render children?.()}
```

...or use an `#if` block to render fallback content:
```
<script>
	let { children } = $props();
</script>

{#if children}
	{@render children()}
{:else}
	fallback content
{/if}
```

##  Typing snippets
Snippets implement the `Snippet` interface imported from `'svelte'`:
```
<script lang="ts">
	import type { Snippet } from 'svelte';

	interface Props {
		data: any[];
		children: Snippet;
		row: Snippet<[any]>;
	}

	let { data, children, row }: Props = $props();
</script>
```

With this change, red squigglies will appear if you try and use the component without providing a `data` prop and a `row` snippet. Notice that the type argument provided to `Snippet` is a tuple, since snippets can have multiple parameters.
We can tighten things up further by declaring a generic, so that `data` and `row` refer to the same type:
```
<script lang="ts" generics="T">
	import type { Snippet } from 'svelte';

	let {
		data,
		children,
		row
	}: {
		data: T[];
		children: Snippet;
		row: Snippet<[T]>;
	} = $props();
</script>
```

##  Exporting snippets
Snippets declared at the top level of a `.svelte` file can be exported from a `<script module>` for use in other components, provided they don’t reference any declarations in a non-module `<script>` (whether directly or indirectly, via other snippets) (demo):
```
<script module>
	export { add };
</script>

{#snippet add(a, b)}
	{a} + {b} = {a + b}
{/snippet}
```

> This requires Svelte 5.5.0 or newer
##  Programmatic snippets
Snippets can be created programmatically with the `createRawSnippet` API. This is intended for advanced use cases.
##  Snippets and slots
In Svelte 4, content can be passed to components using slots. Snippets are more powerful and flexible, and as such slots are deprecated in Svelte 5.


---




---




---

> In Svelte 5.29 and newer, consider using attachments instead, as they are more flexible and composable.
Actions are functions that are called when an element is mounted. They are added with the `use:` directive, and will typically use an `$effect` so that they can reset any state when the element is unmounted:
App
```
<script>
	/** @type {import('svelte/action').Action} */
	function myaction(node) {
		// the node has been mounted in the DOM

		$effect(() => {
			// setup goes here

			return () => {
				// teardown goes here
			};
		});
	}
</script>

<div use:myaction>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const myaction: Action = (node) => {
		// the node has been mounted in the DOM

		$effect(() => {
			// setup goes here

			return () => {
				// teardown goes here
			};
		});
	};
</script>

<div use:myaction>...</div>
```

An action can be called with an argument:
App
```
<script>
	/** @type {import('svelte/action').Action} */
	function myaction(node, data) {
		// ...
	}
</script>

<div use:myaction={data}>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const myaction: Action = (node, data) => {
		// ...
	};
</script>

<div use:myaction={data}>...</div>
```

The action is only called once (but not during server-side rendering) — it will _not_ run again if the argument changes.
> Legacy mode
> Prior to the `$effect` rune, actions could return an object with `update` and `destroy` methods, where `update` would be called with the latest value of the argument if it changed. Using effects is preferred.
##  Typing
The `Action` interface receives three optional type arguments — a node type (which can be `Element`, if the action applies to everything), a parameter, and any custom event handlers created by the action:
App
```
<script>
	/**
	 * @type {import('svelte/action').Action<
	 * 	HTMLDivElement,
	 * 	undefined,
	 * 	{
	 * 		onswiperight: (e: CustomEvent) => void;
	 * 		onswipeleft: (e: CustomEvent) => void;
	 * 		// ...
	 * 	}
	 * >}
	 */
	function gestures(node) {
		$effect(() => {
			// ...
			node.dispatchEvent(new CustomEvent('swipeleft'));

			// ...
			node.dispatchEvent(new CustomEvent('swiperight'));
		});
	}
</script>

<div
	use:gestures
	onswipeleft={next}
	onswiperight={prev}
>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const gestures: Action<
		HTMLDivElement,
		undefined,
		{
			onswiperight: (e: CustomEvent) => void;
			onswipeleft: (e: CustomEvent) => void;
			// ...
		}
	> = (node) => {
		$effect(() => {
			// ...
			node.dispatchEvent(new CustomEvent('swipeleft'));

			// ...
			node.dispatchEvent(new CustomEvent('swiperight'));
		});
	};
</script>

<div
	use:gestures
	onswipeleft={next}
	onswiperight={prev}
>...</div>
```

Edit this page on GitHub llms.txt
previous next
bind: transition:
> In Svelte 5.29 and newer, consider using attachments instead, as they are more flexible and composable.
Actions are functions that are called when an element is mounted. They are added with the `use:` directive, and will typically use an `$effect` so that they can reset any state when the element is unmounted:
App
```
<script>
	/** @type {import('svelte/action').Action} */
	function myaction(node) {
		// the node has been mounted in the DOM

		$effect(() => {
			// setup goes here

			return () => {
				// teardown goes here
			};
		});
	}
</script>

<div use:myaction>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const myaction: Action = (node) => {
		// the node has been mounted in the DOM

		$effect(() => {
			// setup goes here

			return () => {
				// teardown goes here
			};
		});
	};
</script>

<div use:myaction>...</div>
```

An action can be called with an argument:
App
```
<script>
	/** @type {import('svelte/action').Action} */
	function myaction(node, data) {
		// ...
	}
</script>

<div use:myaction={data}>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const myaction: Action = (node, data) => {
		// ...
	};
</script>

<div use:myaction={data}>...</div>
```

The action is only called once (but not during server-side rendering) — it will _not_ run again if the argument changes.
> Legacy mode
> Prior to the `$effect` rune, actions could return an object with `update` and `destroy` methods, where `update` would be called with the latest value of the argument if it changed. Using effects is preferred.
##  Typing
The `Action` interface receives three optional type arguments — a node type (which can be `Element`, if the action applies to everything), a parameter, and any custom event handlers created by the action:
App
```
<script>
	/**
	 * @type {import('svelte/action').Action<
	 * 	HTMLDivElement,
	 * 	undefined,
	 * 	{
	 * 		onswiperight: (e: CustomEvent) => void;
	 * 		onswipeleft: (e: CustomEvent) => void;
	 * 		// ...
	 * 	}
	 * >}
	 */
	function gestures(node) {
		$effect(() => {
			// ...
			node.dispatchEvent(new CustomEvent('swipeleft'));

			// ...
			node.dispatchEvent(new CustomEvent('swiperight'));
		});
	}
</script>

<div
	use:gestures
	onswipeleft={next}
	onswiperight={prev}
>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const gestures: Action<
		HTMLDivElement,
		undefined,
		{
			onswiperight: (e: CustomEvent) => void;
			onswipeleft: (e: CustomEvent) => void;
			// ...
		}
	> = (node) => {
		$effect(() => {
			// ...
			node.dispatchEvent(new CustomEvent('swipeleft'));

			// ...
			node.dispatchEvent(new CustomEvent('swiperight'));
		});
	};
</script>

<div
	use:gestures
	onswipeleft={next}
	onswiperight={prev}
>...</div>
```

Edit this page on GitHub llms.txt
previous next
bind: transition:
> In Svelte 5.29 and newer, consider using attachments instead, as they are more flexible and composable.
Actions are functions that are called when an element is mounted. They are added with the `use:` directive, and will typically use an `$effect` so that they can reset any state when the element is unmounted:
App
```
<script>
	/** @type {import('svelte/action').Action} */
	function myaction(node) {
		// the node has been mounted in the DOM

		$effect(() => {
			// setup goes here

			return () => {
				// teardown goes here
			};
		});
	}
</script>

<div use:myaction>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const myaction: Action = (node) => {
		// the node has been mounted in the DOM

		$effect(() => {
			// setup goes here

			return () => {
				// teardown goes here
			};
		});
	};
</script>

<div use:myaction>...</div>
```

An action can be called with an argument:
App
```
<script>
	/** @type {import('svelte/action').Action} */
	function myaction(node, data) {
		// ...
	}
</script>

<div use:myaction={data}>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const myaction: Action = (node, data) => {
		// ...
	};
</script>

<div use:myaction={data}>...</div>
```

The action is only called once (but not during server-side rendering) — it will _not_ run again if the argument changes.
> Legacy mode
> Prior to the `$effect` rune, actions could return an object with `update` and `destroy` methods, where `update` would be called with the latest value of the argument if it changed. Using effects is preferred.
##  Typing
The `Action` interface receives three optional type arguments — a node type (which can be `Element`, if the action applies to everything), a parameter, and any custom event handlers created by the action:
App
```
<script>
	/**
	 * @type {import('svelte/action').Action<
	 * 	HTMLDivElement,
	 * 	undefined,
	 * 	{
	 * 		onswiperight: (e: CustomEvent) => void;
	 * 		onswipeleft: (e: CustomEvent) => void;
	 * 		// ...
	 * 	}
	 * >}
	 */
	function gestures(node) {
		$effect(() => {
			// ...
			node.dispatchEvent(new CustomEvent('swipeleft'));

			// ...
			node.dispatchEvent(new CustomEvent('swiperight'));
		});
	}
</script>

<div
	use:gestures
	onswipeleft={next}
	onswiperight={prev}
>...</div>
```
```
<script lang="ts">
	import type { Action } from 'svelte/action';


	const gestures: Action<
		HTMLDivElement,
		undefined,
		{
			onswiperight: (e: CustomEvent) => void;
			onswipeleft: (e: CustomEvent) => void;
			// ...
		}
	> = (node) => {
		$effect(() => {
			// ...
			node.dispatchEvent(new CustomEvent('swipeleft'));

			// ...
			node.dispatchEvent(new CustomEvent('swiperight'));
		});
	};
</script>

<div
	use:gestures
	onswipeleft={next}
	onswiperight={prev}
>...</div>
```



---

> **rune** /ruːn/ _noun_
> A letter or mark used as a mystical or magic symbol.
Runes are symbols that you use in `.svelte` and `.svelte.js` / `.svelte.ts` files to control the Svelte compiler. If you think of Svelte as a language, runes are part of the syntax — they are _keywords_.
Runes have a `$` prefix and look like functions:
```
let let message: stringmessage = ```
function $state<"hello">(initial: "hello"): "hello" (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state('hello');`
```

They differ from normal JavaScript functions in important ways, however:
  * You don’t need to import them — they are part of the language
  * They’re not values — you can’t assign them to a variable or pass them as arguments to a function
  * Just like JavaScript keywords, they are only valid in certain positions (the compiler will help you if you put them in the wrong place)


> Legacy mode
> Runes didn’t exist prior to Svelte 5.
Edit this page on GitHub llms.txt
previous next
.svelte.js and .svelte.ts files $state
> **rune** /ruːn/ _noun_
> A letter or mark used as a mystical or magic symbol.
Runes are symbols that you use in `.svelte` and `.svelte.js` / `.svelte.ts` files to control the Svelte compiler. If you think of Svelte as a language, runes are part of the syntax — they are _keywords_.
Runes have a `$` prefix and look like functions:
```
let let message: stringmessage = ```
function $state<"hello">(initial: "hello"): "hello" (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state('hello');`
```

They differ from normal JavaScript functions in important ways, however:
  * You don’t need to import them — they are part of the language
  * They’re not values — you can’t assign them to a variable or pass them as arguments to a function
  * Just like JavaScript keywords, they are only valid in certain positions (the compiler will help you if you put them in the wrong place)


> Legacy mode
> Runes didn’t exist prior to Svelte 5.
Edit this page on GitHub llms.txt
previous next
.svelte.js and .svelte.ts files $state
> **rune** /ruːn/ _noun_
> A letter or mark used as a mystical or magic symbol.
Runes are symbols that you use in `.svelte` and `.svelte.js` / `.svelte.ts` files to control the Svelte compiler. If you think of Svelte as a language, runes are part of the syntax — they are _keywords_.
Runes have a `$` prefix and look like functions:
```
let let message: stringmessage = ```
function $state<"hello">(initial: "hello"): "hello" (+1 overload)
namespace $state
```
`
Declares reactive state.
Example:
```
let count = $state(0);
```

https://svelte.dev/docs/svelte/$state
@paraminitial The initial value
$state('hello');`
```

They differ from normal JavaScript functions in important ways, however:
  * You don’t need to import them — they are part of the language
  * They’re not values — you can’t assign them to a variable or pass them as arguments to a function
  * Just like JavaScript keywords, they are only valid in certain positions (the compiler will help you if you put them in the wrong place)


> Legacy mode
> Runes didn’t exist prior to Svelte 5.


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!


---

# Not found!
If you were expecting to find something here, please drop by the Discord chatroom and let us know, or raise an issue on GitHub. Thanks!
